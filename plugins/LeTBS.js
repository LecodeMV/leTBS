/*
#=============================================================================
# Lecode's Tactical Battle System
# LeTBS.js
# By Lecode
# Version 0.77.2
#-----------------------------------------------------------------------------
# TERMS OF USE
#-----------------------------------------------------------------------------
# https://github.com/LecodeMV/leTBS/blob/master/LICENSE.txt
#-----------------------------------------------------------------------------
# Version History
#-----------------------------------------------------------------------------
# - 0.0 : Beta started.
# - 0.1
#       *Battles start and end correctly.
#	    *Troop events are correctly triggered in battle. (mostly)
#       *Added an end window which appears when pressing ESC on the command window.
#       *That window allows you to escape and change options.
#       *Added the tags and parameters for one time move only and one time offense only.
#       *Fixed some errors in the demo.
# - 0.2
#       *The Item command is functional.
#       *Added custom move scopes and options.
#       *Downgraded the turn order visual for now to fix some bugs.
#       *Added a new option for turn order: "fair Distribution".
#       *Status window is updated when a target is selected.
#       *There's now a help window. Status window is shifted if needed.
# - 0.3
#       *The mouse is supported.
#       *Prototype of the projectiles system.
#       *Prototype of the AI.
#       *Fixed a bug and improved the Turn Order Visual Version A.
#       *85% of the tile effects and marks system.
#       *Fixed a bug with the line of sight.
# - 0.4
#       *Now there is ony one unique tag.
#       *Support custom sprites. (Yay !)
#       *AI improved.
#       *Added AI patterns. They can be used in AI commands.
#       *Now each entity has his own sequence system. This allows simultaneous sequences.
#       *Added some sequence commands.
#       *Now a sequence is played for the following events:
#       *battle start, turn start, victory, death, damaged, healed, buffed, weakened.
# - 0.5
#       *Projectile system completed
#       *Tile, Mark & Aura effects completed
#       *Added knockback damage
#       *Fixed and added some sequence commands
#       *Fixed some bugs
#       *Created DamagePopupEX
# - 0.6
#       *Added these sequence commands: 'call_for_every_cell', 'call_for_every_entity', 'reach_target'
#       *Added these sequence commands: 'save_cells', 'save_entities'
#       *Added these tag instructions: 'sprite_name' and 'sprite_config'
#       *Added a region ID to setup non-walkable tile but free for the line of sight (water)
#       *Improved AI
#       *Reduced lag generated by AI process
#       *Created Win Conditions ADD-ON
#       *New feature: TBS Events and Neutral entities
#       *Map events are now supported - battlers can interact with them.
#       *Support directional scope
#       *Added a new scope type: path
#       *Added an option to instantiate all enemies at the same time
#       *Start messages can be disabled
#       *Added some plugin command for in-battle eventing
#       *Added some event tag for in-battle eventing
#       *Fixed a bug where the system freezes on positioning phase
#       *Fixed the "param is not defined" error when an enemy starts its turn
#       *Fixed a bug where custom scopes ignore line of sight
#       *Fixed parallax scrolling when the cursor move
#       *Fixed a bug where move points could be negative
#       *Fixed a bug where knockback distance could be negative
#       *Fixed a bug where the game crashes when AI try to resume a move action
#       *The entities layer has now a correct Z coordinate
#       *Fixed a bug where entities overlap themselves
#       *Fixed a bug where the scope and marks layers weren't visible
#       *When the active entity die, the scope layer is correctly cleared
#       *Dead enemies don't try to play their turn anymore
#       *Dead actors can't be placed at the start of battles
#       *Battlers are correctly revived
#       *The turn order visual is correctly updated when en entity is revived
#       *The wait parameter for tile effects is correctly applied
#       *The parameter 'false' in the sequence commands 'push' and 'pull' to avoid 
#        knockback damage now works as intended
#       *Fixed 2 bugs related to the mark and tile effect add-on and improved it (1.1)
#       *Selected cells with TouchInput on large map are correctly handled
# - 0.61
#       *Optimized cells locating
#       *Added a trigger type for battle end
# - 0.7
#       *Reworked the battle HUD
#       *Improved the positioning phase, you can also specify fixed actor cells
#       *The positioning phase is now correctly resumed
#       *The mouse is now correctly supported during the positioning phase
#       *Defeat is now based on actors in battle and not the whole party (bugfix)
#       *Added a minimal parameter to scopes
#       *Scopes and AoEs parameters are now evaluated
#       *Added smooth map scrolling system in battle
#       *Added a parameter to hide AI's scopes
#       *Counter attacks and magic reflection are now supported
#       *Added a summon system (add-on)
#       *The system now automatically use RPT ressources (add-on)
#       *Added these sequence commands: switch_cells, use_skill
#       *Added a fast sequence system as well as arguments for sequences
#       *Added a HUD that appear on an entity when the mouse is over it (add-on)
#       *Added some tag instructions to change sprite scale, tone and hue
#       *Added a tag "has_no_corpse" to hide an entity's corpse
#       *Added states and equipment animations in battle
#       *Added a map tactical and auto battle system
#       *The tag sprite_name is correctly taken into account into these components: Turn Order, Window Status
#       *The selected AoE now blinks
#       *Greatly improved targets and cells selection in sequences
#       *The AI Core is completed: all behavior are supported
#       *The AI correctly use its skills and doesn't stick with just one
#       *The AI correctly calculate the closest/farhest path to a given cell (no more stuck by obstacles)
#       *The AI uses smartly AoE skills to hit, heal or boost multiple targets
#       *The AI can use move skills to escape or reach targets
#       *The AI doesn't escape anymore if it's already too far from actors (prevents endless battles)
#       *The AI is able to focus its action on a specified target
#       *Added a parameter to define how much AI should try to escape (prevents endless battles)
#       *The AI now handles confusion states
#       *Added a parameter to delay AI calculation rate, in order to prevent freezes
#       *Added a configuration tag for AI
#       *Fixed a bug where collapse effects are triggered multiple times
#       *Projectiles and entities are now summoned for each cell in the AoE
#       *The turn order is now correctly determined
#       *Command, Skill and Item windows are now correctly positioned
#       *Skills can now directly alter move points with the instruction "change_move_points: +x /-x"
#       *Move points popup is now added - Though a little bugged
#       *Fixed a bug where triggering tiles and mark effects change the next
#       *action damage
# - 0.7a
#       *Fixed a bug where the "Free_LOS" command in event comments would not work
#       *Fixed a bug where the last summon data are used instead of a new data
#       *Sprites of summoned entities are destroyed
# - 0.7b
#       *The automatic call of the battle start is now correctly processed
#       *Fixed actors cannot be swaped
#       *The command, skill and item windows can't be off the screen
# - 0.7c
#       *Fixed a bug where deleted events could make the game crash
#       *The battle window layer isn't affected by the screen filters anymore
#       *Victory branches are now correctly supported
#       *The command window stay closed at the battle end
# - 0.7d
#       * "Cannot move" states are handled
#       *The battlers layer is now correctly below the upper map layer
#       *Added a tag to make the AI play an actor
#       *Added sequence overloading
#       *Entities can now stay on a corpse if it's opacity is 0
#       *Added the sequence command "sprite_prop"
# - 0.75
#       * Added 7 new features to control the timeline (add-on)
#       * Added charged skills
#       * Improved the turn order visual
#       * Added dynamic turn order numbers
#       * The command window is now customizable
#       * Scopes can now be previewed
#       * Added a auto-selection system
#       * Added a skill bubbles system
#       * Added some plugin parameters
#       * Cannot place more actors than available spots
#       * Fixed the "Cannot read Property `list` of undefined" error
#       * Using TouchInput to select starting cells won't throw an error
#       * The status windows doesn't appear on a dead entity who has no corpse
#       * Scopes with the min parameter are now properly drawn at map corners
#       * Auto status sprites are now correctly setup
#       * The ground is now correctly layered
# - 0.76a
#       * Added restrictions to scopes ("scope_select" tag)
#       * Added evaluated parameters for sequences: [string]
#       * Improved the waiting process of sequences
#       * Battlers can be automatically parsed from raw scopes during sequences
#       * Objects are now properly parsed for sequences
#       * Scopes can now be combined
#       * Added the following template sequences: atk_push(x), atk_rush(x), skill_push(x), skill_pull(x)
#       * where x is the number of cells to push/pull the targets
#       * Added a multi selection system
#       * Added a tile effect to escape battles
#       * Animations tied to entities are correctly disposed when they die
#       * Vertical jumps are now correctly performed
#       * Fixed a bug where projectiles starting point could be wrong
#       * The skill bubble is now correctly positioned to avoid obstructions
#       * Windows above entities are now correctly positioned on large maps
#       * Skills are now correctly categorized in the window skill
#       * Fixed a bug where stuck AI entity would make the game crash
#       * Fixed a flaw in AI logic causing entities to skip turns
#       * Do not attempt to preview non-existant skills
#       * Minimal scopes are now drawn properly on map corners
#       * Fixed cross scopes
#       * Fixed the salvation sequence (was using the old commands)
#       * Since 0.75 the tactical layer was above entities. It's now fixed
#       * Event sprites are now correctly below entities level
#       * Fast selection on the positioning windows correctly supports more than 4 members
# - 0.76b
#       * Do not attempt to preview non-existant items
#       * Added parameters to show/hide TP and move points on the status window
#       * Improved how the move points are drawn on the status window
#       * The directional facing can be disabled during the positioning phase
#       * The AI now attacks non active summons when there is nothing else to do
#       * The scope option "include_center" now works as intended with minimal scopes
#       * Fixed the template sequence skill_pull
#       * Patched a compatibility issue with Yanfly's Battle Engine Core preventing
#       * common events from working with LeTBS
#       * The AI now handles sudden loss of move points or ability to move
#       * Added a parameter to move start cells events tied to entities
# - 0.77
#       * Improved the battle flow to support events and common events
#       * Added new trigger types for events
#       * Common events can now be tied to entities and triggered in-battle
#         at specified occasions
#       * Common events can be called in sequences
#       * Tied events can have cooldowns
#       * Auras and marks can now trigger common events, on the fly
#       * The Scan command is now fully supported
#       * Added many plugin commands for eventing and controlling the battle flow
#       * Improved the AI to support on the fly command requests
#       * Rewriting of the tag system
#       * Added a command to alter tag values on the fly
#       * Changing an entity sprite_name or sprite_config updates it's graphic
#       * Added the tag "erased_animation" for states to play an animation
#         when they are removed
#       * Added a bounce effect through sequence commands
#       * Popups are now drawn on the user too
#       * Added body animations to replace sprites
#       * Merged the active and non-active summon classes
#       * Marks and auras can now trigger sequences
#       * Added some tags to set up built-in marks and auras for entities
#       * Skill type icons are now correctly drawn
#       * Move points popup are now correctly supported
#       * Added a module in the configuration file for storing animations
#       * Added a tweening engine
#       * Supports hidden entities
#       * Added if cases in sequence commands
#       * Added a sequence command to execute a TBS plugin command.
#         'plugin_command: [command goes here]'
#       * Default sequences have been tweeked in case of missed hit
#         Push and pull template sequence for example do not move the target
#         unless the attack has hit.
#       * Added various sequence commands
#       * The camera follow entities when they move
#       * Skill effects can now be tied to projectiles
#       * Added these new scope and aoe options: exclude_user, exclude_allies, exclude_enemies
#       * Sequences now automatically convert cell targets to entities, or entity targets
#         to cells when needed
#       * Common events can be linked to actors' commands, using event[ID], just like
#         for skills and items (skill[ID] and item[ID])
#       * Fixed a bug where using animation with "Screen" position would make
#         the game crash
#       * Fixed a bug in the scope parsing function for sequences
#       * AOE's, Scope & AOE options are correctly applied on weapons
#       * Passable entities don't block the line of sight anymore
#       * Fixed the "wait" parameter of the play_pose sequence command
#       * Fixed a bug that could occur during damage evaluation
#       * Fixed a bug during the positioning phase
# - 0.77.1
#       * Improved how trajectories are generated. The engine now uses BÃ©zier curves and spines
#         on top of the legacy function.
#       * Added a module in the config file to customize trajectories.
#       * Moved the sprite configuration module to tags. We are now using
#         <letbs_sprite>[config goes here]</letbs_sprite>.
#       * Entities with no corpse are simply removed from the system on death.
#         Meaning they simply do not exist after their death.
#       * Fixed a bug with the game interpreter, causing a delay in the
#         eventing list process.
#       * Added a tag to disable the AutoSelection add-on on some entities.
#       * Defeat is now exclusively based on actor's death and not on ALL ally entities.
#         Meaning, the battle ends when all actors are dead, even if there are remaining
#         ally entities on the battlefield.
#       * Added the plugin command "ForceJump".
#       * Fixed a bug where entities could incorrectly overlap with each other.
#       * Fixed a bug with the skill bubble plugin.
#       * Fixed a misplacement of animations when the entity's bitmap isn't fully loaded yet.
#       * Fixed a bug where dead entities could take damage from collision.
#       * Fixed some issues on the demo.
#       * Updated some plugins to support the new anchor from TBSEntity_Sprite
# - 0.77.2
#       * AI passes the turn when there is no alive enemy on the battlefield. This is to avoid any bug
#         in the instances where defeating the opposite team doesn't put an end to the battle.
#       * The scan command fully support touch input
#       * The "scope_select" tag can contain multiple values. Ex: scope_select: allies,user
#       * Added a plugin parameter to define a sort method to determine the turn order.
#         By default the method is based on battlers' agi.
#       * Fixed a big where the modifier sequence system from 0.77.1 would prevent "after effects"
#         to take place (counterattack, timeline control effects, ect)
#       * Fixed a bug where statut icons would be incorrectly drawn
# - 0.8
#       * Added two plugin parameters to quickly set up ally and enemy start cells, using
#         terrain identifiers.
#       * Optimized line of sight calculation when the "scope_select" tag is used
#       * Dependency plugins are automatically loaded from libs folder (easystar and co)
#       * Fixed a bug causing scope previsualization to crash the game when the previsualized
#         object is unknown.
#       * Fixed a bug preventing supports skill to be used by AI
#       - Enemy Index: Not working, avoid friendly fire not working
#=============================================================================
*/
var Imported = Imported || {};
Imported.LeTBS = true;

var Lecode = Lecode || {};
Lecode.S_TBS = {};
/*:
 * @plugindesc A tactical battle system with awesome features
 * @author Lecode
 * @version 0.77.2
 *
 * @param Actor Color Cell
 * @desc Color of actor cells.
 * @default #0FC50B
 *
 * @param Enemy Color Cell
 * @desc Color of enemy cells.
 * @default #C50B1B
 *
 * @param Cell Opacity Color
 * @desc Opacity of the positioning cells.
 * @default 175
 *
 * @param Placed Animation
 * @desc Animation ID when a battler is placed.
 * @default 124
 *
 * @param Instantiate All
 * @desc Instantiate all enemies at the same time.
 * @default true
 *
 * @param Display Start Messages
 * @desc Show start messages ?
 * @default false
 *
 * @param -- Misc --
 * @desc [No description]
 * @default 
 *
 * @param Exploration Input
 * @desc Input to trigger exploration.
 * @default shift
 *
 * @param Opacity Input
 * @desc Input to change windows' opacity.
 * @default control
 *
 * @param Min Input Opacity
 * @desc Minimum opacity of windows.
 * @default 0
 *
 * @param Opacity Steps
 * @desc Value of opacity to reduce when inputed.
 * @default 10
 *
 * @param Battle Start Sprite Delay
 * @desc Duration of the battle start sprite.
 * @default 50
 *
 * @param Destination Duration
 * @desc Duration of the destination sprite (when a cell is selected).
 * @default 60
 *
 * @param Move Entity Events
 * @desc [No description]
 * @default false
 *
 * @param -- Turn Order --
 * @desc [No description]
 * @default 
 *
 * @param Turn Order Fair Distribution ?
 * @desc Allow a fair Distribution of the turn order ?
 * @default true
 *
 * @param Turn Order Sort Method
 * @desc Method used to determine the turn order
 * @default b._battler.agi - a._battler.agi
 *
 * @param -- Scopes --
 * @desc [No description]
 * @default 
 *
 * @param Scope Cell Width
 * @desc Width of cells.
 * @default 46
 *
 * @param Scope Cell Height
 * @desc Height of cells. 
 * @default 46
 *
 * @param Obstacle Region Id
 * @desc Region ID for obstacles.
 * @default 250
 *
 * @param Free Obstacle Region Id
 * @desc Region ID for non-blocking los obstacles.
 * @default 249
 *
 * @param -- Move Action --
 * @desc [No description]
 * @default 
 *
 * @param Default Move Scope
 * @desc Default move scope data.
 * @default circle(_mp_)
 *
 * @param Default Move Points
 * @desc Default amount of move points.
 * @default 3
 *
 * @param Move Scope Color
 * @desc Color of the move scope.
 * @default #0A5C85
 *
 * @param Move Scope Opacity
 * @desc Opacity of the move scope.
 * @default 175
 *
 * @param Invalid Move Scope Opacity
 * @desc Opacity of the move scope when cells are invalid.
 * @default 60
 *
 * @param Selected Move Scope Opacity
 * @desc Opacity of the move scope when cells are selected.
 * @default 255
 *
 * @param Selected Move Scope Color
 * @desc Color of the selected move scope.
 * @default #81F7F3
 *
 * @param Enable Directional Facing
 * @desc Battlers will be allowed to change their direction.
 * @default true
 *
 * @param -- Attack Action --
 * @desc [No description]
 * @default 
 *
 * @param Default Attack Animation
 * @desc Default attack animation.
 * @default 1
 *
 * @param Default Attack Sequence
 * @desc Default attack sequence.
 * @default atk
 *
 * @param Default Attack Scope
 * @desc Default attack scope data.
 * @default circle(1)
 *
 * @param Default Attack Ao E
 * @desc Default attack aoe data.
 * @default circle(0)
 *
 * @param Attack Scope Color
 * @desc Color of the attack scope.
 * @default #E20F2B
 *
 * @param Attack Scope Opacity
 * @desc Opacity of the attack scope.
 * @default 175
 *
 * @param Invalid Attack Scope Opacity
 * @desc Opacity of the attack scope when cells are invalid.
 * @default 60
 *
 * @param Selected Attack Scope Color
 * @desc Color of the attack scope.
 * @default #FB3B54
 *
 * @param Selected Attack Scope Opacity
 * @desc Opacity of the attack scope when cells are selected.
 * @default 255
 *
 * @param -- Skill Action --
 * @desc [No description]
 * @default 
 *
 * @param Default Skill Sequence
 * @desc Default skill sequence.
 * @default skill
 *
 * @param Default Skill Scope
 * @desc Default skill scope data.
 * @default circle(3)
 *
 * @param Default Skill Ao E
 * @desc Default skill aoe data.
 * @default circle(0)
 *
 * @param Skill Scope Color
 * @desc Color of the skill scope.
 * @default #E20F2B
 *
 * @param Skill Scope Opacity
 * @desc Opacity of the skill scope.
 * @default 175
 *
 * @param Invalid Skill Scope Opacity
 * @desc Opacity of the skill scope when cells are invalid.
 * @default 60
 *
 * @param Selected Skill Scope Color
 * @desc Color of the selected skill scope.
 * @default #FB3B54
 *
 * @param Selected Skill Scope Opacity
 * @desc Opacity of the skill scope when cells are selected.
 * @default 255
 *
 * @param -- Item Action --
 * @desc [No description]
 * @default 
 *
 * @param Default Item Sequence
 * @desc Default item sequence.
 * @default item
 *
 * @param Default Item Scope
 * @desc Default item scope data.
 * @default circle(3)
 *
 * @param Default Item Ao E
 * @desc Default item aoe data.
 * @default circle(0)
 *
 * @param Item Scope Color
 * @desc Color of the item scope.
 * @default #DF01D7
 *
 * @param Item Scope Opacity
 * @desc Opacity of the item scope.
 * @default 175
 *
 * @param Invalid Item Scope Opacity
 * @desc Opacity of the item scope when cells are invalid.
 * @default 60
 *
 * @param Selected Item Scope Color
 * @desc Color of selected the item scope.
 * @default #F969F4
 *
 * @param Selected Item Scope Opacity
 * @desc Opacity of the item scope when cells are selected.
 * @default 255
 *
 * @param -- Directional Damage --
 * @desc [No description]
 * @default 
 *
 * @param Back Directional Damage Effects
 * @desc Damage % when a battler is hit on the back.
 * @default 15
 *
 * @param Side Directional Damage Effects
 * @desc Damage % when a battler is hit on the sides.
 * @default 0
 *
 * @param Front Directional Damage Effects
 * @desc Damage % when a battler is hit on the face.
 * @default -10
 *
 * @param -- Collision Damage --
 * @desc [No description]
 * @default 
 *
 * @param Default Collision Formula
 * @desc Formula to evaluate collision damage.
 * @default b.mhp * 0.05 * (distance-covered)
 *
 * @param Collission Damage Chain Rate
 * @desc Collision damage chain rate.
 * @default 0.3
 *
 * @param -- Motions --
 * @desc [No description]
 * @default 
 *
 * @param Battlers Move Speed
 * @desc Default move speed.
 * @default 4
 *
 * @param Battlers Frame Delay
 * @desc Default delay value between sprites frames.
 * @default 10
 *
 * @param -- AI --
 * @desc [No description]
 * @default 
 *
 * @param Default Ai Pattern
 * @desc Default AI pattern.
 * @default melee_fighter
 *
 * @param Ai Wait Time
 * @desc AI wait time.
 * @default 5
 *
 * @param Show Scopes
 * @desc [No description]
 * @default false
 *
 * @param Escape Cooldown
 * @desc [No description]
 * @default 2
 *
 * @param Support Cooldown
 * @desc [No description]
 * @default 1
 *
 * @param Ai Process Delay
 * @desc [No description]
 * @default 5
 *
 * @param -- Actions Restrictions --
 * @desc [No description]
 * @default 
 *
 * @param One Time Move
 * @desc Enable the one time move feature. (See doc)
 * @default false
 *
 * @param One Time Offense
 * @desc Enable the one time offense feature. (See doc)
 * @default true
 *
 * @param Auto Pass
 * @desc Enable the auto pass feature. (See doc)
 * @default true
 *
 * @param -- Battle End --
 * @desc [No description]
 * @default 
 *
 * @param Escape Sound
 * @desc Sound when the party try to escape.
 * @default Buzzer2
 *
 * @param End Of Battle Wait
 * @desc Wait amount before the end of the battle.
 * @default 60
 *
 * @param Collapse Animation
 * @desc Default collapse animation.
 * @default 136
 *
 * 
 * @help
 * ============================================================================
 * Introduction
 * ============================================================================
 *
 * This plugin adds a tactical battle system to the engine.
 * LeTBS is inspired from Dofus and Wakfu, both great MMORPG games that use
 * a tactical battle system.
 * 
 * ============================================================================
 * WARNING: Work In Progress
 * ============================================================================
 *
 * The plugin is HEAVY and currentrly being worked on.
 * You can already do amazing things with it, but a lot of features are missing.
 * 
 * The help content as well as the plugin parameters of the core plugins
 * and the add-on will be fully filled once we hit the GOLD version.
 */
//#=============================================================================


/*-------------------------------------------------------------------------
* Get Parameters
-------------------------------------------------------------------------*/
var parameters = PluginManager.parameters('LeTBS');

Lecode.S_TBS.actorColorCell = String(parameters["Actor Color Cell"] || "#0FC50B");	//	(): Color of actor cells.
Lecode.S_TBS.enemyColorCell = String(parameters["Enemy Color Cell"] || "#C50B1B");	//	(): Color of enemy cells.
Lecode.S_TBS.positioningCellOpacity = Number(parameters["Cell Opacity Color"] || 175);	//	(Cell Opacity Color): Opacity of the positioning cells.
Lecode.S_TBS.placedBattlerAnim = Number(parameters["Placed Animation"] || 124);	//	(Placed Animation): Animation ID when a battler is placed.
Lecode.S_TBS.instantiateAll = String(parameters["Instantiate All"] || 'true') === 'true';	//	(): Instantiate all enemies at the same time.
Lecode.S_TBS.displayStartMessages = String(parameters["Display Start Messages"] || 'false') === 'true';	//	(): Show start messages ?
// Divider: -- Misc --
Lecode.S_TBS.explorationInput = String(parameters["Exploration Input"] || "shift");	//	(): Input to trigger exploration.
Lecode.S_TBS.opacityInput = String(parameters["Opacity Input"] || "control");	//	(): Input to change windows' opacity.
Lecode.S_TBS.minInputOpacity = Number(parameters["Min Input Opacity"] || 0);	//	(): Minimum opacity of windows.
Lecode.S_TBS.inputOpacityDecreaseSteps = Number(parameters["Opacity Steps"] || 10);	//	(Opacity Steps): Value of opacity to reduce when inputed.
Lecode.S_TBS.battleStartSpriteDelay = Number(parameters["Battle Start Sprite Delay"] || 50);	//	(): Duration of the battle start sprite.
Lecode.S_TBS.destinationDuration = Number(parameters["Destination Duration"] || 60);	//	(): Duration of the destination sprite (when a cell is selected).
Lecode.S_TBS.moveEntityEvents = String(parameters["Move Entity Events"] || 'false') === 'true';
// Divider: -- Turn Order --
Lecode.S_TBS.turnOrderFairDistribution = String(parameters["Turn Order Fair Distribution ?"] || 'true') === 'true';	//	(Turn Order Fair Distribution ?): Allow a fair Distribution of the turn order ?
Lecode.S_TBS.turnOrderSortMethod = String(parameters["Turn Order Sort Method"] || "b._battler.agi - a._battler.agi");	//	(): Method used to determine the turn order
// Divider: -- Scopes --
Lecode.S_TBS.scopeCellWidth = Number(parameters["Scope Cell Width"] || 46);	//	(): Width of cells.
Lecode.S_TBS.scopeCellHeight = Number(parameters["Scope Cell Height"] || 46);	//	(): Height of cells. 
Lecode.S_TBS.obstacleRegionId = Number(parameters["Obstacle Region Id"] || 250);	//	(): Region ID for obstacles.
Lecode.S_TBS.freeObstacleRegionId = Number(parameters["Free Obstacle Region Id"] || 249);	//	(): Region ID for non-blocking los obstacles.
// Divider: -- Move Action --
Lecode.S_TBS.defaultMoveScope = String(parameters["Default Move Scope"] || "circle(_mp_)");	//	(): Default move scope data.
Lecode.S_TBS.defaultMovePoints = Number(parameters["Default Move Points"] || 3);	//	(): Default amount of move points.
Lecode.S_TBS.moveColorCell = String(parameters["Move Scope Color"] || "#0A5C85");	//	(Move Scope Color): Color of the move scope.
Lecode.S_TBS.moveCellOpacity = Number(parameters["Move Scope Opacity"] || 175);	//	(Move Scope Opacity): Opacity of the move scope.
Lecode.S_TBS.moveInvalidCellOpacity = Number(parameters["Invalid Move Scope Opacity"] || 60);	//	(Invalid Move Scope Opacity): Opacity of the move scope when cells are invalid.
Lecode.S_TBS.moveSelectedCellOpacity = Number(parameters["Selected Move Scope Opacity"] || 255);	//	(Selected Move Scope Opacity): Opacity of the move scope when cells are selected.
Lecode.S_TBS.selectedMoveColorCell = String(parameters["Selected Move Scope Color"] || "#81F7F3");	//	(Selected Move Scope Color): Color of the selected move scope.
Lecode.S_TBS.enableDirectionalFacing = String(parameters["Enable Directional Facing"] || 'true') === 'true';	//	(): Battlers will be allowed to change their direction.
// Divider: -- Attack Action --
Lecode.S_TBS.defaultAttackAnimation = Number(parameters["Default Attack Animation"] || 1);	//	(): Default attack animation.
Lecode.S_TBS.defaultAttackSequence = String(parameters["Default Attack Sequence"] || "atk");	//	(): Default attack sequence.
Lecode.S_TBS.defaultAttackScope = String(parameters["Default Attack Scope"] || "circle(1)");	//	(): Default attack scope data.
Lecode.S_TBS.defaultAttackAoE = String(parameters["Default Attack Ao E"] || "circle(0)");	//	(): Default attack aoe data.
Lecode.S_TBS.attackColorCell = String(parameters["Attack Scope Color"] || "#E20F2B");	//	(Attack Scope Color): Color of the attack scope.
Lecode.S_TBS.attackCellOpacity = Number(parameters["Attack Scope Opacity"] || 175);	//	(Attack Scope Opacity): Opacity of the attack scope.
Lecode.S_TBS.attackInvalidCellOpacity = Number(parameters["Invalid Attack Scope Opacity"] || 60);	//	(Invalid Attack Scope Opacity): Opacity of the attack scope when cells are invalid.
Lecode.S_TBS.selectedAttackColorCell = String(parameters["Selected Attack Scope Color"] || "#FB3B54");	//	(Selected Attack Scope Color): Color of the attack scope.
Lecode.S_TBS.attackSelectedCellOpacity = Number(parameters["Selected Attack Scope Opacity"] || 255);	//	(Selected Attack Scope Opacity): Opacity of the attack scope when cells are selected.
// Divider: -- Skill Action --
Lecode.S_TBS.defaultSkillSequence = String(parameters["Default Skill Sequence"] || "skill");	//	(): Default skill sequence.
Lecode.S_TBS.defaultSkillScope = String(parameters["Default Skill Scope"] || "circle(3)");	//	(): Default skill scope data.
Lecode.S_TBS.defaultSkillAoE = String(parameters["Default Skill Ao E"] || "circle(0)");	//	(): Default skill aoe data.
Lecode.S_TBS.skillColorCell = String(parameters["Skill Scope Color"] || "#E20F2B");	//	(Skill Scope Color): Color of the skill scope.
Lecode.S_TBS.skillCellOpacity = Number(parameters["Skill Scope Opacity"] || 175);	//	(Skill Scope Opacity): Opacity of the skill scope.
Lecode.S_TBS.skillInvalidCellOpacity = Number(parameters["Invalid Skill Scope Opacity"] || 60);	//	(Invalid Skill Scope Opacity): Opacity of the skill scope when cells are invalid.
Lecode.S_TBS.selectedSkillColorCell = String(parameters["Selected Skill Scope Color"] || "#FB3B54");	//	(Selected Skill Scope Color): Color of the selected skill scope.
Lecode.S_TBS.skillSelectedCellOpacity = Number(parameters["Selected Skill Scope Opacity"] || 255);	//	(Selected Skill Scope Opacity): Opacity of the skill scope when cells are selected.
// Divider: -- Item Action --
Lecode.S_TBS.defaultItemSequence = String(parameters["Default Item Sequence"] || "item");	//	(): Default item sequence.
Lecode.S_TBS.defaultItemScope = String(parameters["Default Item Scope"] || "circle(3)");	//	(): Default item scope data.
Lecode.S_TBS.defaultItemAoE = String(parameters["Default Item Ao E"] || "circle(0)");	//	(): Default item aoe data.
Lecode.S_TBS.ItemColorCell = String(parameters["Item Scope Color"] || "#DF01D7");	//	(Item Scope Color): Color of the item scope.
Lecode.S_TBS.ItemCellOpacity = Number(parameters["Item Scope Opacity"] || 175);	//	(Item Scope Opacity): Opacity of the item scope.
Lecode.S_TBS.ItemInvalidCellOpacity = Number(parameters["Invalid Item Scope Opacity"] || 60);	//	(Invalid Item Scope Opacity): Opacity of the item scope when cells are invalid.
Lecode.S_TBS.selectedItemColorCell = String(parameters["Selected Item Scope Color"] || "#F969F4");	//	(Selected Item Scope Color): Color of selected the item scope.
Lecode.S_TBS.ItemSelectedCellOpacity = Number(parameters["Selected Item Scope Opacity"] || 255);	//	(Selected Item Scope Opacity): Opacity of the item scope when cells are selected.
// Divider: -- Directional Damage --
Lecode.S_TBS.backDirectionalDamageEffects = Number(parameters["Back Directional Damage Effects"] || 15);	//	(): Damage % when a battler is hit on the back.
Lecode.S_TBS.sideDirectionalDamageEffects = Number(parameters["Side Directional Damage Effects"] || 0);	//	(): Damage % when a battler is hit on the sides.
Lecode.S_TBS.frontDirectionalDamageEffects = Number(parameters["Face Directional Damage Effects"] || -10);	//	(): Damage % when a battler is hit on the face.
// Divider: -- Collision Damage --
Lecode.S_TBS.defaultCollisionFormula = String(parameters["Default Collision Formula"] || "b.mhp * 0.05 * (distance-covered)");	//	(): Formula to evaluate collision damage.
Lecode.S_TBS.collissionDamageChainRate = Number(parameters["Collission Damage Chain Rate"] || 0.3);	//	(): Collision damage chain rate.
// Divider: -- Motions --
Lecode.S_TBS.battlersMoveSpeed = Number(parameters["Battlers Move Speed"] || 4);	//	(): Default move speed.
Lecode.S_TBS.battlersFrameDelay = Number(parameters["Battlers Frame Delay"] || 10);	//	(): Default delay value between sprites frames.
// Divider: -- AI --
Lecode.S_TBS.defaultAiPattern = String(parameters["Default Ai Pattern"] || "melee_fighter");	//	(): Default AI pattern.
Lecode.S_TBS.aiWaitTime = Number(parameters["Ai Wait Time"] || 5);	//	(): AI wait time.
Lecode.S_TBS.showScopes = String(parameters["Show Scopes"] || 'false') === 'true';
Lecode.S_TBS.escapeCooldown = Number(parameters["Escape Cooldown"] || 2);
Lecode.S_TBS.supportCooldown = Number(parameters["Support Cooldown"] || 1);
Lecode.S_TBS.aiProcessDelay = Number(parameters["Ai Process Delay"] || 5);
// Divider: -- Actions Restrictions --
Lecode.S_TBS.oneTimeMove = String(parameters["One Time Move"] || 'false') === 'true';	//	(): Enable the one time move feature. (See doc)
Lecode.S_TBS.oneTimeOffense = String(parameters["One Time Offense"] || 'true') === 'true';	//	(): Enable the one time offense feature. (See doc)
Lecode.S_TBS.autoPass = String(parameters["Auto Pass"] || 'true') === 'true';	//	(): Enable the auto pass feature. (See doc)
// Divider: -- Battle End --
Lecode.S_TBS.escapeSound = String(parameters["Escape Sound"] || "Buzzer2");	//	(): Sound when the party try to escape.
Lecode.S_TBS.endOfBattleWait = Number(parameters["End Of Battle Wait"] || 60);	//	(): Wait amount before the end of the battle.
Lecode.S_TBS.collapseAnimation = Number(parameters["Collapse Animation"] || 136);	//	(): Default collapse animation.

Lecode.S_TBS.allyRegionId = 5;
Lecode.S_TBS.enemyRegionId = 1;


/*-------------------------------------------------------------------------
* PluginManager
-------------------------------------------------------------------------*/
/*Lecode.S_TBS.oldPluginManager_setup = PluginManager.setup;
PluginManager.setup = function () {
    this.loadLeTBSDependency("easystar.js");
    this.loadLeTBSDependency("Tween.js");
    this.loadLeTBSDependency("async.min.js");
    var async = require("async");
    console.log("async:" ,async);
    Lecode.S_TBS.oldPluginManager_setup.call(this);
};

PluginManager.loadLeTBSDependency = function(name) {
    var url = "js/libs" + name;
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    script.async = false;
    script.onerror = this.onError.bind(this);
    script._url = url;
    document.body.appendChild(script);
};*/


/*-------------------------------------------------------------------------
* Spriteset_BattleTBS
-------------------------------------------------------------------------*/
function Spriteset_BattleTBS() {
    this.initialize.apply(this, arguments);
}

Spriteset_BattleTBS.prototype = Object.create(Spriteset_Map.prototype);
Spriteset_BattleTBS.prototype.constructor = Spriteset_BattleTBS;

Spriteset_BattleTBS.prototype.initialize = function () {
    Spriteset_Map.prototype.initialize.call(this);
    this._pictures = [];
    this.createTBSLayer();
    this.createBattleLayers();
};

Spriteset_BattleTBS.prototype.createCharacters = function () {
    this._characterSprites = [];
    $gameMap.events().forEach(function (event) {
        if (event.event().note.match(/<TBS Event>/i) || event.event().note.match(/<TBS Neutral (.+)>/i))
            this._characterSprites.push(new Sprite_Character(event));
    }, this);

    for (var i = 0; i < this._characterSprites.length; i++) {
        this._tilemap.addChild(this._characterSprites[i]);
    }
};

Spriteset_BattleTBS.prototype.getEventSprite = function (event) {
    for (var i = 0; i < this._characterSprites.length; i++) {
        var sprite = this._characterSprites[i];
        if (sprite._character === event.event()) return sprite;
    }
    return null;
};

Spriteset_BattleTBS.prototype.createTBSLayer = function () {
    this._tbsLayer = new Sprite();
    this._tbsLayer.x = this._tilemap.x;
    this._tbsLayer.y = this._tilemap.y;
    this._tbsLayer.width = this._tilemap.width;
    this._tbsLayer.height = this._tilemap.height;
    this._baseSprite.addChild(this._tbsLayer);
};

Spriteset_BattleTBS.prototype.createBattleLayers = function () {
    //-Scopes
    this._scopesLayer = new TBSScopeLayer();
    this._scopesLayer.z = 1;
    this._tilemap.addChild(this._scopesLayer);
    this._scopesLayer.createSelectionLayer();
    this._tbsLayer.addChild(this._scopesLayer._selectionLayer);
    //-Ground entities
    this._groundEntitiesLayer = new Sprite();
    this._groundEntitiesLayer.z = 1;
    this._tilemap.addChild(this._groundEntitiesLayer);
    //-Ground
    this._groundLayer = new Sprite();
    this._groundLayer.z = 2;
    this._tbsLayer.addChild(this._groundLayer);
    //-Battlers
    this._battlersLayer = new Sprite();
    this._battlersLayer.z = 4;
    this._tilemap.addChild(this._battlersLayer);
    //-Animations
    this._animationsLayer = new TBSMapAnimation();
    this._animationsLayer.z = 4;
    this._tbsLayer.addChild(this._animationsLayer);
    //-Movable Info
    this._movableInfoLayer = new Sprite();
    this._movableInfoLayer.z = 6;
    this.addChild(this._movableInfoLayer);
    //-Movable Windows
    this._movableWindowsLayer = new Sprite();
    this._movableWindowsLayer.z = 6;
    this.addChild(this._movableWindowsLayer);
    //-Fixed Info
    this._fixedInfoLayer = new Sprite();
    this._fixedInfoLayer.z = 6;
    this.addChild(this._fixedInfoLayer);
    //-Debug
    var bitmap = new Bitmap(Graphics.width, Graphics.height);
    this._debugLayer = new Sprite(bitmap);
    this._debugLayer.z = 7;
    this._tbsLayer.addChild(this._debugLayer);
};

Spriteset_BattleTBS.prototype.setMapFilter = function (filter, includeParallax) {
    this._tilemap.filters = [filter];
    if (includeParallax)
        this._parallax.filters = [filter];
    [this._scopesLayer, this._groundEntitiesLayer, this._battlersLayer].forEach(function (l) {
        l.filters = [];
    }, this);
};

Spriteset_BattleTBS.prototype.setEntitiesFilter = function (filter) {
    [this._groundEntitiesLayer, this._battlersLayer].forEach(function (l) {
        l.filters = [filter];
    }, this);
};

Spriteset_BattleTBS.prototype.setMapRenderable = function (bool, includeParallax) {
    this._tilemap.lowerZLayer.renderable = bool;
    this._tilemap.upperZLayer.renderable = bool;
    if (includeParallax)
        this._parallax.renderable = bool;
};

Spriteset_BattleTBS.prototype.setMapAlpha = function (alpha, includeParallax) {
    this._tilemap.lowerZLayer.alpha = alpha;
    this._tilemap.upperZLayer.alpha = alpha;
    if (includeParallax)
        this._parallax.alpha = alpha;
};

Spriteset_BattleTBS.prototype.setMapTone = function (tone, includeParallax) {
    var filter = new ToneFilter();
    filter.adjustTone(tone[0], tone[1], tone[2]);
    filter.adjustSaturation(-tone[3]);
    this.setMapFilter(filter, includeParallax);
};

Spriteset_BattleTBS.prototype.setEntitiesTone = function (tone) {
    var filter = new ToneFilter();
    filter.adjustTone(tone[0], tone[1], tone[2]);
    filter.adjustSaturation(-tone[3]);
    this.setEntitiesFilter(filter);
};

Spriteset_BattleTBS.prototype.showPicture = function (picId, filename, xStr, yStr) {
    var bitmap = ImageManager.loadPicture(filename, 0);
    bitmap.addLoadListener(this.onPictureBitmapLoaded.bind(this, bitmap, picId, xStr, yStr));
};

Spriteset_BattleTBS.prototype.onPictureBitmapLoaded = function (bitmap, picId, xStr, yStr) {
    var pic = new Sprite(bitmap);
    pic.x = this.getPicDestinationX(pic, xStr);
    pic.y = this.getPicDestinationY(pic, yStr);
    this._pictures[picId] = pic;
    this._fixedInfoLayer.addChild(pic);
};

Spriteset_BattleTBS.prototype.freePicture = function (picId) {
    var pic = this._pictures[picId];
    this._fixedInfoLayer.removeChild(pic);
    this._pictures[picId] = null;
};

Spriteset_BattleTBS.prototype.getPicDestinationX = function (pic, xStr) {
    switch (xStr) {
        case "offscreen-left": return -pic.width;
        case "middle": return Graphics.width / 2 - pic.width / 2;
    }
    return Number(xStr);
};

Spriteset_BattleTBS.prototype.getPicDestinationY = function (pic, yStr) {
    switch (yStr) {
        case "offscreen-top": return -pic.height;
        case "middle": return Graphics.height / 2 - pic.height / 2;
    }
    return Number(yStr);
};

Spriteset_BattleTBS.prototype.movePicture = function (picId, xStr, yStr, time) {
    var picture = this.getPicture(picId);
    var x = Math.round(this.getPicDestinationX(picture, xStr));
    var y = Math.round(this.getPicDestinationY(picture, yStr));
    LeUtilities.tweenProperty(picture, "x", x, time).start();
    LeUtilities.tweenProperty(picture, "y", y, time).start();
    return { x: x, y: y };
};

Spriteset_BattleTBS.prototype.update = function () {
    Spriteset_Map.prototype.update.call(this);
    this.updateEntitiesZ();
};

Spriteset_BattleTBS.prototype.updateTilemap = function () {
    Spriteset_Map.prototype.updateTilemap.call(this);
    [this._tbsLayer, this._movableInfoLayer, this._movableWindowsLayer, this._battlersLayer,
    this._scopesLayer, this._groundEntitiesLayer].forEach(function (layer) {
        if (layer) {
            layer.x = -$gameMap.displayX() * $gameMap.tileWidth();
            layer.y = -$gameMap.displayY() * $gameMap.tileHeight();
        }
    });
};

Spriteset_BattleTBS.prototype.updateEntitiesZ = function () {
    if (this._battlersLayer)
        this._battlersLayer.children.sort(this.compareEntitiesOrder);
};

Spriteset_BattleTBS.prototype.compareEntitiesOrder = function (a, b) {
    if (a._entity.getCell().y < b._entity.getCell().y) return -1;
    if (a._entity.getCell().y > b._entity.getCell().y) return 1;
    return 0;
};

Spriteset_BattleTBS.prototype.getPicture = function (picId) {
    return this._pictures[picId];
};


/*-------------------------------------------------------------------------
* TBSScopeLayer
-------------------------------------------------------------------------*/
function TBSScopeLayer() {
    this.initialize.apply(this, arguments);
}
TBSScopeLayer.prototype = Object.create(Sprite.prototype);
TBSScopeLayer.prototype.constructor = TBSScopeLayer;

TBSScopeLayer.prototype.initialize = function () {
    var w = $gameMap.width() * $gameMap.tileWidth();
    var h = $gameMap.height() * $gameMap.tileHeight();
    var bitmap = new Bitmap(w, h);
    Sprite.prototype.initialize.call(this, bitmap);
    this._selectionLayer = null;
    this._selectionCells = [];
};

TBSScopeLayer.prototype.createSelectionLayer = function () {
    this._selectionLayer = new TBSScopeLayer();
    this._selectionLayer.z = 2;
    //this.parent.addChild(this._selectionLayer);
};

TBSScopeLayer.prototype.update = function () {
    Sprite.prototype.update.call(this);
    if (this._selectionLayer) {
        //this._selectionLayer.x = this.x;
        //this._selectionLayer.y = this.y;
    }
};

TBSScopeLayer.prototype.clear = function () {
    this.bitmap.clear();
};

TBSScopeLayer.prototype.clearSelection = function () {
    this._selectionLayer.clear();
    this._selectionLayer.leU_endLoopFlash();
};

TBSScopeLayer.prototype.drawCell = function (x, y, opacity, color) {
    var w = Lecode.S_TBS.scopeCellWidth;
    var h = Lecode.S_TBS.scopeCellHeight;
    var sx = $gameMap.tileWidth() - w;
    var sy = $gameMap.tileHeight() - h;
    x = x * $gameMap.tileWidth();
    y = y * $gameMap.tileHeight();
    this.bitmap.paintOpacity = opacity;
    this.bitmap.fillRect(x + sx, y + sy, w - sx, h - sy, color);
};

TBSScopeLayer.prototype.drawSquare = function (x, y, w0, h0, opacity, color) {
    var w = Lecode.S_TBS.scopeCellWidth;
    var h = Lecode.S_TBS.scopeCellHeight;
    var sx = $gameMap.tileWidth() - w;
    var sy = $gameMap.tileHeight() - h;
    x = x * $gameMap.tileWidth();
    y = y * $gameMap.tileHeight();
    w *= w0; h *= h0;
    this.bitmap.paintOpacity = opacity;
    this.bitmap.fillRect(x + sx, y + sy, w - sx, h - sy, color);
};

TBSScopeLayer.prototype.eraseCell = function (x, y) {
    var w = Lecode.S_TBS.scopeCellWidth;
    var h = Lecode.S_TBS.scopeCellHeight;
    x = x * $gameMap.tileWidth();
    y = y * $gameMap.tileHeight();
    this.bitmap.clearRect(x, y, w, h);
};

TBSScopeLayer.prototype.drawSelectionCells = function (scope, opacity, color, scolor) {
    var boundaries = BattleManagerTBS.getScopeBoundaries(scope);
    var w = (Math.abs(boundaries.right - boundaries.left) + 1) * $gameMap.tileWidth();
    var h = (Math.abs(boundaries.top - boundaries.bottom) + 1) * $gameMap.tileHeight();
    var x = boundaries.left * $gameMap.tileWidth();
    var y = boundaries.top * $gameMap.tileHeight();
    this._selectionLayer.bitmap = new Bitmap(w, h);
    this._selectionLayer.paintOpacity = opacity;
    this._selectionLayer.x = x;
    this._selectionLayer.y = y;

    w = Lecode.S_TBS.scopeCellWidth;
    h = Lecode.S_TBS.scopeCellHeight;
    var sx = $gameMap.tileWidth() - w;
    var sy = $gameMap.tileHeight() - h;
    scope.forEach(function (cell) {
        var cx = cell.x - boundaries.left;
        var cy = cell.y - boundaries.top;
        cx = cx * $gameMap.tileWidth();
        cy = cy * $gameMap.tileHeight();
        this._selectionLayer.bitmap.fillRect(cx + sx, cy + sy, w - sx, h - sy, scolor);
    }.bind(this));
    this._selectionLayer.leU_startLoopFlash([0, 0, 0, 255], 25);
    this._selectionLayer.leU_setFlashMode("opacity");
};

TBSScopeLayer.prototype.drawSelectionCell = function (x, y, opacity, color) {
    this._selectionLayer.drawCell(x, y, opacity, color);
};

TBSScopeLayer.prototype.debugGrid = function (grid) {
    for (var y = 0; y < $gameMap.height(); y++) {
        for (var x = 0; x < $gameMap.width(); x++) {
            var tile = grid[y][x];
            if (tile === 1) {
                this.drawCell(x, y, 255, "#000000");
            }
        }
    }
};


/*-------------------------------------------------------------------------
* TBSMapAnimation
-------------------------------------------------------------------------*/
function TBSMapAnimation() {
    this.initialize.apply(this, arguments);
}

TBSMapAnimation.prototype = Object.create(Sprite_Base.prototype);
TBSMapAnimation.prototype.constructor = TBSMapAnimation;

TBSMapAnimation.prototype.initialize = function (battler) {
    Sprite_Base.prototype.initialize.call(this);
    this._cell = null;
    this._target = null;
};

TBSMapAnimation.prototype.update = function () {
    Sprite_Base.prototype.update.call(this);
};

TBSMapAnimation.prototype.newAnimation = function (id, mirror, delay, cell, target) {
    this._cell = cell;
    this._target = target;
    this.startAnimation($dataAnimations[id], mirror, delay);
};

TBSMapAnimation.prototype.startAnimation = function (animation, mirror, delay) {
    var sprite = new Sprite_TBSAnimation();
    sprite.setup(this._target || this._effectTarget, animation, mirror, delay, this._cell);
    this.addChild(sprite);
    this._animationSprites.push(sprite);
};

TBSMapAnimation.prototype.isAnimationPlaying = function () {
    return this._animationSprites.filter(function (sprite) {
        return !sprite._isLoopAnim;
    }).length > 0;
};


/*-------------------------------------------------------------------------
* Sprite_TBSAnimation
-------------------------------------------------------------------------*/
function Sprite_TBSAnimation() {
    this.initialize.apply(this, arguments);
}

Sprite_TBSAnimation.prototype = Object.create(Sprite_Animation.prototype);
Sprite_TBSAnimation.prototype.constructor = Sprite_TBSAnimation;

Sprite_TBSAnimation.prototype.initialize = function () {
    Sprite_Animation.prototype.initialize.call(this);
    this._cell = null;
};

Sprite_TBSAnimation.prototype.update = function () {
    Sprite_Animation.prototype.update.call(this);
};

Sprite_TBSAnimation.prototype.setup = function (target, animation, mirror, delay, cell) {
    this._cell = cell;
    this._target = target;
    this._animation = animation;
    this._mirror = mirror;
    this._delay = delay;
    if (this._animation) {
        this.remove();
        this.setupRate();
        this.setupDuration();
        this.loadBitmaps();
        this.createSprites();
    }
};

Sprite_TBSAnimation.prototype.updatePosition = function () {
    if (this._animation.position === 3) {
        this.x = this.parent.width / 2;
        this.y = this.parent.height / 2;
    } else {
        var w = $gameMap.tileWidth();
        var h = $gameMap.tileHeight();
        this.x = this._cell.x * $gameMap.tileWidth() + w / 2;
        this.y = this._cell.y * $gameMap.tileHeight() + h / 2;
        if (this._animation.position === 2)
            this.y += h / 2;
        else if (this._animation.position === 0)
            this.y -= h / 2;
    }
};


/*-------------------------------------------------------------------------
* Sprite_TBSEntityAnimation
-------------------------------------------------------------------------*/
function Sprite_TBSEntityAnimation() {
    this.initialize.apply(this, arguments);
}

Sprite_TBSEntityAnimation.prototype = Object.create(Sprite_TBSAnimation.prototype);
Sprite_TBSEntityAnimation.prototype.constructor = Sprite_TBSEntityAnimation;

Sprite_TBSEntityAnimation.prototype.initialize = function () {
    Sprite_TBSAnimation.prototype.initialize.call(this);
};

Sprite_TBSEntityAnimation.prototype.setup = function (target, animation, mirror, delay, cell) {
    Sprite_TBSAnimation.prototype.setup.call(this, target, animation, mirror, delay, cell);
    this.updatePosition();
};

Sprite_TBSEntityAnimation.prototype.updatePosition = function () {
    if (this._animation.position === 3) {
        this.x = Graphics.width / 2;
        this.y = Graphics.height / 2;
    } else {
        var w = this._target.width;
        var h = this._target.height;
        this.x = this._target.x;
        this.y = this._target.y - h / 2;
        if (this._animation.position === 2)
            this.y += h / 2;
        else if (this._animation.position === 0)
            this.y -= h / 2;
    }
};


/*-------------------------------------------------------------------------
* Scene_Battle
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldSB_create = Scene_Battle.prototype.create;
Scene_Battle.prototype.create = function () {
    if (Lecode.S_TBS.commandOn) {
        Scene_Base.prototype.create.call(this);
        this.createDisplayObjects();
    } else {
        Lecode.S_TBS.oldSB_create.call(this);
    }
};

Lecode.S_TBS.oldSB_createDisplayObjects = Scene_Battle.prototype.createDisplayObjects;
Scene_Battle.prototype.createDisplayObjects = function () {
    if (Lecode.S_TBS.commandOn) {
        this.createSpriteset();
        this.createWindowLayer();
        this.createAllWindows();
    } else {
        Lecode.S_TBS.oldSB_createDisplayObjects.call(this);
    }
};

Lecode.S_TBS.oldSB_start = Scene_Battle.prototype.start;
Scene_Battle.prototype.start = function () {
    if (Lecode.S_TBS.commandOn) {
        Scene_Base.prototype.start.call(this);
        this.startFadeIn(this.fadeSpeed(), false);

        BattleManager.playBattleBgm();
        BattleManagerTBS._spriteset = this._spriteset;
        BattleManagerTBS._logWindow = this._logWindow;
        this._logWindow.setSpriteset(this._spriteset);
        InputHandlerTBS.setup();
        this.setMovableWindows();

        InputHandlerTBS.addWindowBlockingTouch(this._windowConfirm)
            .addWindowBlockingTouch(this._windowCommand)
            .addWindowBlockingTouch(this._windowSkill)
            .addWindowBlockingTouch(this._windowItem)
            .addWindowBlockingTouch(this._windowStatus)
            .addWindowBlockingTouch(this._helpWindow)
            .addWindowBlockingTouch(this._windowEndCommand)
            .addWindowBlockingTouch(this._windowPositioning)
            .addWindowBlockingTouch(this._windowPositioningConfirm);

        BattleManagerTBS.startBattle();
    } else {
        Lecode.S_TBS.oldSB_start.call(this);
    }
};

Lecode.S_TBS.oldSB_update = Scene_Battle.prototype.update;
Scene_Battle.prototype.update = function () {
    if (Lecode.S_TBS.commandOn) {
        $gameMap.update(true);
        //$gameTroop.updateInterpreter();
        $gameTimer.update(true);
        $gameScreen.update();
        InputHandlerTBS.update();
        BattleManagerTBS.update();
        Scene_Base.prototype.update.call(this);
    } else {
        Lecode.S_TBS.oldSB_update.call(this);
    }
};

Lecode.S_TBS.oldSB_createSpriteset = Scene_Battle.prototype.createSpriteset;
Scene_Battle.prototype.createSpriteset = function () {
    if (Lecode.S_TBS.commandOn) {
        this._spriteset = new Spriteset_BattleTBS();
        this.addChild(this._spriteset);
    } else {
        Lecode.S_TBS.oldSB_createSpriteset.call(this);
    }
};

Lecode.S_TBS.oldSB_createAllWindows = Scene_Battle.prototype.createAllWindows;
Scene_Battle.prototype.createAllWindows = function () {
    if (Lecode.S_TBS.commandOn) {
        this.createLogWindow();
        this.createPositioningWindow();
        this.createPositioningConfirmWindow();
        this.createConfirmationWindow();
        this.createStatusWindow();
        this.createCommandWindow();
        this.createHelpWindow();
        this.createSkillWindow();
        this.createItemWindow();
        this.createEndCommandWindow();
        this.createMessageWindow();
    } else {
        Lecode.S_TBS.oldSB_createAllWindows.call(this);
    }
};

Scene_Battle.prototype.setMovableWindows = function () {
    BattleManagerTBS.getLayer("movableWindows").addChild(this._windowCommand);
    BattleManagerTBS.getLayer("movableWindows").addChild(this._windowSkill);
    BattleManagerTBS.getLayer("movableWindows").addChild(this._windowItem);
};

Scene_Battle.prototype.createPositioningWindow = function () {
    this._windowPositioning = new Window_TBSPositioning();
    this._windowPositioning.setHandler('ok', this.onPositioningOk.bind(this));
    this._windowPositioning.setHandler('cancel', this.onPositioningCancel.bind(this));
    this._windowPositioning.setHandler('exit_up', this.onPositioningExitUp.bind(this));
    this._windowPositioning.close();
    this._windowPositioning.deactivate();
    this._windowPositioning.x = 0;
    this._windowPositioning.y = Graphics.height / 2 - this._windowPositioning.height / 2;
    this.addWindow(this._windowPositioning);
};

Scene_Battle.prototype.createPositioningConfirmWindow = function () {
    this._windowPositioningConfirm = new Window_TBSPositioningConfirm(this._windowPositioning.width);
    this._windowPositioningConfirm.setHandler('ok', this.onPositioningConfirmOk.bind(this));
    this._windowPositioningConfirm.setHandler('cancel', this.onPositioningConfirmCancel.bind(this));
    this._windowPositioningConfirm.setHandler('cursor_down', this.onPositioningConfirmCursorDown.bind(this));
    this._windowPositioningConfirm.close();
    this._windowPositioningConfirm.deactivate();
    this._windowPositioningConfirm.x = this._windowPositioning.x;
    this._windowPositioningConfirm.y = this._windowPositioning.y - this._windowPositioningConfirm.height;
    this.addWindow(this._windowPositioningConfirm);
};

Scene_Battle.prototype.createConfirmationWindow = function () {
    this._windowConfirm = new Window_TBSConfirm();
    this._windowConfirm.setHandler('ok', this.onConfirmationOK.bind(this));
    this._windowConfirm.setHandler('cancel', this.onConfirmationCancel.bind(this));
    this._windowConfirm.hide();
    this._windowConfirm.deactivate();
    this.addWindow(this._windowConfirm);
};

Lecode.S_TBS.oldSB_createStatusWindow = Scene_Battle.prototype.createStatusWindow;
Scene_Battle.prototype.createStatusWindow = function () {
    if (Lecode.S_TBS.commandOn) {
        this._windowStatus = new Window_TBSStatus();
        this._windowStatus.hide();
        this.addWindow(this._windowStatus);
    } else {
        Lecode.S_TBS.oldSB_createStatusWindow.call(this);
    }
};

Lecode.S_TBS.oldSB_createCommandWindow = Scene_Battle.prototype.createCommandWindow;
Scene_Battle.prototype.createCommandWindow = function () {
    if (Lecode.S_TBS.commandOn) {
        this._windowCommand = new Window_TBSCommand();
        this._windowCommand.setHandler('cancel', this.onCommandInput.bind(this, "cancel"));
        this._windowCommand.hide();
        this._windowCommand.deactivate();
    } else {
        Lecode.S_TBS.oldSB_createCommandWindow.call(this);
    }
};

Lecode.S_TBS.oldSB_createSkillWindow = Scene_Battle.prototype.createSkillWindow;
Scene_Battle.prototype.createSkillWindow = function () {
    if (Lecode.S_TBS.commandOn) {
        this._windowSkill = new Window_TBSSkillList();
        this._windowSkill.setHandler('ok', this.onSkillInput.bind(this, "ok"));
        this._windowSkill.setHandler('cancel', this.onSkillInput.bind(this, "cancel"));
        this._windowSkill._helpWindow = this._helpWindow;
        this._windowSkill.hide();
        this._windowSkill.close();
        this._windowSkill.deactivate();
    } else {
        Lecode.S_TBS.oldSB_createSkillWindow.call(this);
    }
};

Lecode.S_TBS.oldSB_createItemWindow = Scene_Battle.prototype.createItemWindow;
Scene_Battle.prototype.createItemWindow = function () {
    if (Lecode.S_TBS.commandOn) {
        this._windowItem = new Window_TBSItemList();
        this._windowItem.setHandler('ok', this.onItemInput.bind(this, "ok"));
        this._windowItem.setHandler('cancel', this.onItemInput.bind(this, "cancel"));
        this._windowItem._helpWindow = this._helpWindow;
        this._windowItem.hide();
        this._windowItem.close();
        this._windowItem.deactivate();
    } else {
        Lecode.S_TBS.oldSB_createItemWindow.call(this);
    }
};

Scene_Battle.prototype.createEndCommandWindow = function () {
    this._windowEndCommand = new Window_TBSEndCommand();
    this._windowEndCommand.setHandler('options', this.onEndCommandInput.bind(this, "options"));
    this._windowEndCommand.setHandler('escape', this.onEndCommandInput.bind(this, "escape"));
    this._windowEndCommand.setHandler('cancel', this.onEndCommandInput.bind(this, "cancel"));
    this._windowEndCommand.hide();
    this._windowEndCommand.deactivate();
    this.addWindow(this._windowEndCommand);
};

Scene_Battle.prototype.activatePositioningWindow = function () {
    this._windowPositioning.open();
    this._windowPositioningConfirm.open();
    this._windowPositioning.selectLast();
    this._windowPositioning.activate();
    for (var i = 0; i < $gameParty.allMembers().length; i++) {
        this._windowPositioning.select(i);
        if (!this._windowPositioning._disabled[i])
            break;
    }
};

Scene_Battle.prototype.onPositioningOk = function () {
    var actor = this._windowPositioning.actor();
    this._windowPositioning.disableSelection();
    this._windowPositioning.refresh();
    this._windowPositioning.close();
    this._windowPositioningConfirm.close();
    BattleManagerTBS.processActorPositioning(actor);
};

Scene_Base.prototype.onPositioningCancel = function () {
    var actor = this._windowPositioning.actor();
    var currentEntity = BattleManagerTBS.getEntityByActorId(actor.actorId());
    if (currentEntity) {
        BattleManagerTBS.processActorPositioning(actor);
        BattleManagerTBS.positioningPhaseCancel();
    }
    this._windowPositioning.activate();
};

Scene_Battle.prototype.onActorPrePositioning = function (actor) {
    this._windowPositioning.setFixedActor(actor);
    this._windowPositioning.refresh();
};

Scene_Battle.prototype.onPositioningExitUp = function () {
    this._windowPositioning.deactivate();
    this._windowPositioning.deselect();
    this._windowPositioningConfirm.activate();
};

Scene_Battle.prototype.onPositioningConfirmOk = function () {
    BattleManagerTBS.positioningPhaseEnd();
};

Scene_Battle.prototype.onPositioningConfirmCancel = function () {
    this.onPositioningConfirmCursorDown();
};

Scene_Battle.prototype.onPositioningConfirmCursorDown = function () {
    this._windowPositioning.activate();
    this._windowPositioning.selectLast();
    this._windowPositioningConfirm.deactivate();
    this._windowPositioningConfirm.deselect();
};

Scene_Battle.prototype.onTBSBattleBeginning = function () {
    this.hideConfirmationWindow();
    this._windowPositioning.deactivate();
    this._windowPositioning.close();
    this._windowPositioningConfirm.deactivate();
    this._windowPositioningConfirm.close();
};

Scene_Battle.prototype.showPositioningWindow = function (cell, battler) {
    this._windowPositioning.open();
    this._windowPositioning.show();
    this._windowPositioningConfirm.open();
    this._windowPositioningConfirm.show();
    this._windowPositioning.refresh();
    this._windowPositioningConfirm.refresh();
    this._windowPositioning.activate();
};

Scene_Battle.prototype.showStatusWindow = function (entity, slide) {
    if (entity.battler().rpgObject().TagsLetbs.hideStatusWindow) return;
    if (entity.battler().isDead() && entity.hasNoCorpse()) return;
    var window = this._windowStatus;
    this._windowStatus._entity = entity;
    this._windowStatus.show();
    this._windowStatus.open();
    this._windowStatus.refresh();
    if (slide)
        this._windowStatus.slide();
};

Scene_Battle.prototype.showCommandWindow = function () {
    if (this._windowCommand._opening) return;
    if (this._windowCommand.isOpen()) return;
    if (this._windowSkill._opening) return;
    if (this._windowSkill.isOpen()) return;
    if (this._windowItem._opening) return;
    if (this._windowItem.isOpen()) return;
    var entity = BattleManagerTBS.activeEntity();
    var battler = BattleManagerTBS.activeBattler();
    this._windowCommand.setup(battler, entity);
};

Scene_Battle.prototype.showSkillWindow = function () {
    var entity = BattleManagerTBS.activeEntity();
    var cell = entity.getCell();
    var battler = BattleManagerTBS.activeBattler();
    this._windowSkill._entity = entity;
    this._windowSkill._stypeId = this._windowCommand.currentExt();
    this._windowSkill.setActor(battler);
    this._windowSkill.show();
    this._windowSkill.open();
    this._windowSkill.refresh();
    this._windowSkill.activate();
    this.showHelpWindow();
};

Scene_Battle.prototype.showItemWindow = function () {
    var entity = BattleManagerTBS.activeEntity();
    var cell = entity.getCell();
    var battler = BattleManagerTBS.activeBattler();
    this._windowItem._entity = entity;
    this._windowItem.show();
    this._windowItem.open();
    this._windowItem.refresh();
    this._windowItem.activate();
    this.showHelpWindow();
};

Scene_Battle.prototype.showHelpWindow = function () {
    var status = this._windowStatus;
    var help = this._helpWindow;
    help.x = 0;
    help.y = Graphics.height - help.height;
    while ((status.y + status.height) > help.y)
        status.y--;
    status.y++;
    help.visible = true;
};

Scene_Battle.prototype.showEndCommandWindow = function () {
    this._windowEndCommand.show();
    this._windowEndCommand.open();
    this._windowEndCommand.activate();
};

Scene_Battle.prototype.hideHelpWindow = function () {
    var status = this._windowStatus;
    var help = this._helpWindow;
    if ((status.y + status.height) == (help.y + 1))
        status.y += help.height;
    help.y += help.height;
    help.visible = false;
};

Scene_Battle.prototype.showConfirmationWindow = function () {
    this._windowConfirm.show();
    this._windowConfirm.open();
    this._windowConfirm.activate();
};

Scene_Battle.prototype.hideConfirmationWindow = function () {
    this._windowConfirm.close();
    this._windowConfirm.deactivate();
};

Scene_Battle.prototype.onConfirmationOK = function () {
    if (this._windowConfirm.openness == 255);
    BattleManagerTBS.onConfirmationWindowOK();
};

Scene_Battle.prototype.onConfirmationCancel = function () {
    if (this._windowConfirm.openness == 255);
    BattleManagerTBS.onConfirmationWindowCancel();
};

Scene_Battle.prototype.onCommandInput = function (command) {
    this._windowCommand.close();
    this._windowCommand.deactivate();
    BattleManagerTBS.onCommandInput(command);
};

Scene_Battle.prototype.onSkillInput = function (command) {
    this._windowSkill.close();
    this._windowSkill.deactivate();
    this.hideHelpWindow();
    BattleManagerTBS.onSkillInput(command);
};

Scene_Battle.prototype.onItemInput = function (command) {
    this._windowItem.close();
    this._windowItem.deactivate();
    this.hideHelpWindow();
    BattleManagerTBS.onItemInput(command);
};

Scene_Battle.prototype.onEndCommandInput = function (command) {
    this._windowEndCommand.close();
    this._windowEndCommand.deactivate();
    BattleManagerTBS.onEndCommandInput(command);
};

Scene_Battle.prototype.getDismissibleWindows = function () {
    return [this._windowConfirm, this._windowCommand, this._windowStatus,
    this._windowSkill, this._helpWindow
    ];
};

Scene_Battle.prototype.stop = function () {
    Scene_Base.prototype.stop.call(this);
    if (this.needsSlowFadeOut()) {
        this.startFadeOut(this.slowFadeSpeed(), false);
    } else {
        this.startFadeOut(this.fadeSpeed(), false);
    }
    if (Lecode.S_TBS.commandOn) {
        this.getDismissibleWindows().forEach(function (window) {
            window.close();
        }.bind(this));
    } else {
        this._statusWindow.close();
        this._partyCommandWindow.close();
        this._actorCommandWindow.close();
    }
};


/*-------------------------------------------------------------------------
* InputHandlerTBS
-------------------------------------------------------------------------*/
function InputHandlerTBS() {
    throw new Error('This is a static class');
}

InputHandlerTBS.setup = function () {
    this._active = true;
    this._lastSelectedCell = null;
    this._windowsBlocking = [];
    this._oldMousePos = {};
};

InputHandlerTBS.isActive = function () {
    return this._active;
};

InputHandlerTBS.lastSelectedCell = function () {
    return this._lastSelectedCell || BattleManagerTBS._activeCell;
};

InputHandlerTBS.setActive = function (active) {
    this._active = active;
};

InputHandlerTBS.addWindowBlockingTouch = function (window) {
    this._windowsBlocking.push(window);
    return this;
};

InputHandlerTBS.setOnTouchCallback = function (callback) {
    this._onTouchCallback = callback;
    return this;
};

InputHandlerTBS.setOnTouchCancelCallback = function (callback) {
    this._onTouchCancelCallback = callback;
    return this;
};

InputHandlerTBS.setOnUpCallback = function (callback) {
    this._onUpCallback = callback;
    return this;
};

InputHandlerTBS.setOnRightCallback = function (callback) {
    this._onRightCallback = callback;
    return this;
};

InputHandlerTBS.setOnDownCallback = function (callback) {
    this._onDownCallback = callback;
    return this;
};

InputHandlerTBS.setOnLeftCallback = function (callback) {
    this._onLeftCallback = callback;
    return this;
};

InputHandlerTBS.setOnOkCallback = function (callback) {
    this._onOkCallback = callback;
    return this;
};

InputHandlerTBS.setOnCancelCallback = function (callback) {
    this._onCancelCallback = callback;
    return this;
};

InputHandlerTBS.setOnMoveCallback = function (callback) {
    this._onMoveCallback = callback;
    return this;
};

InputHandlerTBS.update = function () {
    if (!this.isActive()) return;
    if (BattleManagerTBS.isWaiting()) return;

    if (Input.isPressed(Lecode.S_TBS.explorationInput) && !BattleManagerTBS.isExploring()) {
        BattleManagerTBS.startMapExploration();
        return;
    }
    if (!Input.isPressed(Lecode.S_TBS.explorationInput) && BattleManagerTBS.isExploring()) {
        BattleManagerTBS.endMapExploration();
        return;
    }
    if (BattleManagerTBS.isExploring()) {
        this.updateExplorationInput();
        return;
    }

    if (Input.isPressed(Lecode.S_TBS.opacityInput))
        BattleManagerTBS.setInputOpacity();
    else
        BattleManagerTBS._opacityInputed = false;

    if (TouchInput.isTriggered()) {
        var x = $gameMap.canvasToMapX(TouchInput.x);
        var y = $gameMap.canvasToMapY(TouchInput.y);
        var cell = BattleManagerTBS.getCellAt(x, y);
        this.processCallback("Touch", cell);
        this._lastSelectedCell = cell;
        if (!this.isTouchBlocked()) {
            $gameTemp.setDestination(x, y);
            BattleManagerTBS.resetDestinationCount();
        }
        return;
    }

    if (TouchInput.isCancelled()) {
        this.processCallback("TouchCancel");
        return;
    }

    if (Input.isTriggered("right"))
        this.processCallback("Right");
    if (Input.isTriggered("down"))
        this.processCallback("Down");
    if (Input.isTriggered("left"))
        this.processCallback("Left");
    if (Input.isTriggered("up"))
        this.processCallback("Up");
    if (Input.isTriggered("ok"))
        this.processCallback("Ok");
    if (Input.isTriggered("cancel"))
        this.processCallback("Cancel");

    if (TouchInput._leTBSMoveData.x != this._oldMousePos.x ||
        TouchInput._leTBSMoveData.y != this._oldMousePos.y) {
        this.processCallback("Move");
        this._oldMousePos.x = TouchInput._leTBSMoveData.x;
        this._oldMousePos.y = TouchInput._leTBSMoveData.y;
    }
};

InputHandlerTBS.processCallback = function (key, arg) {
    var func = eval("this._on" + key + "Callback");
    if (func)
        func(arg);
};

InputHandlerTBS.updateExplorationInput = function () {
    if (Input.isPressed("right"))
        BattleManagerTBS.scrollRight(1);
    if (Input.isPressed("down"))
        BattleManagerTBS.scrollDown(1);
    if (Input.isPressed("up"))
        BattleManagerTBS.scrollUp(1);
    if (Input.isPressed("left"))
        BattleManagerTBS.scrollLeft(1);
    var x = $gameMap.canvasToMapX(TouchInput.x);
    var y = $gameMap.canvasToMapY(TouchInput.y);
    var cell = BattleManagerTBS.getCellAt(x, y);
    BattleManagerTBS.centerCell(cell);
};

InputHandlerTBS.isTouchBlocked = function () {
    var x = TouchInput.x;
    var y = TouchInput.y;
    for (var i = 0; i < this._windowsBlocking.length; i++) {
        var w = this._windowsBlocking[i];
        if (!w.visible || w.opacity === 0 || w.openness === 0) continue;
        if (x >= w.x && x <= (w.x + w.width)) {
            if (y >= w.y && y <= (w.y + w.height))
                return true;
        }
    }
    return false;
};


/*-------------------------------------------------------------------------
* BattleManager
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldBM_setup = BattleManager.setup;
BattleManager.setup = function (troopId, canEscape, canLose) {
    Lecode.S_TBS.oldBM_setup.call(this, troopId, canEscape, canLose);
    BattleManagerTBS.setup();
};

Lecode.S_TBS.oldBM_isTurnEnd = BattleManager.isTurnEnd;
BattleManager.isTurnEnd = function () {
    return Lecode.S_TBS.oldBM_isTurnEnd.call(this) || BattleManagerTBS._subPhase == "turn_end";
};

Lecode.S_TBS.oldBM_canEscape = BattleManager.canEscape;
BattleManager.canEscape = function () {
    var entity = BattleManagerTBS.activeEntity();
    if (entity) {
        var bool = entity._movePerformed || entity._actionPerformed;
        return Lecode.S_TBS.oldBM_canEscape.call(this) && !bool;
    } else {
        return Lecode.S_TBS.oldBM_canEscape.call(this);
    }
};

Lecode.S_TBS.oldBattleManager_displayStartMessages = BattleManager.displayStartMessages;
BattleManager.displayStartMessages = function () {
    if (Lecode.S_TBS.displayStartMessages)
        Lecode.S_TBS.oldBattleManager_displayStartMessages.call(this);
};


/*-------------------------------------------------------------------------
* BattleManagerTBS
-------------------------------------------------------------------------*/
function BattleManagerTBS() {
    throw new Error('This is a static class');
}

BattleManagerTBS.setup = function () {
    this.initMembers();
};

BattleManagerTBS.initMembers = function () {
    this._phase = "init";
    this._subPhase = "";
    this._startCells = [];
    this._positioningEntityToSwap = null;
    this._currentPositioningEntity = null;
    this._groundCells = {};
    this._cursor = null;
    this._activeCell = null;
    this._spriteset = null;
    this._hiddenEntities = [];
    this._battlerEntities = [];
    this._neutralEntities = [];
    this._tbsEvents = [];
    this._entityEventsCooldown = {};
    this._eventsCooldown = {};
    this._lastTriggeredEventEntity = null;
    this._lastTriggeredEventBattler = null;
    this._startupFlags = {};
    this._entitiesEvents = {};
    this._explorationIniCell = null;
    this._exploring = false;
    this._inputOpacity = 0;
    this._opacityInputed = false;
    this._waitTime = 0;
    this._turnOrder = [];
    this._activeIndex = 0;
    this._activeAction = null;
    this._moveScope = null;
    this._movePath = null;
    this._actionScope = null;
    this._destinationCount = 0;
};

BattleManagerTBS.cursor = function () {
    return this._cursor;
};

BattleManagerTBS.hiddenEntities = function () {
    return this._hiddenEntities;
};

BattleManagerTBS.allEntities = function () {
    return this._battlerEntities.concat(this._neutralEntities);
};

BattleManagerTBS.allEntitiesWithHidden = function () {
    return this.allEntities().concat(this.hiddenEntities());
};

BattleManagerTBS.allPlayableEntities = function () {
    return this._battlerEntities;
};

BattleManagerTBS.moveScope = function () {
    return this._moveScope;
};

BattleManagerTBS.movePath = function () {
    return this._movePath;
};

BattleManagerTBS.actionScope = function () {
    return this._actionScope;
};

BattleManagerTBS.isExploring = function () {
    return this._exploring;
};

BattleManagerTBS.activeAction = function () {
    return this._activeAction;
};

BattleManagerTBS.getLayer = function (id) {
    var layer = eval("this._spriteset._" + id + "Layer");
    return layer;
};

BattleManagerTBS.wait = function (time) {
    this._waitTime += time;
};

BattleManagerTBS.isWaiting = function () {
    return this._waitTime > 0;
};

BattleManagerTBS.startBattle = function () {
    this.prepare();
    this.processPositioningPhase();
};

BattleManagerTBS.prepare = function () {
    this.createStartCells();
    this.createGroundCells();
    this.createTBSObjects();
    this.createTBSEvents();
    this.createNeutralEntities();
    this.prepareEventsCooldown();
    this.prepareEntityFlags();
};

BattleManagerTBS.createTBSObjects = function () {
    this.createDirectionSelector();
    this.createCursor();
    this.createBattleStartSprite();
    this.createTurnOrderVisual();
    this.createProjectilesManager();
    this.createAiManager();
    this._easystar = new EasyStar.js();
};

BattleManagerTBS.createDirectionSelector = function () {
    var layer = this.getLayer("movableInfo");
    this._directionSelector = new TBSDirectionSelector(layer);
};

BattleManagerTBS.createCursor = function () {
    var bitmap = ImageManager.loadLeTBS("MapCursor");
    this._cursor = new SpriteCursorTBS(bitmap);
    this.getLayer("ground").addChild(this.cursor());
};

BattleManagerTBS.createBattleStartSprite = function () {
    var bitmap = ImageManager.loadLeTBS("Battle_Start");
    this._startSprite = new Sprite(bitmap);
    this._startSprite.visible = false;
    this.getLayer("fixedInfo").addChild(this._startSprite);
};

BattleManagerTBS.createProjectilesManager = function () {
    var layer = this.getLayer("animations");
    this._projectilesManager = new TBSProjectilesManager(layer);
};

BattleManagerTBS.createAiManager = function () {
    this._aiManager = new TBSAiManager();
};
BattleManagerTBS.createTurnOrderVisual = function () {
    var layer = this.getLayer("fixedInfo");
    this._turnOrderVisual = new TBSTurnOrderVisual(layer);
};

BattleManagerTBS.createStartCells = function () {
    this.getLayer("scopes").clear();
    this._startCells = [];
    this.createStartCellsByEvents();
    this.createStartCellsByRegionId();
};

BattleManagerTBS.createStartCellsByEvents = function () {
    $gameMap.events().forEach(function (eventObj) {
        var x = eventObj.event().x;
        var y = eventObj.event().y;
        var note = eventObj.event().note;
        var data = {};
        if (note.match(/<Enemy Cell>/i)) {
            data.type = "enemy";
        } else if (note.match(/<Enemy Cell\s?:\s?(.+)>/i)) {
            data.type = "enemy";
            data.fixed = Number(RegExp.$1);
        } else if (note.match(/<Actor Cell>/i)) {
            data.type = "actor";
        } else if (note.match(/<Actor Cell\s?:\s?(.+)>/i)) {
            data.type = "actor";
            data.fixed = Number(RegExp.$1);
        }
        if (data.type) {
            var cell = new TBSCell(x, y);
            cell._event = eventObj.event();
            cell._positioningData = data;
            this.createPositioningCell(data.type, x, y, cell);
            this._startCells.push(cell);
            if (!this._entitiesEvents[x])
                this._entitiesEvents[x] = {};
            this._entitiesEvents[x][y] = eventObj;
        }
    }.bind(this));
};

BattleManagerTBS.createStartCellsByRegionId = function () {
    for (var i = 0; i < $gameMap.width(); i++) {
        for (var j = 0; j < $gameMap.height(); j++) {
            var regionId = $gameMap.regionId(i, j);
            var data = {};
            if (regionId === Lecode.S_TBS.allyRegionId) {
                data.type = "actor";
            } else if (regionId === Lecode.S_TBS.enemyRegionId) {
                data.type = "enemy";
            }
            if (data.type) {
                var cell = new TBSCell(i, j);
                cell._positioningData = data;
                this.createPositioningCell(data.type, i, j, cell);
                this._startCells.push(cell);
            }
        }
    }
};

BattleManagerTBS.createGroundCells = function () {
    for (var i = 0; i < $gameMap.width(); i++) {
        this._groundCells[i] = {};
        for (var j = 0; j < $gameMap.height(); j++) {
            var cell = new TBSCell(i, j);
            cell._regionId = $gameMap.regionId(i, j);
            this._groundCells[i][j] = cell;
        }
    }
};

BattleManagerTBS.createTBSEvents = function () {
    $gameMap.events().forEach(function (event) {
        if (event.event().note.match(/<TBS Event>/i)) {
            this._tbsEvents.push(new TBSEvent(event));
        }
    }.bind(this));
};

BattleManagerTBS.getTBSEventAt = function (x, y) {
    for (var i = 0; i < this._tbsEvents.length; i++) {
        var event = this._tbsEvents[i];
        if (event.x() === x && event.y() === y)
            return event;
    }
    return null;
};

BattleManagerTBS.onEventPageSetup = function (event) {
    for (var i = 0; i < this._tbsEvents.length; i++) {
        var tbsEvent = this._tbsEvents[i];
        if (tbsEvent._event === event)
            tbsEvent.onEventPageSetup();
    }
};

BattleManagerTBS.onEventForceMoveRoute = function (event) {
    for (var i = 0; i < this._tbsEvents.length; i++) {
        var tbsEvent = this._tbsEvents[i];
        if (tbsEvent._event === event)
            tbsEvent.onEventForceMoveRoute();
    }
};

BattleManagerTBS.createNeutralEntities = function () {
    var layer = this.getLayer("battlers");
    $gameMap.events().forEach(function (event) {
        if (event.event().note.match(/<TBS Neutral (.+)>/i)) {
            var enemyId = Number(RegExp.$1);
            var tbsEvent = new TBSEvent(event);
            this._tbsEvents.push(tbsEvent);
            var entity = new TBSNeutralEntity(layer, tbsEvent, enemyId);
            entity.setCell(this.getCellAt(event.x, event.y));
            this._neutralEntities.push(entity);
        }
    }.bind(this));
};

BattleManagerTBS.prepareEventsCooldown = function () {
    for (var i = 0; i < $dataCommonEvents.length; i++) {
        var comEv = $dataCommonEvents[i];
        if (comEv) {
            var id = comEv.id;
            this._entityEventsCooldown[id] = 0;
        }
    }
    for (var j = 0; j < this._tbsEvents.length; j++) {
        var ev = this._tbsEvents[j];
        this._eventsCooldown[ev._event.id] = 0;
    }
};

BattleManagerTBS.prepareEntityFlags = function () {
    $gameMap.events().forEach(function (event) {
        if (event && !event._erased) {
            for (var i = 0; i < event.list().length; i++) {
                var command = event.list()[i];
                if (command && command.code == 108) {
                    var comments = command.parameters;
                    for (var j = 0; j < comments.length; j++) {
                        var comment = comments[j];
                        if (comment.match(/<LeTBS>\s?Flag\s?:\s?(.+)/i)) {
                            this._startupFlags[event.x] = {};
                            this._startupFlags[event.x][event.y] = RegExp.$1;
                        }
                    }
                }
            }
        }
    }.bind(this));
};

BattleManagerTBS.update = function () {
    this.updateWait();
    //this.waitMessagesForCommandWindow();
    //this.waitEventsForCommandWindow();
    this.updateWindowsInputOpacity();
    this.updateTBSObjects();
    this.updatePhase();
    this.updateBattlers();
    this.updateTBSEvents();
    this.updateDestination();
};

BattleManagerTBS.updateDestination = function () {
    this._destinationCount++;
    if (this._destinationCount >= Lecode.S_TBS.destinationDuration) {
        this._destinationCount = 0;
        $gameTemp.clearDestination();
    }
};

BattleManagerTBS.resetDestinationCount = function () {
    this._destinationCount = 0;
};

BattleManagerTBS.waitMessagesForCommandWindow = function () {
    if ($gameMessage.isBusy() && !this._windowToResume) {
        this.wait(1);
        var window = LeUtilities.getScene()._windowCommand;
        if (window.active) {
            window.close();
            window.deactivate();
            this._windowToResume = window;
        }
    } else {
        if (this._windowToResume && this._phase !== "battle_end") {
            this._windowToResume.open();
            this._windowToResume.activate();
            this._windowToResume = null;
        }
    }
};

BattleManagerTBS.waitEventsForCommandWindow = function () {
    if ($gameTroop.isEventRunning() && !this._windowToResume) {
        var window = LeUtilities.getScene()._windowCommand;
        if (window.active) {
            window.close();
            window.deactivate();
            this._windowToResume = window;
        }
    } else {
        if (this._windowToResume && this._phase !== "battle_end") {
            this._windowToResume.open();
            this._windowToResume.activate();
            this._windowToResume = null;
        }
    }
};

BattleManagerTBS.updateWait = function () {
    if (this.isWaiting())
        this._waitTime--;
};

BattleManagerTBS.updateWindowsInputOpacity = function () {
    if (this._inputOpacity === 0)
        return;

    var windows = LeUtilities.getScene().getDismissibleWindows();
    windows.forEach(function (window) {
        window.opacity = 255 - this._inputOpacity;
        window.backOpacity = 255 - this._inputOpacity;
        window.contentsOpacity = 255 - this._inputOpacity;
    }.bind(this));

    if (!this._opacityInputed) {
        var steps = Lecode.S_TBS.inputOpacityDecreaseSteps;
        var max = 255 - Lecode.S_TBS.minInputOpacity;
        this._inputOpacity -= steps;
        this._inputOpacity = this._inputOpacity.clamp(0, max);
    }
};

BattleManagerTBS.updateTBSObjects = function () {
    this.updateCursor();
    this._turnOrderVisual.update();
    this._projectilesManager.update();
};

BattleManagerTBS.updateCursor = function () {
    if (!this._activeCell || !this.cursor()) return;
    this.cursor().setCell(this._activeCell);
};

BattleManagerTBS.startMapExploration = function () {
    this._exploring = true;
    this._explorationIniCell = this._activeCell;
};

BattleManagerTBS.endMapExploration = function () {
    this._exploring = false;
    this.centerCell(this._explorationIniCell);
};

BattleManagerTBS.setInputOpacity = function () {
    this._opacityInputed = true;
    var steps = Lecode.S_TBS.inputOpacityDecreaseSteps;
    var max = 255 - Lecode.S_TBS.minInputOpacity;
    this._inputOpacity += steps;
    this._inputOpacity = this._inputOpacity.clamp(0, max);
};

BattleManagerTBS.updatePhase = function () {
    InputHandlerTBS.setActive(!$gameMessage.isBusy());
    if ($gameMessage.isBusy()) return;
    switch (this._phase) {
        case "positioning":
            this.updatePositioningPhase();
            break;
        case "battle_beginning":
            this.updateBeginningPhase();
            break;
        case "battle_processing":
            this.updateBattleProcessing();
            break;
        case "battle_stopping":
            this.updateBattleStopping();
            break;
        case "battle_end":
            this.updateBattleEnd();
            break;
    }
};

BattleManagerTBS.updateBattlers = function () {
    this.allEntities().forEach(function (entity) {
        entity.update();
    }.bind(this));
};

BattleManagerTBS.updateTBSEvents = function () {
    for (var i = 0; i < this._tbsEvents.length; i++) {
        this._tbsEvents[i].update();
    }
};

BattleManagerTBS.createPositioningCell = function (type, x, y, cell) {
    var opacity = Lecode.S_TBS.positioningCellOpacity;
    var color = (type === "actor") ? Lecode.S_TBS.actorColorCell : Lecode.S_TBS.enemyColorCell;
    this.getLayer("scopes").drawCell(x, y, opacity, color);
    cell._type = type;
};

BattleManagerTBS.processPositioningPhase = function () {
    this._phase = "positioning";
    this._subPhase = "";
    this._actorsToPositionate = [];
    this._enemiesToPositionate = [];
    $gameTroop.members().forEach(function (mem) {
        this._enemiesToPositionate.push(mem);
    }.bind(this));
    this.allyStartCells().forEach(function (cell) {
        if (cell._positioningData.type === "actor") {
            var id = cell._positioningData.fixed;
            if (id)
                this._actorsToPositionate.push($gameActors.actor(id));
        }
    }.bind(this));
    this.processActorsPrePositioning();
    this.processEnemyPositioning();

    InputHandlerTBS.setOnTouchCallback(this.positioningPhaseOnTouchInput.bind(this))
        .setOnTouchCancelCallback(this.positioningPhaseOnInputCancel.bind(this))
        .setOnOkCallback(this.positioningPhaseOnInputOk.bind(this))
        .setOnCancelCallback(this.positioningPhaseOnInputCancel.bind(this))
        .setOnRightCallback(this.positioningPhaseOnInputRight.bind(this))
        .setOnLeftCallback(this.positioningPhaseOnInputLeft.bind(this))
        .setOnDownCallback(this.positioningPhaseOnInputDown.bind(this))
        .setOnUpCallback(this.positioningPhaseOnInputUp.bind(this))
        .setOnMoveCallback(this.positioningPhaseOnMouseMove.bind(this));
};

BattleManagerTBS.positioningPhaseOnMouseMove = function () {
    if (this._subPhase === "directionSelector_input") {
        var x = $gameMap.canvasToMapX(TouchInput._leTBSMoveData.x);
        var y = $gameMap.canvasToMapY(TouchInput._leTBSMoveData.y);
        var cell = BattleManagerTBS.getCellAt(x, y);
        if (cell) {
            var entity = this._directionSelector._battlerEntity;
            var oldDir = entity.getDir();
            entity.lookAt(cell);
            if (oldDir != entity.getDir())
                this._directionSelector.setDir(entity.getDir());
        }
    }
};

BattleManagerTBS.positioningPhaseOnTouchInput = function (selectedCell) {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByTouch(selectedCell);
            break;
        case "directionSelector_input":
            this.setDirectionSelectionDirByTouch(selectedCell);
            break;
    }
    this.checkStartWindowInput();
};

BattleManagerTBS.checkStartWindowInput = function () {
    var window = LeUtilities.getScene()._windowPositioningConfirm;
    if (window.visible && window.isMouseInsideFrame()) {
        LeUtilities.getScene().onPositioningExitUp();
    }
    window = LeUtilities.getScene()._windowPositioning;
    if (window.visible && !window.active && window.isMouseInsideFrame()) {
        LeUtilities.getScene().onPositioningConfirmCursorDown();
    }
};

BattleManagerTBS.positioningPhaseOnInputOk = function () {
    switch (this._subPhase) {
        case "input":
            this.positioningPhaseOk();
            break;
        case "directionSelector_input":
            this.directionSelectorValidatePositioning();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputCancel = function () {
    switch (this._subPhase) {
        case "input":
            this.positioningPhaseCancel();
            break;
        case "directionSelector_input":
            this.directionSelectorCancelPositioning();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputLeft = function () {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByDir("left");
            break;
        case "directionSelector_input":
            this.setDirectionSelectorLeft();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputRight = function () {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByDir("right");
            break;
        case "directionSelector_input":
            this.setDirectionSelectorRight();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputDown = function () {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByDir("down");
            break;
        case "directionSelector_input":
            this.setDirectionSelectorDown();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputUp = function () {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByDir("up");
            break;
        case "directionSelector_input":
            this.setDirectionSelectorUp();
            break;
    }
};

BattleManagerTBS.updatePositioningPhase = function () {
    if (this._subPhase === "troop") {
        if (!this.isAnimationPlaying()) {
            if (this._enemiesToPositionate.length === 0)
                this.waitForPositioningInput();
            else
                this.placeNextEnemy();
        }
    }
};

BattleManagerTBS.addEntity = function (battler, cell, anim, isNeutral) {
    var entity = new TBSEntity(battler, this.getLayer("battlers"));
    entity.setCell(cell);
    entity.newAnimation(anim, false, 0);
    entity._isNeutral = isNeutral;
    if (isNeutral)
        this._neutralEntities.push(entity);
    else
        this._battlerEntities.push(entity);
    return entity;
};

BattleManagerTBS.processActorsPrePositioning = function () {
    if (this._actorsToPositionate.length === 0) return;
    do {
        var actor = this._actorsToPositionate.shift();
        var cell = this.allyStartCells().filter(function (cell) {
            return cell._positioningData.fixed === actor.actorId();
        })[0];
        var entity = new TBSEntity(actor, this.getLayer("battlers"));
        entity.setCell(cell);
        this._battlerEntities.push(entity);
        LeUtilities.getScene().onActorPrePositioning(actor);
    } while (this._actorsToPositionate.length > 0);
};

BattleManagerTBS.processEnemyPositioning = function () {
    this._subPhase = "troop";
    if (Lecode.S_TBS.instantiateAll) {
        while (this._enemiesToPositionate.length > 0)
            this.placeNextEnemy();
    } else {
        this.placeNextEnemy();
    }
};

BattleManagerTBS.placeNextEnemy = function () {
    var enemy = this._enemiesToPositionate.shift();
    var cells = this.enemyStartCells().filter(function (c) {
        return c._positioningData.fixed === enemy.index() + 1 && this.isCellFree(c);
    }.bind(this));
    if (cells.length === 0) {
        cells = this.enemyStartCells().filter(function (c) {
            return this.isCellFree(c);
        }.bind(this));
    }
    var cell = LeUtilities.getRandomValueInArray(cells);
    if (cell) {
        cell.select();
        this.centerActiveCell();
        this.updateCursor();
        var entity = new TBSEntity(enemy, this.getLayer("battlers"));
        entity.setCell(cell);
        entity.newAnimation(Lecode.S_TBS.placedBattlerAnim, false, 0);
        this._battlerEntities.push(entity);
        this.drawPositioningArea(entity, "enemy");
    }
};

BattleManagerTBS.drawPositioningArea = function (entity, type) {
    var opacity = Lecode.S_TBS.positioningCellOpacity;
    var color = (type === "actor") ? Lecode.S_TBS.actorColorCell : Lecode.S_TBS.enemyColorCell;
    var cell = entity.getCell();
    this.getLayer("scopes").eraseCell(cell.x, cell.y);

    var bounds = this.getScopeBoundaries(entity.getSizeArea());
    var x = bounds.left;
    var y = bounds.top;
    var w = bounds.right - x + 1;
    var h = bounds.bottom - y + 1;
    this.getLayer("scopes").drawSquare(x, y, w, h, opacity, color);
};

BattleManagerTBS.waitForPositioningInput = function () {
    this._subPhase = "wait";
    this.selectNextStartCell();
    this.cursor().hide();
    LeUtilities.getScene().showPositioningWindow();
    LeUtilities.getScene().activatePositioningWindow();
};

BattleManagerTBS.processActorPositioning = function (actor) {
    this.cursor().show();
    InputHandlerTBS.setActive(true);
    this._subPhase = "input";
    var currentEntity = this.getEntityByActorId(actor.actorId());
    if (currentEntity) {
        this._currentPositioningEntity = currentEntity;
        this.positioningSelect(currentEntity.getCell());
        currentEntity.startFlash([255, 255, 255, 255], 20, true);
        return;
    }
    var entity = new TBSEntity(actor, this.getLayer("battlers"));
    var cell = this.getNextActorPositioningCell();
    entity.startFlash([255, 255, 255, 255], 20, true);
    this._currentPositioningEntity = entity;
    this.positioningSelect(cell);
    entity.newAnimation(Lecode.S_TBS.placedBattlerAnim, false, 0);
};

BattleManagerTBS.positioningSelect = function (cell) {
    cell.select();
    this.centerCell(cell);
    this.updateCursor();
    if (cell._positioningData && cell._positioningData.fixed)
        return;
    if (this._currentPositioningEntity) {
        var actorId = this._currentPositioningEntity.battler().actorId();
        if (this._positioningEntityToSwap) {
            this._positioningEntityToSwap.stopFLash();
        }
        var entity = cell.getEntity();
        if (entity && entity.battler().actorId() != actorId) {
            this._positioningEntityToSwap = entity;
            this._currentPositioningEntity.stopFLash();
            this._currentPositioningEntity.startFlash([255, 255, 255, 255], 20, true);
            entity.startFlash([255, 255, 255, 255], 20, true);
        } else {
            this._currentPositioningEntity.setCell(cell);
            this.updateEnemiesDirectionForPositioning();
            this._positioningEntityToSwap = null;
        }
    }
};

BattleManagerTBS.selectStartCellByDir = function (dir) {
    var cell = this._activeCell;
    var cells = this.allyStartCells().filter(function (c) {
        return c != cell;
    });
    var found = null;
    switch (dir) {
        case "up":
            cells = cells.filter(function (c) {
                return c.y < cell.y;
            });
            found = LeUtilities.closestByDistance(cell, cells);
            break;
        case "down":
            cells = cells.filter(function (c) {
                return c.y > cell.y;
            });
            found = LeUtilities.closestByDistance(cell, cells);
            break;
        case "right":
            cells = cells.filter(function (c) {
                return c.x > cell.x;
            });
            found = LeUtilities.closestByDistance(cell, cells);
            break;
        case "left":
            cells = cells.filter(function (c) {
                return c.x < cell.x;
            });
            found = LeUtilities.closestByDistance(cell, cells);
            break;
    }
    if (found && found != cell) {
        this.positioningSelect(found);
        SoundManager.playCursor();
    }
};

BattleManagerTBS.selectStartCellByTouch = function (cell) {
    if (cell) {
        var scope = this.allyStartCells();
        var currentCell = this._activeCell;
        if (this.isCellInScope(cell, scope)) {
            if (currentCell.isSame(cell)) {
                this.positioningPhaseOk();
            } else {
                this.positioningSelect(cell);
            }
        } else {
            this.positioningPhaseOk();
        }
    }
};

BattleManagerTBS.getNextActorPositioningCell = function () {
    if (this.allyEntities().length >= this.allyStartCells().length)
        return this.allyStartCells()[0];
    var currentIndex = this.allyStartCells().indexOf(this._activeCell);
    if (currentIndex === -1) {
        return this.allyStartCells()[0];
    }
    var cell = this._activeCell;
    var currentEntity = cell.getEntity();
    if (!currentEntity)
        return cell;
    var index = currentIndex;
    do {
        if (index === this.allyStartCells().length - 1)
            index = 0;
        else
            index++;
        cell = this.allyStartCells()[index];
        currentEntity = cell.getEntity();
    } while (currentEntity);
    return cell;
};

BattleManagerTBS.selectNextStartCell = function () {
    var cell = this.getNextActorPositioningCell();
    this.positioningSelect(cell);
    SoundManager.playCursor();
};

BattleManagerTBS.positioningPhaseOk = function () {
    SoundManager.playOk();
    var cell = this._activeCell;
    var entity = this._positioningEntityToSwap;
    if (entity) {
        entity.setCell(this._currentPositioningEntity.getCell());
        entity.stopFLash();
        this._currentPositioningEntity.setCell(cell);
        this._positioningEntityToSwap = null;
        return;
    }
    var actorId = this._currentPositioningEntity.battler().actorId();
    var currentEntity = this.getEntityByActorId(actorId);
    if (!currentEntity)
        this._battlerEntities.push(this._currentPositioningEntity);
    cell = this._currentPositioningEntity.getCell();
    if (!Lecode.S_TBS.enableDirectionalFacing)
        this.directionSelectorValidatePositioning();
    else
        this.callDirectionSelector(this._currentPositioningEntity, cell);
    LeUtilities.getScene()._windowPositioningConfirm.setEnabled(true);
    LeUtilities.getScene()._windowPositioningConfirm.refresh();
};

BattleManagerTBS.positioningPhaseCancel = function () {
    var entity = this._currentPositioningEntity;
    if (!entity) {
        SoundManager.playBuzzer();
        return;
    }
    this._subPhase = "wait";
    InputHandlerTBS.setActive(false);
    var actor = LeUtilities.getScene()._windowPositioning.actor();
    LeUtilities.getScene()._windowPositioning.enableSelection();
    LeUtilities.getScene()._windowPositioning.refresh();
    LeUtilities.getScene().activatePositioningWindow();
    this.cursor().hide();
    SoundManager.playCancel();
    this.destroyEntity(entity);
    this._currentPositioningEntity = null;
    if (this.allyEntities().length === 0) {
        LeUtilities.getScene()._windowPositioningConfirm.setEnabled(false);
        LeUtilities.getScene()._windowPositioningConfirm.refresh();
    }
};

BattleManagerTBS.updateEnemiesDirectionForPositioning = function () {
    var actors = this.allyEntities().concat([this._currentPositioningEntity]);
    this.enemyEntities().forEach(function (ent) {
        ent.lookClosestBattler(actors);
    }.bind(this));
};

BattleManagerTBS.callDirectionSelector = function (battler, cell) {
    this._subPhase = "directionSelector_input";
    this._directionSelector.set(cell, battler);
};

BattleManagerTBS.setDirectionSelectorUp = function () {
    this._directionSelector.setDir(8);
};

BattleManagerTBS.setDirectionSelectorDown = function () {
    this._directionSelector.setDir(2);
};

BattleManagerTBS.setDirectionSelectorLeft = function () {
    this._directionSelector.setDir(4);
};

BattleManagerTBS.setDirectionSelectorRight = function () {
    this._directionSelector.setDir(6);
};

BattleManagerTBS.directionSelectorValidatePositioning = function () {
    SoundManager.playOk();
    Input.clear();
    this._currentPositioningEntity.stopFLash();
    this._directionSelector.hide();
    this._subPhase = "";
    this._currentPositioningEntity = null;
    LeUtilities.getScene().activatePositioningWindow();
    this.cursor().hide();
    var nbrFixedActors = this.allyStartCells().filter(function (cell) {
        return cell._positioningData.fixed != null;
    }).length;
    if (this.allyEntities().length === (nbrFixedActors + $gameParty.members().length)
        || this.allyEntities().length === this.allyStartCells().length) {
        LeUtilities.getScene()._windowPositioning.deactivate();
        LeUtilities.getScene()._windowPositioning.deselect();
        this.positioningPhaseEnd();
    }
};

BattleManagerTBS.setDirectionSelectionDirByTouch = function (selectedCell) {
    var entity = this._directionSelector._battlerEntity;
    entity.lookAt(selectedCell);
    this.directionSelectorValidatePositioning();
};

BattleManagerTBS.directionSelectorCancelPositioning = function () {
    this._directionSelector.hide();
    this._subPhase = "input";
    this.positioningPhaseCancel();
};

BattleManagerTBS.positioningPhaseEnd = function () {
    this._subPhase = "confirm";
    Input.clear();
    LeUtilities.getScene().showConfirmationWindow();
};

BattleManagerTBS.resumePositioningPhase = function () {
    LeUtilities.getScene().hideConfirmationWindow();
    LeUtilities.getScene().activatePositioningWindow();
    LeUtilities.getScene()._windowPositioningConfirm.deselect();
    this._subPhase = "";
};

BattleManagerTBS.onConfirmationWindowOK = function () {
    switch (this._phase) {
        case "positioning":
            this.battleBeginning();
            break;
    }
};

BattleManagerTBS.onConfirmationWindowCancel = function () {
    switch (this._phase) {
        case "positioning":
            this.resumePositioningPhase();
            break;
    }
};

BattleManagerTBS.battleBeginning = function () {
    this._phase = "battle_beginning";
    LeUtilities.getScene().onTBSBattleBeginning();

    this._startSprite.visible = true;
    this._startSprite.x = Graphics.width / 2 - this._startSprite.width / 2;
    this._startSprite.y = Graphics.height / 2 - this._startSprite.height / 2;
    this._startSprite.opacity = 0;
    this._subPhase = "in";
};

BattleManagerTBS.updateBeginningPhase = function () {
    var opa;
    if (this._subPhase === "in") {
        opa = this._startSprite.opacity;
        this._startSprite.opacity = (opa + 6).clamp(0, 255);
        if (this._startSprite.opacity === 255) {
            this._subPhase = "wait";
            this.wait(Lecode.S_TBS.battleStartSpriteDelay);
        }
    } else if (this._subPhase === "wait") {
        if (!this.isWaiting())
            this._subPhase = "out";
    } else if (this._subPhase === "out") {
        opa = this._startSprite.opacity;
        this._startSprite.opacity = (opa - 6).clamp(0, 255);
        if (this._startSprite.opacity === 0) {
            this.beginningPhaseEnd();
        }
    }
};

BattleManagerTBS.beginningPhaseEnd = function () {
    this._startSprite.visible = false;
    this.cursor().show();
    this.processBattle();
};

BattleManagerTBS.processBattle = function () {
    InputHandlerTBS.setActive(true);
    this._phase = "battle_processing";
    this._subPhase = "";

    BattleManager.startBattle();
    this.allEntities().forEach(function (entity) {
        entity.onBattleStart();
    }.bind(this));
    this.hidePositioningCells();
    this.determineTurnOrder();
    //$gameTroop.increaseTurn();
    this.setEntitiesFlag();
    this.executeEventsWhen("battle_start");
    this.startTurn();

    InputHandlerTBS.setOnTouchCallback(this.battlePhaseOnTouchInput.bind(this))
        .setOnTouchCancelCallback(this.battlePhaseOnInputCancel.bind(this))
        .setOnOkCallback(this.battlePhaseOnInputOk.bind(this))
        .setOnCancelCallback(this.battlePhaseOnInputCancel.bind(this))
        .setOnUpCallback(this.battlePhaseOnInputUp.bind(this))
        .setOnRightCallback(this.battlePhaseOnInputRight.bind(this))
        .setOnDownCallback(this.battlePhaseOnInputDown.bind(this))
        .setOnLeftCallback(this.battlePhaseOnInputLeft.bind(this));
};

BattleManagerTBS.battlePhaseOnTouchInput = function (selectedCell) {
    switch (this._subPhase) {
        case "move":
            this.touchMoveSelection(selectedCell);
            break;
        case "directionSelector_input":
            this.passByTouch(selectedCell);
            break;
        case "attack":
        case "skill":
        case "item":
            this.touchActionSelection(selectedCell);
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputOk = function () {
    switch (this._subPhase) {
        case "move":
            this.validateMoveSelection();
            break;
        case "directionSelector_input":
            this.validatePass();
            break;
        case "attack":
        case "skill":
        case "item":
            this.validateActionSelection();
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputCancel = function () {
    switch (this._subPhase) {
        case "move":
            this.onMoveCancel();
            break;
        case "directionSelector_input":
            this.cancelPass();
            break;
        case "attack":
        case "skill":
        case "item":
            this.onActionCancel();
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputLeft = function () {
    switch (this._subPhase) {
        case "directionSelector_input":
            this.setDirectionSelectorLeft();
            break;
        case "move":
        case "attack":
        case "skill":
        case "item":
        case "examine":
            this.moveCursor("left");
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputRight = function () {
    switch (this._subPhase) {
        case "directionSelector_input":
            this.setDirectionSelectorRight();
            break;
        case "move":
        case "attack":
        case "skill":
        case "item":
        case "examine":
            this.moveCursor("right");
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputDown = function () {
    switch (this._subPhase) {
        case "directionSelector_input":
            this.setDirectionSelectorDown();
            break;
        case "move":
        case "attack":
        case "skill":
        case "item":
        case "examine":
            this.moveCursor("down");
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputUp = function () {
    switch (this._subPhase) {
        case "directionSelector_input":
            this.setDirectionSelectorUp();
            break;
        case "move":
        case "attack":
        case "skill":
        case "item":
        case "examine":
            this.moveCursor("up");
            break;
    }
};

BattleManagerTBS.updateBattleProcessing = function () {
    this.updateSequences();
    if (this.isWaiting()) return;
    if (this.turnOrderShouldWait()) return;

    this.checkSubPhase();
};

BattleManagerTBS.checkSubPhase = function () {
    switch (this._subPhase) {
        case "":
            LeUtilities.getScene().showCommandWindow();
            break;
        case "moving":
            if (!this.activeEntity().isMoving())
                this.onActiveEntityMoveEnd();
            break;
        case "action_start":
            this.executeAction();
            break;
        case "obj_invokation":
            if (!this.anySequenceRunning())
                this.onActionEnd();
            break;
        case "ai":
            this._aiManager.update();
            break;
        case "turn_end":
            this.nextTurn();
            break;
        case "turn_resuming":
            this.resumeTurn();
            break;
        case "pass":
            this.processCommandPass();
            break;
        default:
            break;
    }
};

BattleManagerTBS.hidePositioningCells = function () {
    this.getLayer("scopes").clear();
};

BattleManagerTBS.determineTurnOrder = function () {
    if (Lecode.S_TBS.turnOrderFairDistribution)
        this.determineTurnOrderFair();
    else
        this.determineTurnOrderSimple();
};

BattleManagerTBS.determineTurnOrderSimple = function () {
    var array = [];
    this._turnOrder = [];
    this._activeIndex = 0;

    this.allPlayableEntities().forEach(function (entity) {
        array.push(entity);
    });
    array = array.sort(function (a, b) {
        return eval(Lecode.S_TBS.turnOrderSortMethod);
    });

    this._turnOrder = array;
    this._turnOrderVisual.set(this._turnOrder);
};

BattleManagerTBS.determineTurnOrderFair = function () {
    var array = [];
    var actors = [];
    var enemies = [];
    this._turnOrder = [];
    this._activeIndex = 0;

    this.allyEntities().forEach(function (entity) {
        actors.push(entity);
    });
    actors = actors.sort(function (a, b) {
        return eval(Lecode.S_TBS.turnOrderSortMethod);
    });

    this.enemyEntities().forEach(function (entity) {
        enemies.push(entity);
    });
    enemies = enemies.sort(function (a, b) {
        return eval(Lecode.S_TBS.turnOrderSortMethod);
    });

    var partySet = actors[0]._battler.agi >= enemies[0]._battler.agi ? actors : enemies;
    var partyLeft = actors[0]._battler.agi >= enemies[0]._battler.agi ? enemies : actors;
    while (partySet.length > 0)
        array.push(partySet.shift());
    var index = 0;
    while (partyLeft.length > 0) {
        array.splice(index + 1, 0, partyLeft.shift());
        index += 2;
    }

    this._turnOrder = array;
    this._turnOrderVisual.set(this._turnOrder);
};

BattleManagerTBS.setEntitiesFlag = function () {
    this.allEntities().forEach(function (entity) {
        var cell = entity.getCell();
        if (this._startupFlags[cell.x])
            entity._flag = this._startupFlags[cell.x][cell.y];
        if (this._entitiesEvents[cell.x])
            entity._event = this._entitiesEvents[cell.x][cell.y];
    }.bind(this));
};

BattleManagerTBS.activeEntity = function () {
    return this._turnOrder[this._activeIndex];
};

BattleManagerTBS.activeBattler = function () {
    return this.activeEntity()._battler;
};

BattleManagerTBS.startTurn = function () {
    this._actionScope = {};
    this.getLayer("scopes").clear();
    this.getLayer("scopes").clearSelection();
    this._subPhase = "";
    var entity = this.activeEntity();
    entity.onTurnStart();

    var battler = this.activeBattler();
    this.newAction(battler, true);
    LeUtilities.getScene().showStatusWindow(entity, true);

    var cell = entity.getCell();
    this.setCursorCell(cell);
    this.cursor().show();

    if (entity.playableByAI()) {
        this.startAiTurn(entity);
    }

    this.executeEventsWhen("turn_start");
    if (this.activeBattler().isActor()) {
        this.executeEventsWhen("actor_turn_start");
    } else {
        this.executeEventsWhen("enemy_turn_start");
    }
    this.executeEntityEventsWhen("entity_turn_start", entity);
};

BattleManagerTBS.resumeTurn = function () {
    this._subPhase = "";
    var entity = this.activeEntity();
    LeUtilities.getScene().showStatusWindow(entity, true);

    var cell = entity.getCell();
    this.setCursorCell(cell);
    this.cursor().show();
};

BattleManagerTBS.startAiTurn = function (entity, options) {
    this._subPhase = "ai";
    if (entity.battler().isDead() || !entity.battler().canMove())
        this.requestCommandPass();
    else
        this._aiManager.process(entity, options);
    if (!Lecode.S_TBS.showScopes)
        this.cursor().hide();
};

BattleManagerTBS.updateSequences = function () {
    this.allEntities().forEach(function (entity) {
        entity._sequenceManager.update();
    });
};

BattleManagerTBS.anySequenceRunning = function () {
    return this.allEntities().some(function (entity) {
        return entity._sequenceManager.isRunning();
    });
};

BattleManagerTBS.newAction = function (battler, isFloating) {
    this._activeAction = isFloating ? new TBS_FloatingAction(battler, false) : new Game_Action(battler, false);
};

BattleManagerTBS.moveCursor = function (dir) {
    var x = this._activeCell.x,
        y = this._activeCell.y;
    switch (dir) {
        case "up":
            y--;
            break;
        case "down":
            y++;
            break;
        case "right":
            x++;
            break;
        case "left":
            x--;
            break;
    }
    var cell = this.getCellAt(x, y);
    this.setCursorCell(cell);
    SoundManager.playCursor();
};

BattleManagerTBS.setCursorCell = function (cell) {
    if (!cell) return;
    cell.select();
    this.centerCell(cell);
    this.updateCursor();
    this.updateScopeSelection();
    this.updateTargetStatus();
};

BattleManagerTBS.updateScopeSelection = function () {
    if (this.cursorOnMoveScope())
        this.updateMoveSelection();
    else if (this.cursorOnActionScope()) {
        this.updateActionSelection();
    } else {
        this.clearActionSelection();
        this.clearMoveSelection();
    }
};

BattleManagerTBS.updateTargetStatus = function () {
    var cell = this._activeCell;
    var entity = cell.getEntity();
    var scene = LeUtilities.getScene();
    if (entity) {
        scene.showStatusWindow(entity);
    } else {
        scene.showStatusWindow(this.activeEntity());
    }
};

BattleManagerTBS.onCommandInput = function (command) {
    switch (command) {
        case "move":
            this.processCommandMove();
            break;
        case "attack":
            this.processCommandAttack();
            break;
        case "skill":
            this.processCommandSkill();
            break;
        case "item":
            this.processCommandItem();
            break;
        case "pass":
            this.requestCommandPass();
            break;
        case "cancel":
            this.processCommandCancel();
            break;
    }
};

BattleManagerTBS.processCommandMove = function () {
    this._subPhase = "move";
    this.drawMoveScope(this.activeEntity());
};

BattleManagerTBS.makeMoveScope = function (entity, isFloating) {
    var center = entity.getCell().toCoords();
    var param = this.makeMoveScopeParam(entity);
    var data = entity.getMoveScopeData();
    var scope = this.getScopeFromData(data, center, param);
    if (isFloating) {
        return {
            cells: scope,
            center: center
        };
    }
    this._moveScope = {};
    this._moveScope.cells = scope;
    this._moveScope.center = center;
};

BattleManagerTBS.drawMoveScope = function (entity) {
    this.makeMoveScope(entity);
    var scope = this._moveScope.cells;
    var color = Lecode.S_TBS.moveColorCell;
    var opa = Lecode.S_TBS.moveCellOpacity;
    var invalidOpa = Lecode.S_TBS.moveInvalidCellOpacity;
    var invalidCondition = "!cell._walkable";
    this.getLayer("scopes").clear();
    this.drawScope(scope, color, opa, invalidOpa, invalidCondition);
};

BattleManagerTBS.makeMoveScopeParam = function (entity) {
    var param = {
        points: entity.getMovePoints(),
        user: entity,
        dir: entity.getDir(),
        exclude_center: true,
        can_select_obstacles: false,
        cells_reachable: true,
    };
    var data = entity.getMoveScopeParamData();
    data = LeUtilities.stringSplit(data, ",");
    data.forEach(function (arg) {
        if (arg.match(/through_obstacles/i))
            param.cells_reachable = false;
    }.bind(this));
    return param;
};

BattleManagerTBS.cursorOnMoveScope = function () {
    if (!this.isMoveScopeAvailable()) return false;
    for (var i = 0; i < this.moveScope().cells.length; i++) {
        var cell = this.moveScope().cells[i];
        if (cell._walkable) // && !cell.isObstacle())
            if (cell.x == this.cursor().cellX && cell.y == this.cursor().cellY)
                return true;
    }
    return false;
};

BattleManagerTBS.updateMoveSelection = function () {
    var sx = this.moveScope().center.x,
        sy = this.moveScope().center.y,
        dx = this.cursor().cellX,
        dy = this.cursor().cellY;
    var unitSize = this.activeEntity().getSizeAreaModel();
    this._movePath = this.getPathFromAToB(sx, sy, dx, dy, "walkable", [], unitSize);
    console.log("this._movePath:", this._movePath);
    if (!(this._subPhase === "ai" && !Lecode.S_TBS.showScopes))
        this.drawMoveSelection();
};

BattleManagerTBS.drawMoveSelection = function () {
    this.clearMoveSelection();
    var color = Lecode.S_TBS.moveColorCell;
    var scolor = Lecode.S_TBS.selectedMoveColorCell;
    var opacity = Lecode.S_TBS.moveSelectedCellOpacity;
    this.getLayer("scopes").drawSelectionCells(this.movePath(), opacity, color, scolor);
};

BattleManagerTBS.clearMoveSelection = function () {
    this.getLayer("scopes").clearSelection();
};

BattleManagerTBS.validateMoveSelection = function () {
    if (!this.cursorOnMoveScope()) {
        SoundManager.playBuzzer();
        return;
    }
    SoundManager.playOk();
    this.centerCell(this.activeEntity().getCell());
    this.activeEntity().processMovement(this.movePath());
    this._subPhase = "moving";
    this.getLayer("scopes").clear();
    this.clearMoveSelection();
};

BattleManagerTBS.touchMoveSelection = function (selectedCell) {
    var oldActiveCell = this._activeCell;
    this.setCursorCell(selectedCell);
    if (this.cursorOnMoveScope() && InputHandlerTBS.lastSelectedCell().isSame(selectedCell)) {
        this.validateMoveSelection();
    }
};

BattleManagerTBS.onActiveEntityMoveEnd = function () {
    this._subPhase = "";
    this._moveScope = {};
    this.activeEntity()._movePerformed = true;

    var entity = this.activeEntity();
    if (!entity.playableByAI()) {
        if (Lecode.S_TBS.autoPass && !entity.canMoveCommand() && entity._actionPerformed)
            this.requestCommandPass();
    }
    LeUtilities.getScene().showStatusWindow(entity);
    var cell = entity.getCell();
    this.setCursorCell(cell);

    this.executeEventsWhen("move_action_end");
    if (this.activeBattler().isActor()) {
        this.executeEventsWhen("actor_move_action_end");
    } else {
        this.executeEventsWhen("enemy_move_action_end");
    }
    this.executeEntityEventsWhen("entity_move_action_end", entity);
};

BattleManagerTBS.onMoveCancel = function () {
    this._subPhase = "";
    this.getLayer("scopes").clear();
    this.clearMoveSelection();
    this._moveScope = {};

    var cell = this.activeEntity().getCell();
    this.setCursorCell(cell);
    Input.clear();

    SoundManager.playCancel();
};

BattleManagerTBS.isMoveScopeAvailable = function () {
    return this.moveScope() && this.moveScope().cells && this.moveScope().center;
};

BattleManagerTBS.processCommandAttack = function () {
    this._subPhase = "attack";
    this.activeAction().setAttack();
    this.drawAttackScope(this.activeEntity());
};

BattleManagerTBS.makeAttackScope = function (entity) {
    var data = entity.getAttackScopeData();
    var battler = entity.battler();
    var obj = battler.isActor() ? battler.weapons()[0] : null;
    this.makeActionScope(entity, data, obj);
};

BattleManagerTBS.drawAttackScope = function (entity) {
    this.makeAttackScope(entity);
    this._actionScopeParam = {
        color: Lecode.S_TBS.attackColorCell,
        scolor: Lecode.S_TBS.selectedAttackColorCell,
        opacity: Lecode.S_TBS.attackCellOpacity,
        invalidOpa: Lecode.S_TBS.attackInvalidCellOpacity
    };
    this.drawActionScope(entity);
    this.updateScopeSelection();
};

BattleManagerTBS.updateAttackSelection = function () {
    this._actionAoE = this.getAttackAoE();
    if (!(this._subPhase === "ai" && !Lecode.S_TBS.showScopes))
        this.drawActionSelection();
};

BattleManagerTBS.getAttackAoE = function () {
    var data = this.activeEntity().getAttackAoEData();
    var center = this._activeCell.toCoords();
    var battler = this.activeEntity().battler();
    var obj = battler.isActor() ? battler.weapons()[0] : null;
    var param = this.makeObjAoEParam(obj, this.activeEntity(), center);
    return this.getScopeFromData(data, center, param);
};

BattleManagerTBS.processCommandSkill = function () {
    LeUtilities.getScene().showSkillWindow();
};

BattleManagerTBS.onSkillInput = function (command) {
    switch (command) {
        case "ok":
            this.onSkillSelected();
            break;
        case "cancel":
            this.onActionCancel();
            break;
    }
};

BattleManagerTBS.onSkillSelected = function () {
    var skill = LeUtilities.getScene()._windowSkill.item();
    if (skill) {
        this._subPhase = "skill";
        this.activeAction().setItemObject(skill);
        this.drawSkillScope(this.activeEntity(), skill);
    }
};

BattleManagerTBS.makeSkillScope = function (entity, obj) {
    obj = obj || this.activeAction().item();
    var data = entity.getObjectScopeData(obj);
    this.makeActionScope(entity, data, obj);
};

BattleManagerTBS.drawSkillScope = function (entity, obj) {
    this.makeSkillScope(entity, obj);
    this._actionScopeParam = {
        color: obj.TagsLetbs.scopeColor || Lecode.S_TBS.skillColorCell,
        scolor: obj.TagsLetbs.scopeSColor || Lecode.S_TBS.selectedSkillColorCell,
        opacity: obj.TagsLetbs.scopeOpacity || Lecode.S_TBS.skillCellOpacity,
        invalidOpa: Lecode.S_TBS.skillInvalidCellOpacity,
        selectedOpacity: Lecode.S_TBS.skillSelectedCellOpacity
    };
    this.drawActionScope(entity);
    this.updateScopeSelection();
};

BattleManagerTBS.processCommandItem = function () {
    LeUtilities.getScene().showItemWindow();
};

BattleManagerTBS.onItemInput = function (command) {
    switch (command) {
        case "ok":
            this.onItemSelected();
            break;
        case "cancel":
            this.onActionCancel();
            break;
    }
};

BattleManagerTBS.onItemSelected = function () {
    var item = LeUtilities.getScene()._windowItem.item();
    if (item) {
        this._subPhase = "item";
        this.activeAction().setItemObject(item);
        this.drawItemScope(this.activeEntity(), item);
    }
};

BattleManagerTBS.makeItemScope = function (entity, obj) {
    obj = obj || this.activeAction().item();
    var data = entity.getObjectScopeData(obj);
    this.makeActionScope(entity, data, obj);
};

BattleManagerTBS.drawItemScope = function (entity, obj) {
    this.makeItemScope(entity, obj);
    this._actionScopeParam = {
        color: obj.TagsLetbs.scopeColor || Lecode.S_TBS.ItemColorCell,
        scolor: obj.TagsLetbs.scopeSColor || Lecode.S_TBS.selectedItemColorCell,
        opacity: obj.TagsLetbs.scopeOpacity || Lecode.S_TBS.ItemCellOpacity,
        invalidOpa: Lecode.S_TBS.ItemInvalidCellOpacity,
        selectedOpacity: Lecode.S_TBS.ItemSelectedCellOpacity
    };
    this.drawActionScope(entity);
    this.updateScopeSelection();
};

BattleManagerTBS.updateActionSelection = function () {
    if (this._subPhase === "attack") {
        this.updateAttackSelection();
        return;
    }
    this._actionAoE = this.getActionAoE();
    if (!(this._subPhase === "ai" && !Lecode.S_TBS.showScopes))
        this.drawActionSelection();
};

BattleManagerTBS.getActionAoE = function () {
    var obj = this.activeAction().item();
    if (!obj) return [];
    var data = this.activeEntity().getObjectAoEData(obj);
    var center = this._activeCell.toCoords();
    var param = this.makeObjAoEParam(obj, this.activeEntity(), center);
    return this.getScopeFromData(data, center, param);
};

BattleManagerTBS.validateActionSelection = function () {
    if (!this.cursorOnActionScope()) {
        SoundManager.playBuzzer();
        return;
    }
    SoundManager.playOk();

    this.getLayer("scopes").clear();
    this.clearActionSelection();
    this.processAction();
};

BattleManagerTBS.touchActionSelection = function (selectedCell) {
    this.setCursorCell(selectedCell);
    if (this.cursorOnActionScope() && InputHandlerTBS.lastSelectedCell().isSame(selectedCell)) {
        this.validateActionSelection();
    }
};

BattleManagerTBS.onActionCancel = function () {
    this.getLayer("scopes").clear();
    this.clearActionSelection();
    this._actionScope = {};
    var cell = this.activeEntity().getCell();
    this.setCursorCell(cell);

    Input.clear();
    SoundManager.playCancel();
    if (this._subPhase === "skill") {
        this.processCommandSkill();
    } else if (this._subPhase === "item") {
        this.processCommandItem();
    }
    this._subPhase = "";

};

BattleManagerTBS.isActionScopeAvailable = function () {
    return this.actionScope() && this.actionScope().cells && this.actionScope().center;
};

BattleManagerTBS.processAction = function () {
    this._subPhase = "action_start";
    var entity = this.activeEntity();

    this.executeEventsWhen("action_start");
    if (this.activeBattler().isActor()) {
        this.executeEventsWhen("actor_action_start");
    } else {
        this.executeEventsWhen("enemy_action_start");
    }
    this.executeEntityEventsWhen("entity_action_start", entity);
};

BattleManagerTBS.executeAction = function () {
    this._subPhase = "obj_invokation";
    var action = this.activeAction();
    var item = action.item();
    var entity = this.activeEntity();
    var id = action.isAttack() ? entity.getWeaponSequenceData() : entity.getObjectSequenceData(item);
    var fastSequence = action.isAttack() ? entity.getWeaponFastSequence() : entity.getObjectFastSequence(item);
    entity.lookAt(this._activeCell);
    entity._actionPerformed = true;
    entity.battler()._itemOnUse = item;
    this.activeBattler().useItem(item);
    action.applyGlobal();
    entity.onActionStart(id, fastSequence, action);
    if (fastSequence.length > 0)
        entity.startSequence(fastSequence, action);
    else
        entity.startSequence(id, action);
};

BattleManagerTBS.onForcedActionStart = function (entity) {
    this._actionScope = {};
    this.getLayer("scopes").clear();
    this.getLayer("scopes").clearSelection();
};

BattleManagerTBS.onRequestedActionStart = function (entity) {
    this.onForcedActionStart(entity);
    entity._actionPerformed = false;
    entity._movePerformed = false;
};

BattleManagerTBS.onPrimarySequenceEnd = function (seqMng) {
    var entities = LeUtilities.uniqArray(seqMng._affectedTargets);
    this.processCounterAttack(entities, seqMng.getUser(), seqMng._action);
};

BattleManagerTBS.processCounterAttack = function (targets, subject, action) {
    if (!action) return;
    this.setCursorCell(subject.getCell());
    targets.forEach(function (entity) {
        if (entity) {
            var dist = LeUtilities.distanceBetweenCells(subject.getCell(), entity.getCell());
            if (dist <= 1 && Math.random() < action.itemCnt(entity.battler())) {
                var skill = $dataSkills[entity.battler().attackSkillId()];
                subject.battler().clearResult();
                entity.lookAt(subject.getCell());
                entity.addTextPopup("Counter");
                entity.startSequence("counter");
                this.forceAction(skill, entity);
            }
        }
    }.bind(this));
};

BattleManagerTBS.invokeObjEffects = function (user, item, targets, hitAnim, animDelay) {
    this.activeAction().setItemObject(item);
    this.prepareDirectionalDamageBonus(user, targets, item);
    this.applyObjEffects(user, targets, hitAnim, animDelay);
    this.dealObjTagEffects(user, targets);
    this.resetDirectionalDamageBonus(targets);
    this.refreshBattlersStatus();
};

BattleManagerTBS.applyObjEffects = function (user, targets, hitAnim, animDelay) {
    targets.forEach(function (target) {
        target.prepareExtraPopups();
        if (Math.random() < this.activeAction().itemMrf(target.battler()))
            this.processMagicReflection(user, target, hitAnim, animDelay);
        else {
            this.activeAction().apply(target.battler());
            if (target.battler().result().isHit()) {
                if (hitAnim)
                    target.newAnimation(hitAnim, false, animDelay);
                if (target.battler().result().hpDamage > 0)
                    target.callSequence("damaged");
            } else {
                target.callSequence("evaded");
            }
            target.onObjectEffects(user, this.activeAction().item());
            target.onDamage(user);
            if (target !== user)
                user.addPopup();
        }
    }.bind(this));
};

BattleManagerTBS.dealObjTagEffects = function (user, targets) {
    var item = this.activeAction().item();
    var movePointsDmg = user.battler().getLeTBSTagNumberValue("[deal]movePoints", 0);
    if (movePointsDmg !== 0) {
        targets.forEach(function (entity) {
            entity.changeMovePoints(movePointsDmg);
        });
    }
};

BattleManagerTBS.processMagicReflection = function (user, target, hitAnim, animDelay) {
    var cell = target.getCell();
    user.prepareExtraPopups();
    target.newAnimation(178, false, 0);
    this.activeAction().apply(user.battler());
    user.addTextPopup("Reflect");
    if (user.battler().result().isHit()) {
        if (hitAnim)
            user.newAnimation(hitAnim, false, animDelay);
        if (user.battler().result().hpDamage > 0)
            user.callSequence("damaged");
    } else {
        user.callSequence("evaded");
    }
    user.onObjectEffects(target, this.activeAction().item());
    user.onDamage(target);
};

BattleManagerTBS.invokeObjEffectsOnMap = function (user, item, cellTargets, hitAnim, animDelay) {
    this.applyObjEffectsOnMap(user, item, cellTargets, hitAnim, animDelay);
    this.refreshBattlersStatus();
};

BattleManagerTBS.applyObjEffectsOnMap = function (user, item, cellTargets, hitAnim, animDelay) {
    cellTargets.forEach(function (cell) {
        var target = cell.getEntity();
        var sprite;
        if (target) {
            if (Math.random() < this.activeAction().itemMrf(target.battler()))
                this.processMagicReflectionOnMap(user, item, target, hitAnim, animDelay);
            else {
                this.prepareDirectionalDamageBonus(user, [target], item);
                this.activeAction().apply(target.battler());
                if (target.battler().result().isHit()) {
                    sprite = target._sprite;
                    if (target.battler().result().hpDamage > 0)
                        target.callSequence("damaged");
                } else {
                    target.callSequence("evaded");
                }
                target.onObjectEffects(user, this.activeAction().item());
                target.onDamage(user);
                this.resetDirectionalDamageBonus([target]);
            }
        }
        if (hitAnim)
            this.getLayer("animations").newAnimation(hitAnim, false, animDelay, cell, sprite);
    }.bind(this));
};

BattleManagerTBS.processMagicReflectionOnMap = function (user, item, target, hitAnim, animDelay) {
    var sprite;
    var cell = user.getCell();
    user.prepareExtraPopups();
    this.prepareDirectionalDamageBonus(target, [user], item);
    this.activeAction().apply(user.battler());
    if (user.battler().result().isHit()) {
        sprite = user._sprite;
        if (user.battler().result().hpDamage > 0)
            user.callSequence("damaged");
    } else {
        user.callSequence("evaded");
    }
    user.onObjectEffects(target, this.activeAction().item());
    user.onDamage(target);
    this.resetDirectionalDamageBonus([target]);
    if (hitAnim)
        this.getLayer("animations").newAnimation(hitAnim, false, animDelay, cell, sprite);
};

BattleManagerTBS.applyFloatingDamage = function (amount, target) {
    target.battler().gainHp(-amount);
    target.addPopup();
    target.callSequence("damaged");
    target.checkDeath();
};

BattleManagerTBS.forceAction = function (obj, entity) {
    var battler = entity.battler();
    var center = entity.getCell().toCoords();
    var action = new TBS_FloatingAction(battler, false);
    action.setItemObject(obj);
    entity.battler()._itemOnUse = obj;

    var data = obj.id === battler.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(obj);
    this.makeActionScope(entity, data, obj);

    var aoeData = obj.id === battler.attackSkillId() ? entity.getAttackAoEData() : entity.getObjectAoEData(obj);
    var aoeCenter = this._activeCell.toCoords();
    var param = this.makeObjAoEParam(obj, entity, aoeCenter);
    var aoe = this.getScopeFromData(aoeData, aoeCenter, param);
    this._actionAoE = aoe;

    var item = action.item();
    var id = action.isAttack() ? entity.getWeaponSequenceData() : entity.getObjectSequenceData(item);
    battler.useItem(item);
    action.applyGlobal();
    entity.lookAt(this._activeCell);
    entity.appendSequence(id, action);
};

BattleManagerTBS.refreshBattlersStatus = function () {
    LeUtilities.getScene()._windowStatus.refresh();
};

BattleManagerTBS.onActionEnd = function (entity) {
    this._subPhase = "";
    this._actionScope = {};
    entity = entity || this.activeEntity();
    var cell = entity.getCell();
    this.setCursorCell(cell);
    Input.clear();
    LeUtilities.getScene().showStatusWindow(entity);

    var obj = this.activeAction().item();
    if (entity.passAfterObjUse(obj))
        this.requestCommandPass();
    else if (!entity.playableByAI()) {
        if (Lecode.S_TBS.autoPass && !entity.canMoveCommand())
            this.requestCommandPass();
    }

    this.getLayer("scopes").clear();
    this.getLayer("scopes").clearSelection();

    this.executeEventsWhen("action_end");
    if (this.activeBattler().isActor()) {
        this.executeEventsWhen("actor_action_end");
    } else {
        this.executeEventsWhen("enemy_action_end");
    }
    this.executeEntityEventsWhen("entity_action_end", entity);
    entity.battler()._itemOnUse = null;
};

BattleManagerTBS.onForcedActionEnd = function (entity) {
    this._actionScope = {};
    var cell = entity.getCell();
    this.setCursorCell(cell);
    this.getLayer("scopes").clear();
    this.getLayer("scopes").clearSelection();
    Lecode.S_TBS.requestedAction = false;
    entity.battler()._itemOnUse = null;
};

BattleManagerTBS.onRequestedActionEnd = function (entity) {
    this.onForcedActionEnd(entity);
    entity._actionPerformed = false;
    entity._movePerformed = false;
};

BattleManagerTBS.requestCommandPass = function () {
    this._subPhase = "pass";
};

BattleManagerTBS.processCommandPass = function () {
    var entity = this.activeEntity();
    var cell = entity.getCell();
    if (!this.activeEntity().playableByAI() && Lecode.S_TBS.enableDirectionalFacing) {
        this._subPhase = "directionSelector_input";
        this._beforePassDir = entity.getDir();
        this._directionSelector.set(cell, entity);
    } else {
        this.validatePass();
    }
};

BattleManagerTBS.cancelPass = function () {
    this._subPhase = "";
    this._directionSelector.hide();
    Input.clear();
    SoundManager.playCancel();
    this.activeEntity().setDir(this._beforePassDir);
};

BattleManagerTBS.validatePass = function () {
    this._directionSelector.hide();
    this.turnEnd();
};

BattleManagerTBS.passByTouch = function (selectedCell) {
    var entity = this._directionSelector._battlerEntity;
    entity.lookAt(selectedCell);
    this.validatePass();
};

BattleManagerTBS.turnEnd = function () {
    this._subPhase = "turn_end";
    var entity = this.activeEntity();
    entity.onTurnEnd();
    this.executeEventsWhen("turn_end");
    if (this.activeBattler().isActor()) {
        this.executeEventsWhen("actor_turn_end");
    } else {
        this.executeEventsWhen("enemy_turn_end");
    }
    this.executeEntityEventsWhen("entity_turn_end", entity);

    this.updateTiedEventsCooldown(entity);
};

BattleManagerTBS.turnOrderShouldWait = function () {
    var canContinue = !this.updateEvents() && this.checkDefeatAndVictory() && !this.isWaiting() && !this.anySequenceRunning();
    return !canContinue;
};

BattleManagerTBS.updateStartOfTurnEvents = function () {
    if (!this.turnOrderShouldWait()) {
        this.nextTurn();
    }
};

BattleManagerTBS.updateEndOfTurnEvents = function () {
    if (!this.turnOrderShouldWait()) {
        this._subPhase = "next_turn";
    }
};

BattleManagerTBS.updateEvents = function () {
    $gameTroop.updateInterpreter();
    $gameParty.requestMotionRefresh();
    if ($gameTroop.isEventRunning()) {
        return true;
    }
    $gameTroop.setupBattleEvent();
    if ($gameTroop.isEventRunning() || SceneManager.isSceneChanging()) {
        return true;
    }
    return false;
};

BattleManagerTBS.nextTurn = function () {
    do {
        this._activeIndex++;
        if (this._activeIndex >= this._turnOrder.length) {
            this._activeIndex = 0;
            this.onTurnOrderEnd();
        }
    } while (this.activeEntity()._dead);
    if (this.activeEntity().isTurnHidden()) {
        this.nextTurn();
        return;
    }
    this._turnOrderVisual.updateOnNextTurn(this._turnOrder, this._activeIndex);
    this.startTurn();
};

BattleManagerTBS.onTurnOrderEnd = function () {
    $gameTroop.increaseTurn();
    this._logWindow.startTurn();
    this.executeEventsWhen("turn_order_end");
};

BattleManagerTBS.processCommandCancel = function () {
    this._subPhase = "end_command";
    LeUtilities.getScene().showEndCommandWindow();
};

BattleManagerTBS.onEndCommandInput = function (command) {
    switch (command) {
        case "options":
            break;
        case "escape":
            this.processEscape();
            break;
        case "cancel":
            this.exitEndCommand();
            break;
    }
};

BattleManagerTBS.exitEndCommand = function () {
    this._subPhase = "";
    Input.clear();
};

BattleManagerTBS.processEscape = function () {
    $gameParty.performEscape();
    var success = BattleManager._preemptive ? true : (Math.random() < BattleManager._escapeRatio);
    if (success) {
        BattleManager._escaped = true;
        SoundManager.playEscape();
        this.prepareAbort();
    } else {
        var audio = {};
        audio.name = Lecode.S_TBS.escapeSound;
        audio.pitch = 100;
        audio.volume = 90;
        audio.pan = 0;
        AudioManager.playSe(audio);
        BattleManager._escapeRatio += 0.1;
        this.resumeBattle();
        this.nextTurn();
    }
};

BattleManagerTBS.checkDefeatAndVictory = function () {
    if (this.canPrepareDefeat()) {
        this.prepareDefeat();
        return false;
    } else if (this.canPrepareVictory()) {
        this.prepareVictory();
        return false;
    }
    return true;
};

BattleManagerTBS.canPrepareDefeat = function () {
    return this.allyEntities().every(function (entity) {
        return entity.battler().isActor() && entity.battler().isDead();
    });
};

BattleManagerTBS.canPrepareVictory = function () {
    return $gameTroop.isAllDead();
};

BattleManagerTBS.prepareAbort = function () {
    this._battleStopStatus = "abort";
    this.stopBattle();
};

BattleManagerTBS.prepareDefeat = function () {
    this._battleStopStatus = "defeat";
    this.stopBattle();
};

BattleManagerTBS.prepareVictory = function () {
    this._battleStopStatus = "victory";
    this.stopBattle();
    this.allyEntities().forEach(function (entity) {
        entity.startSequence("victory");
    });
};

BattleManagerTBS.processDefeat = function () {
    BattleManager.processDefeat();
    this._phase = "battle_end";
    this.enemyEntities().forEach(function (entity) {
        entity.startSequence("victory");
    });
};

BattleManagerTBS.processAbort = function () {
    BattleManager.processAbort();
    this._phase = "battle_end";
};

BattleManagerTBS.processVictory = function () {
    BattleManager.processVictory();
    this._phase = "battle_end";
};

BattleManagerTBS.stopBattle = function () {
    InputHandlerTBS.setActive(false);
    this._phase = "battle_stopping";
    this.wait(Lecode.S_TBS.endOfBattleWait);
    this.executeEventsWhen("battle_end");
};

BattleManagerTBS.updateBattleStopping = function () {
    LeUtilities.getScene()._windowCommand.close();
    this._directionSelector.hide();
    this.updateSequences();
    if (this.updateEvents() || this.anySequenceRunning()) return;
    var waiting = this.isWaiting();
    switch (this._battleStopStatus) {
        case "abort":
            waiting = waiting || this.isWaitingForAbortEvents();
            break;
        case "victory":
            waiting = waiting || this.isWaitingForVictoryEvents();
            break;
        case "defeat":
            waiting = waiting || this.isWaitingForDefeatEvents();
            break;
    }
    if (!waiting) {
        switch (this._battleStopStatus) {
            case "abort":
                this.processAbort();
                break;
            case "victory":
                this.processVictory();
                break;
            case "defeat":
                this.processDefeat();
                break;
        }
    }
};

BattleManagerTBS.isWaitingForAbortEvents = function () {
    return false;
};

BattleManagerTBS.isWaitingForVictoryEvents = function () {
    return false;
};

BattleManagerTBS.isWaitingForDefeatEvents = function () {
    return false;
};

BattleManagerTBS.updateBattleEnd = function () {
    BattleManager.updateBattleEnd();
    this._phase = null;
};

BattleManagerTBS.onEntityDeath = function (entity) {
    if (this.activeEntity() === entity) {
        this.getLayer("scopes").clear();
        this.getLayer("scopes").clearSelection();
        this.turnEnd();
    }
    this._turnOrderVisual.updateOnEntityDeath(this._turnOrder, this._activeIndex);
    this.executeEntityEventsWhen("entity_death", entity);

    if (entity.hasNoCorpse())
        this.destroyEntity(entity, false);
};

BattleManagerTBS.onEntityRevive = function (entity) {
    this._turnOrderVisual.updateOnEntityRevive(this._turnOrder, this._activeIndex);
};

BattleManagerTBS.destroyEntity = function (entity, removeTurn) {
    if (removeTurn)
        this.removeEntityTurn(entity);
    entity.destroy();
    LeUtilities.removeInArray(this._battlerEntities, entity);
    LeUtilities.removeInArray(this._neutralEntities, entity);
};

BattleManagerTBS.removeEntityTurn = function (entity) {
    var index;
    for (var i = 0; i < this._turnOrder.length; i++) {
        var e = this._turnOrder[i];
        if (entity === e)
            index = i;
    }
    if (isNaN(index)) return;
    LeUtilities.removeInArray(this._turnOrder, entity);
    if (this._activeIndex >= index)
        this._activeIndex--;
    this._turnOrderVisual.set(this._turnOrder, this._activeIndex);
};

BattleManagerTBS.makeActionScope = function (entity, data, obj, isFloating) {
    var bodySize = entity.getSizeArea();
    var scope = [], param;
    for (var i = 0; i < bodySize.length; i++) {
        var cell = bodySize[i];
        var center = cell.toCoords();
        param = this.makeObjScopeParam(obj, entity, center);
        var subScope = this.getScopeFromData(data, center, param);
        scope = scope.concat(subScope);
    }
    if (param.exclude_center) {
        scope = scope.filter(function (cell) {
            return !entity.isOnCell(cell);
        });
    }
    scope = LeUtilities.uniqArray(scope);
    if (isFloating) {
        return {
            cells: scope,
            center: entity.getCell().toCoords()
        };
    }
    this._actionScope = {};
    this._actionScope.cells = scope;
    this._actionScope.center = entity.getCell().toCoords();
};

BattleManagerTBS.drawActionScope = function (entity) {
    var color = this._actionScopeParam.color;
    var opacity = this._actionScopeParam.opacity;
    var invalidOpa = this._actionScopeParam.invalidOpa;
    var scope = this._actionScope.cells;
    var invalidCondition = "!cell._selectable || (cell.isObstacleForLOS() && !cell.isThereEntity())";
    this.getLayer("scopes").clear();
    this.drawScope(scope, color, opacity, invalidOpa, invalidCondition);
};

BattleManagerTBS.makeObjScopeParam = function (obj, entity, center) {
    obj = obj || this.activeAction().item();
    var param = {
        user: entity,
        dir: entity.getDirectionTo(center),
        need_check_los: true,
        exclude_center: true,
        line_of_sight: true,
        remove_nonvisibleCells: false,
        select: obj ? obj.TagsLetbs.scopeSelect : null
    };
    if (!obj) return param;
    var data = obj.TagsLetbs.scopeOptions;
    data = LeUtilities.stringSplit(data, ",");
    data.forEach(function (arg) {
        if (arg.match(/include_center/i))
            param.exclude_center = false;
        else if (arg.match(/through_obstacles/i))
            param.line_of_sight = false;
        else if (arg.match(/need_free_cell/i))
            param.need_free_cell = true;
    }.bind(this));
    return param;
};

BattleManagerTBS.makeObjAoEParam = function (obj, entity, center) {
    obj = obj || this.activeAction().item();
    var param = {
        user: entity,
        dir: entity.getDirectionTo(center)
    };
    this._requestSpecialSelection = null;
    if (!obj) return param;
    var data = obj.TagsLetbs.aoeOptions;
    data = LeUtilities.stringSplit(data, ",");
    data.forEach(function (arg) {
        if (arg.match(/line_of_sight/i)) {
            this._requestSpecialSelection = {};
            param.need_check_los = true;
            param.line_of_sight = true;
            param.remove_nonvisibleCells = true;
        } else if (arg.match(/exclude_center/i)) {
            param.exclude_center = true;
        } else if (arg.match(/need_free_cell/i)) {
            param.need_free_cell = true;
        } else if (arg.match(/exclude_user/i)) {
            param.exclude_user = true;
        } else if (arg.match(/exclude_allies/i)) {
            param.exclude_allies = true;
        } else if (arg.match(/exclude_enemies/i)) {
            param.exclude_enemies = true;
        } else if (arg.match(/exclude_free_cells/i)) {
            param.exclude_free_cells = true;
        }
    }.bind(this));
    return param;
};

BattleManagerTBS.cursorOnActionScope = function () {
    if (!this.isActionScopeAvailable()) return false;
    for (var i = 0; i < this.actionScope().cells.length; i++) {
        var cell = this.actionScope().cells[i];
        if (cell._selectable && !(cell.isObstacle() && !cell.isThereEntity())) {
            if (cell.x == this.cursor().cellX && cell.y == this.cursor().cellY) {
                return true;
            }
        }
    }
    return false;
};

BattleManagerTBS.drawActionSelection = function () {
    this.clearActionSelection();
    var color = this._actionScopeParam.color;
    var scolor = this._actionScopeParam.scolor;
    var opacity;
    var invalidOpa = this._actionScopeParam.invalidOpa;
    if (this._requestSpecialSelection) {
        var aoe = this._requestSpecialSelection.aoe;
        opacity = invalidOpa;
        this.getLayer("scopes").drawSelectionCells(aoe, opacity, color, scolor);
    }
    opacity = this._actionScopeParam.selectedOpacity;
    this.getLayer("scopes").drawSelectionCells(this._actionAoE, opacity, color, scolor);
};

BattleManagerTBS.clearActionSelection = function () {
    this.getLayer("scopes").clearSelection();
};

BattleManagerTBS.getScopeFromData = function (data, center, param) {
    var scope = [];

    var scopesStr = data.split(";");
    for (var i = 0; i < scopesStr.length; i++) {
        var scopeStr = scopesStr[i].trim();
        scope = scope.concat(this.makeScope(scopeStr, center, param));
    }
    scope = LeUtilities.uniqArray(scope);

    if (this._requestSpecialSelection) {
        this._requestSpecialSelection.aoe = scope;
    }
    scope = this.applyParamToScope(scope, center, param);
    return scope;
};

BattleManagerTBS.makeScope = function (data, center, param) {
    var str, min, size;
    var e = param.user;
    if (e)
        var a = e.battler();

    if (data.match(/(circle|line|square|cross)\((.+)\)/i)) {
        if (RegExp.$2.includes(",")) {
            str = RegExp.$2.split(",");
            size = Math.floor(Number(eval(str[0])));
            min = Math.floor(Number(eval(str[1])));
        } else {
            size = Math.floor(Number(eval(RegExp.$2)));
        }
    }

    if (data.match(/custom\((.+)\)/i)) {
        var scopeData = Lecode.S_TBS.Config.Custom_Scopes[String(RegExp.$1)];
        scope = this.getScopeFromRawData(scopeData, center, param);
    } else if (data.match(/circle\((.+)\)/i)) {
        scope = this.makeCircleScope(center, size, min, param);
    } else if (data.match(/line\((.+)\)/i)) {
        scope = this.makeLineScope(center, size, min, param);
    } else if (data.match(/square\((.+)\)/i)) {
        scope = this.makeSquareScope(center, size, min, param);
    } else if (data.match(/cross\((.+)\)/i)) {
        scope = this.makeCrossScope(center, size, min, param);
    } else if (data.match(/path/i)) {
        scope = this.makePathScope(param);
    } else {
        var cx = center.x;
        var cy = center.y;
        var aoe = eval("[" + data + "]");
        for (var i = 0; i < aoe.length; i++) {
            var cell = this.getCellAt(aoe[i][0], aoe[i][1]);
            if (cell)
                scope.push(cell);
        }
    }
    return LeUtilities.uniqArray(scope);
};

BattleManagerTBS.getScopeFromRawData = function (scopeData, center, param) {
    var scope = [];
    var cx = center.x;
    var cy = center.y;
    var ux = this.activeEntity()._cell.x;
    var uy = this.activeEntity()._cell.y;
    var dir = param.dir;
    var dirData = eval("scopeData.data_" + LeUtilities.directionCodeToText(dir));
    var data = dirData ? dirData : scopeData.data;
    var array = eval("[" + data + "]");
    array.forEach(function (arr) {
        var cell = this.getCellAt(arr[0], arr[1]);
        if (cell)
            scope.push(cell);
    }.bind(this));
    return LeUtilities.uniqArray(scope);
};

BattleManagerTBS.makeCircleScope = function (center, range, min, param) {
    var cells = [];
    var start = param.exclude_center ? 1 : 0;
    var x = center.x,
        y = center.y;
    for (var i = start; i <= range; i++) {
        cells.push(this.getCellAt(x + i, y));
        cells.push(this.getCellAt(x - i, y));
        cells.push(this.getCellAt(x, y + i));
        cells.push(this.getCellAt(x, y - i));
        for (var a = start; a <= range - i; a++) {
            cells.push(this.getCellAt(x - i, y - a));
            cells.push(this.getCellAt(x - i, y + a));
            cells.push(this.getCellAt(x + i, y - a));
            cells.push(this.getCellAt(x + i, y + a));
        }
    }
    cells = cells.filter(function (cell) {
        return cell;
    }.bind(this));
    if (min) {
        var minCells = this.makeCircleScope(center, min, null, param);
        cells = cells.filter(function (cell) {
            return !this.isCellInScope(cell, minCells);
        }.bind(this));
    }
    return cells;
};

BattleManagerTBS.makeSquareScope = function (center, range, min, param) {
    var cells = [];
    var x = center.x,
        y = center.y;
    for (var i = -range; i <= range; i++) {
        for (var j = -range; j <= range; j++) {
            if (param.exclude_center && i === 0 && j === 0)
                continue;
            cells.push(this.getCellAt(x + i, y + j));
        }
    }
    cells = cells.filter(function (cell) {
        return cell;
    }.bind(this));
    if (min) {
        var minCells = this.makeSquareScope(center, min, null, param);
        cells = cells.filter(function (cell) {
            return !this.isCellInScope(cell, minCells);
        }.bind(this));
    }
    return cells;
};

BattleManagerTBS.makeRectScope = function (center, width, height, param) {
    var cells = [];
    var x = center.x,
        y = center.y;
    for (var i = 0; i < width; i++) {
        cells.push(this.getCellAt(x + i, y));
        for (var j = 0; j < height; j++) {
            cells.push(this.getCellAt(x + i, y + j));
        }
    }

    cells = cells.filter(function (cell) {
        return cell;
    }.bind(this));
    return cells;
};

BattleManagerTBS.makeLineScope = function (center, range, min, param) {
    var cells = [];
    var start = param.exclude_center ? 1 : 0;
    start = min || start;
    var x = center.x,
        y = center.y;
    for (var i = start; i <= range; i++) {
        cells.push(this.getCellAt(x + i, y));
        cells.push(this.getCellAt(x - i, y));
        cells.push(this.getCellAt(x, y + i));
        cells.push(this.getCellAt(x, y - i));
    }
    cells = cells.filter(function (cell) {
        return cell;
    }.bind(this));
    if (min) {
        var minCells = this.makeLineScope(center, min, null, param);
        cells = cells.filter(function (cell) {
            return !this.isCellInScope(cell, minCells);
        }.bind(this));
    }
    return cells;
};

BattleManagerTBS.makeCrossScope = function (center, range, min, param) {
    var cells = [];
    var start = param.exclude_center ? 1 : 0;
    var x = center.x,
        y = center.y;
    for (var i = start; i <= range; i++) {
        cells.push(this.getCellAt(x + i, y + i));
        cells.push(this.getCellAt(x + i, y - i));
        cells.push(this.getCellAt(x - i, y + i));
        cells.push(this.getCellAt(x - i, y - i));
    }
    cells = cells.filter(function (cell) {
        return cell;
    }.bind(this));
    if (min) {
        var minCells = this.makeCrossScope(center, min, null, param);
        cells = cells.filter(function (cell) {
            return !this.isCellInScope(cell, minCells);
        }.bind(this));
    }
    return cells;
};

BattleManagerTBS.makePathScope = function (param) {
    var sx = param.user.getCell().x;
    var sy = param.user.getCell().y;
    var dx = this._activeCell.x;
    var dy = this._activeCell.y;
    return this.getPathFromAToB(sx, sy, dx, dy, "free", []);
};

BattleManagerTBS.applyParamToScope = function (cells, center, param) {
    cells = this.removeInvalidCells(cells);
    if (!param.exclude_center) {
        var centerCell = this.getCellAt(center.x, center.y);
        if (!this.isCellInScope(centerCell, cells))
            cells.push(centerCell);
    }
    if (param.exclude_user) {
        cells = cells.filter(function (cell) {
            //return !cell.isSame(param.user.getCell());
            return !param.user.isOnCell(cell);
        });
    }
    if (param.exclude_allies) {
        var user = param.user;
        var party = user.battler().isEnemy() ? this.enemyEntities() : this.allyEntities();
        cells = cells.filter(function (cell) {
            return !party.some(function (e) {
                //return cell.isSame(e.getCell());
                return e.isOnCell(cell);
            });
        });
    }
    if (param.exclude_enemies) {
        var user = param.user;
        var party = user.battler().isActor() ? this.enemyEntities() : this.allyEntities();
        cells = cells.filter(function (cell) {
            return !party.some(function (e) {
                //return cell.isSame(e.getCell());
                return e.isOnCell(cell);
            });
        });
    }
    if (!param.can_select_obstacles) {
        if (param.remove_obstacles)
            cells = this.removeObstaclesFromScope(cells);
    }
    if (param.cells_reachable) {
        this.checkScopeWalkable(cells, param, center);
        if (param.remove_unreachableCells)
            cells = this.makeScopeReachable(cells, param.points, center);
    }
    if (param.need_check_los) {
        cells.forEach(function (cell) {
            cell._selectable = true;
        }.bind(this));
        if (param.select) {
            cells = this.selectScopeTargets(cells, param.select, param.user);
        }
        if (param.line_of_sight) {
            this.checkScopeVisibility(cells, center);
            if (param.remove_nonvisibleCells)
                cells = this.makeScopeVisible(cells, center);
        }
    }
    if (param.need_free_cell) {
        cells = this.removeObstaclesFromScope(cells);
        cells = this.removeEntitiesFromScope(cells);
    }
    return cells;
};

BattleManagerTBS.removeInvalidCells = function (cells) {
    return cells.filter(function (cell) {
        return cell;
    });
};

BattleManagerTBS.removeObstaclesFromScope = function (cells) {
    return cells.filter(function (cell) {
        return !cell.isObstacle();
    });
};

BattleManagerTBS.removeEntitiesFromScope = function (cells) {
    return cells.filter(function (cell) {
        return !cell.isThereEntity();
    });
};

BattleManagerTBS.checkScopeWalkable = function (cells, param, center) {
    var range = param.points;
    var entity = param.user;
    for (var i = 0; i < cells.length; i++) {
        cells[i]._walkable = false;
    }

    var unitSize = entity.getSizeAreaModel();
    var grid;
    var cellsToIgnore = [];
    if (unitSize.length > 1) {
        cellsToIgnore = this.shiftScope(unitSize, center);
        //cellsToIgnore.shift();
        grid = this.getWalkableSubGridForEasyStar(cellsToIgnore, unitSize);
        /*console.log("center:", center);
        console.log("cellsToIgnore:", cellsToIgnore);
        console.log("grid:", grid);*/
        //this.getLayer("scopes").debugGrid(grid);
    } else
        grid = this.getWalkableGridForEasyStar();
    this._easystar.setGrid(grid);
    this._easystar.setAcceptableTiles([0]);
    this._easystar.enableSync();

    var scope = LeUtilities.sortByClosestDistance(center, cells);
    scope.reverse();
    var reachables = [];
    for (i = 0; i < scope.length; i++) {
        var cell = scope[i];
        cell._walkable = this.isCellReachable(cell, range, center, reachables, cellsToIgnore, grid);
        reachables = LeUtilities.uniqArray(reachables);
    }
};

BattleManagerTBS.makeScopeReachable = function (cells, range, center) {
    return cells.filter(function (cell) {
        return cell._walkable;
    }.bind(this));
};

BattleManagerTBS.isCellReachable = function (cell, range, center, reachables, cellsToIgnore, grid) {
    for (var j = 0; j < reachables.length; j++) {
        if (cell.isSame(reachables[j])) {
            return true;
        }
    }

    if (!(this.isCellInScope(cell, cellsToIgnore) && grid[cell.y][cell.x] === 0)) {
        if (cell.getEntity()) {
            if (!cell.getEntity().entitiesCanLayOnMe())
                return false;
        } else if (cell.isObstacle())
            return false;
    }
    var path = [];
    var pathResult = null;
    var sx = center.x;
    var sy = center.y;
    var dx = cell.x;
    var dy = cell.y;
    this._easystar.findPath(sx, sy, dx, dy, function (result) {
        pathResult = result;
    });
    this._easystar.calculate();
    if (!pathResult)
        return false;
    pathResult.shift();
    if (pathResult.length > range)
        return false;
    if (reachables) reachables.push(cell);
    return true;
};

BattleManagerTBS.selectScopeTargets = function (cells, str, user) {
    var conditions = [], flagId, actorId, enemyId, evalStr;

    var query = str.split(",");
    query.forEach(function (type) {
        var condition = function () { return false; };
        if (type === "user") {
            condition = function (e) {
                //return e.getCell().isSame(user.getCell());
                return user.isOnCell(e.getCell());
            };
        } else if (type === "allies") {
            condition = function (e) {
                return e && LeUtilities.isAlly(user.battler(), e.battler());
            };
        } else if (type === "enemies") {
            condition = function (e) {
                return e && LeUtilities.isEnemy(user.battler(), e.battler());
            };
        } else if (type.match(/flaggedentity\((.+)\)/i)) {
            flagId = RegExp.$1;
            condition = function (e) {
                return e && e._flag === flagId;
            };
        } else if (type.match(/actorId\((.+)\)/i)) {
            actorId = Number(RegExp.$1);
            condition = function (e) {
                return e && e.battler().isActor() && e.battler().actorId() === actorId;
            };
        } else if (type.match(/enemyId\((.+)\)/i)) {
            actorId = Number(RegExp.$1);
            condition = function (e) {
                return e && e.battler().isEnemy() && e.battler().enemyId() === enemyId;
            };
        } else if (type.match(/eval\((.+)\)/i)) {
            evalStr = RegExp.$1;
            condition = function (e) {
                if (!e) return false;
                var b = e.battler();
                var a = user.battler();
                return eval(evalStr);
            };
        }
        conditions.push(condition);
    });

    var match = function (e) {
        if (e) {
            for (var i = 0; i < conditions.length; i++) {
                var condition = conditions[i];
                if (condition(e)) return true;
            }
        }
        return false;
    };
    cells.forEach(function (cell) {
        var e = cell.getEntity();
        cell._selectable = (cell._selectable && match(e));
    }, this);
    return cells;
};

BattleManagerTBS.checkScopeVisibility = function (cells, center) {
    var w = $gameMap.tileWidth();
    var h = $gameMap.tileHeight();
    var cx = center.x * w + w / 2;
    var cy = center.y * h + h / 2;
    var obstacles = [];
    var boundaries = this.getScopeBoundaries(cells);
    for (var x = boundaries.left; x <= boundaries.right; x++) {
        for (var y = boundaries.top; y <= boundaries.bottom; y++) {
            var cell = this.getCellAt(x, y);
            if (cell.isObstacleForLOS())
                obstacles.push(cell);
        }
    }
    /*for (var k = 0; k < cells.length; k++) {
    	if (cells[k].isObstacle())
    		obstacles.push(cells[k]);
    }*/
    var nonVisible = [];

    /*for (var i = 0; i < cells.length; i++) {
        cells[i]._selectable = true;
    }*/

    for (i = 0; i < obstacles.length; i++) {
        var cellsToCheck = this.cellsToCheckNearObstacle(obstacles[i], cells, center);
        for (var j = 0; j < cellsToCheck.length; j++) {
            var cellToCheck = cellsToCheck[j];
            if (obstacles[i].x == cellToCheck.x && obstacles[i].y == cellToCheck.y)
                continue;
            var dx = cellToCheck.x * w + w / 2;
            var dy = cellToCheck.y * h + h / 2;
            //- var sprite = SceneManager._scene._spriteset._debugLayer;
            var pixels = LeUtilities.getPixelsOfLine(cx, cy, dx, dy);
            for (var k = 0; k < obstacles.length; k++) {
                var obstacle = obstacles[k];
                if (obstacle.x == center.x && obstacle.y == center.y)
                    continue;
                if (obstacle.isSame(cellToCheck))
                    continue;
                var x = obstacle.x * w;
                var y = obstacle.y * h;
                for (var m = 0; m < pixels.length; m++) {
                    if (LeUtilities.doesRectIncludeCoord(x, y, w, h, pixels[m])) {
                        nonVisible.push([cellToCheck.x, cellToCheck.y]);
                        m = pixels.length;
                    }
                }
            }
        }
    }

    for (i = 0; i < nonVisible.length; i++) {
        for (var j = 0; j < cells.length; j++) {
            if (cells[j].x === nonVisible[i][0] && cells[j].y === nonVisible[i][1]) {
                cells[j]._selectable = false;
            }
        }
    }
};

BattleManagerTBS.checkSingleCellVisibility = function (cell, center) {
    var w = $gameMap.tileWidth();
    var h = $gameMap.tileHeight();
    var cx = center.x * w + w / 2;
    var cy = center.y * h + h / 2;

    var obstacles = [];
    var cells = this.getAllCells();
    for (var i = 0; i < cells.length; i++) {
        if (cells[i].isObstacleForLOS())
            obstacles.push(cells[i]);
    }
    cell._selectable = true;

    var dx = cell.x * w + w / 2;
    var dy = cell.y * h + h / 2;
    var pixels = LeUtilities.getPixelsOfLine(cx, cy, dx, dy);
    for (var k = 0; k < obstacles.length; k++) {
        var obstacle = obstacles[k];
        if (obstacle.x === center.x && obstacle.y === center.y)
            continue;
        if (obstacle.isSame(cell))
            continue;
        var x = obstacle.x * w;
        var y = obstacle.y * h;
        for (var m = 0; m < pixels.length; m++) {
            if (LeUtilities.doesRectIncludeCoord(x, y, w, h, pixels[m])) {
                cell._selectable = false;
                return;
            }
        }
    }
};

BattleManagerTBS.cellsToCheckNearObstacle = function (obstacle, cells, center) {
    var cx = center.x,
        cy = center.y;
    var result = [];
    var condition;
    if (obstacle.y > cy && obstacle.x > cx)
        condition = "cell.x >= obstacle.x && cell.y >= obstacle.y";
    else if (obstacle.y > cy && obstacle.x < cx)
        condition = "cell.x <= obstacle.x && cell.y >= obstacle.y";
    else if (obstacle.y < cy && obstacle.x > cx)
        condition = "cell.x >= obstacle.x && cell.y <= obstacle.y";
    else if (obstacle.y < cy && obstacle.x < cx)
        condition = "cell.x <= obstacle.x && cell.y <= obstacle.y";
    else if (obstacle.y == cy && obstacle.x < cx)
        condition = "cell.x <= obstacle.x";
    else if (obstacle.y == cy && obstacle.x > cx)
        condition = "cell.x >= obstacle.x";
    else if (obstacle.x == cx && obstacle.y < cy)
        condition = "cell.y <= obstacle.y";
    else if (obstacle.x == cx && obstacle.y > cy)
        condition = "cell.y >= obstacle.y";
    for (var i = 0; i < cells.length; i++) {
        var cell = cells[i];
        if (cell._selectable && eval(condition))
            result.push(cell);
    }
    return result;
};

BattleManagerTBS.makeScopeVisible = function (cells, center) {
    return cells.filter(function (cell) {
        return !!cell._selectable;
    }.bind(this));
};

BattleManagerTBS.getScopeBoundaries = function (cells) {
    if (cells.length === 0) {
        return {};
    }
    var copy = cells.filter(function (cell) {
        return true;
    });
    var cellsByX = copy.sort(function (cellA, cellB) {
        return (cellA.x > cellB.x) ? 1 : ((cellA.x < cellB.x) ? -1 : 0);
    });
    var rightCell = cellsByX.leU_last();
    var leftCell = cellsByX[0];
    var cellsByY = copy.sort(function (cellA, cellB) {
        return (cellA.y > cellB.y) ? 1 : ((cellA.y < cellB.y) ? -1 : 0);
    });
    var bottomCell = cellsByY.leU_last();
    var topCell = cellsByY[0];
    return {
        left: leftCell.x,
        right: rightCell.x,
        top: topCell.y,
        bottom: bottomCell.y
    };
};

BattleManagerTBS.getPathFromAToB = function (sx, sy, dx, dy, gridType, cellsToIgnore, unitSize) {
    var path = [];
    var pathResult = null;
    var grid;
    if (gridType === "walkable") {
        if (unitSize.length > 1) {
            cellsToIgnore = this.shiftScope(unitSize, { x: sx, y: sy });
            //cellsToIgnore.shift();
            grid = this.getWalkableSubGridForEasyStar(cellsToIgnore, unitSize);
        } else {
            grid = this.getWalkableGridForEasyStar(cellsToIgnore);
        }
    } else if (gridType === "free") {
        grid = this.getFreeGridForEasyStar();
    } else {
        grid = this.getGridForEasyStar();
    }
    this._easystar.setGrid(grid);
    this._easystar.setAcceptableTiles([0]);
    this._easystar.enableSync();
    this._easystar.findPath(sx, sy, dx, dy, function (result) {
        pathResult = result;
    });
    this._easystar.calculate();
    if (!pathResult) return [];
    pathResult.shift();
    for (var i = 0; i < pathResult.length; i++) {
        var cellArr = pathResult[i];
        var cell = this.getCellAt(cellArr.x, cellArr.y);
        path.push(cell);
    }
    return path;
};

BattleManagerTBS.getGridForEasyStar = function () {
    var grid = [];
    for (var y = 0; y < $gameMap.height(); y++) {
        var arr = [];
        for (var x = 0; x < $gameMap.width(); x++) {
            var cell = this.getCellAt(x, y);
            if (!cell || cell.isObstacle())
                arr.push(1);
            else
                arr.push(0);
        }
        grid.push(arr);
    }
    return grid;
};

BattleManagerTBS.getFreeGridForEasyStar = function () {
    var grid = [];
    for (var y = 0; y < $gameMap.height(); y++) {
        var arr = [];
        for (var x = 0; x < $gameMap.width(); x++) {
            var cell = this.getCellAt(x, y);
            if (!cell)
                arr.push(1);
            else
                arr.push(0);
        }
        grid.push(arr);
    }
    return grid;
};

BattleManagerTBS.getWalkableGridForEasyStar = function (cellsToIgnore) {
    cellsToIgnore = cellsToIgnore || [];
    var grid = [];
    for (var y = 0; y < $gameMap.height(); y++) {
        var arr = [];
        for (var x = 0; x < $gameMap.width(); x++) {
            var cell = this.getCellAt(x, y);
            if (this.isCellInScope(cell, cellsToIgnore)) {
                arr.push(0);
            } else if (cell) {
                var entity = cell.getEntity();
                if (entity) {
                    arr.push(entity.isPassable() ? 0 : 1);
                } else {
                    arr.push(cell.isObstacle() ? 1 : 0);
                }
            } else
                arr.push(1);
        }
        grid.push(arr);
    }
    return grid;
};

BattleManagerTBS.getWalkableSubGridForEasyStar = function (cellsToIgnore, unitSize) {
    cellsToIgnore = cellsToIgnore || [];
    var grid = [];
    for (var y = 0; y < $gameMap.height(); y++) {
        var arr = [];
        for (var x = 0; x < $gameMap.width(); x++) {
            var centerCell = { x: x, y: y };
            var cells = this.shiftScope(unitSize, centerCell);

            var allIgnore = cells.every(function (cell) {
                return this.isCellInScope(cell, cellsToIgnore);
            }, this);
            var allExisting = cells.every(function (cell) {
                return !!cell;
            }, this);
            if (allIgnore) {
                arr.push(0);
            } else if (allExisting) {
                var hasEntity = cells.some(function (cell) {
                    if (this.isCellInScope(cell, cellsToIgnore)) return false;
                    var entity = cell.getEntity();
                    return entity && !entity.isPassable();
                }, this);
                var hasObstacle = cells.some(function (cell) {
                    if (this.isCellInScope(cell, cellsToIgnore)) return false;
                    return cell.isObstacle();
                }, this);
                if (hasEntity || hasObstacle)
                    arr.push(1);
                else
                    arr.push(0);
            } else
                arr.push(1);
        }
        grid.push(arr);
    }
    return grid;
};

BattleManagerTBS.drawScope = function (cells, color, opa, invalidOpa, invalidCondition) {
    for (var i = 0; i < cells.length; i++) {
        var cell = cells[i];
        var opacity;
        if (eval(invalidCondition))
            opacity = invalidOpa;
        else
            opacity = opa;
        this.getLayer("scopes").drawCell(cell.x, cell.y, opacity, color);
    }
};

BattleManagerTBS.isCellInScope = function (cell, scope) {
    for (var i = 0; i < scope.length; i++) {
        if (scope[i].isSame(cell))
            return true;
    }
    return false;
};

BattleManagerTBS.getEntitiesInScope = function (scope) {
    var entities = [];
    for (var i = 0; i < scope.length; i++) {
        var cell = scope[i];
        var entity = cell.getEntity();
        if (entity)
            entities.push(entity);
    }
    return entities;
};

BattleManagerTBS.closestWalkableCellTo = function (cellTarget, scope) {
    return scope.sort(function (a, b) {
        var obj_aPath = this.getPathFromAToB(a.x, a.y, cellTarget.x, cellTarget.y, "walkable", [cellTarget]);
        var obj_bPath = this.getPathFromAToB(b.x, b.y, cellTarget.x, cellTarget.y, "walkable", [cellTarget]);
        var obj_aDist = obj_aPath.length === 0 ? 999 : obj_aPath.length;
        var obj_bDist = obj_bPath.length === 0 ? 999 : obj_bPath.length;
        return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
    }.bind(this))[0];
};

BattleManagerTBS.farthestWalkableCellTo = function (cellTarget, scope) {
    return scope.sort(function (a, b) {
        var obj_aPath = this.getPathFromAToB(a.x, a.y, cellTarget.x, cellTarget.y, "walkable", [cellTarget]);
        var obj_bPath = this.getPathFromAToB(b.x, b.y, cellTarget.x, cellTarget.y, "walkable", [cellTarget]);
        var obj_aDist = obj_aPath.length === 0 ? 999 : obj_aPath.length;
        var obj_bDist = obj_bPath.length === 0 ? 999 : obj_bPath.length;
        return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
    }.bind(this)).pop();
};

BattleManagerTBS.processCollisionEffects = function (entity) {
    var collisionData = entity._collisionData;
    if (!collisionData.endCell) return;

    var distance = collisionData.distance;
    var covered = collisionData.covered;
    var user = collisionData.user;
    var obj = collisionData.obj;
    var a = user.battler();
    var b = entity.battler();
    var formula = Lecode.S_TBS.defaultCollisionFormula;
    if (obj && obj.TagsLetbs.collisionFormula) {
        formula = obj.TagsLetbs.collisionFormula;
    }
    var damage = Math.floor(eval(formula));
    var dmgBonus = user.getCollisionDamageBonus(damage, obj);
    var dmgMinus = entity.getCollisionDamageReduction(damage, obj);
    damage += dmgBonus - dmgMinus;
    if (damage < 0) damage = 0;
    this.applyFloatingDamage(Math.floor(damage), entity);

    var endCell = collisionData.endCell;
    var next = endCell.getEntity();
    while (next) {
        if (next.battler().isDead())
            break;
        damage -= damage * Lecode.S_TBS.collissionDamageChainRate;
        this.applyFloatingDamage(Math.floor(damage), next);
        var oldDir = next.getDir();
        next.setDir(collisionData.dir);
        endCell = next.getForwardCell();
        next.setDir(oldDir);
        next = endCell.getEntity();
    }
    entity._collisionData = null;
};

BattleManagerTBS.prepareDirectionalDamageBonus = function (user, targets, item) {
    var oldUserDir = user.getDir();
    for (var i = 0; i < targets.length; i++) {
        var entity = targets[i];
        if (entity === user) continue;
        var dir = entity.getDir();
        var effects = 0;
        user.lookAt(entity.getCell());
        if (user.getDir() === dir) {
            effects = Lecode.S_TBS.backDirectionalDamageEffects * 0.01;
            effects += user.getDirectionalDmgBonus("back", item);
            effects -= entity.getDirectionalDmgReduction("back", item);
        } else if (user.getDir() === 2 && dir === 8 || user.getDir() === 8 && dir === 2 ||
            user.getDir() === 4 && dir === 6 || user.getDir() === 6 && dir === 4) {
            effects = Lecode.S_TBS.frontDirectionalDamageEffects * 0.01;
            effects += user.getDirectionalDmgBonus("front", item);
            effects -= entity.getDirectionalDmgReduction("front", item);
        } else {
            effects = Lecode.S_TBS.sideDirectionalDamageEffects * 0.01;
            effects += user.getDirectionalDmgBonus("side", item);
            effects -= entity.getDirectionalDmgReduction("side", item);
        }
        entity.battler().leTBS_setDirectionalDmgEffects(effects);
    }
    user.setDir(oldUserDir);
};

BattleManagerTBS.resetDirectionalDamageBonus = function (targets) {
    for (var i = 0; i < targets.length; i++) {
        targets[i].battler().leTBS_setDirectionalDmgEffects(0);
    }
};

BattleManagerTBS.executeEventsByTouch = function (entity) {
    var cell = entity.getForwardCell();
    if (cell) {
        var event = this.getTBSEventAt(cell.x, cell.y);
        if (event && event.canTriggerWhen("touch")) {
            event.start();
            this._lastTriggeredEventEntity = entity;
            this._lastTriggeredEventBattler = entity.battler();
        }
    }
};

BattleManagerTBS.executeEventsByStep = function (entity) {
    var cell = entity.getCell();
    var event = this.getTBSEventAt(cell.x, cell.y);
    if (event && event.canTriggerWhen("step_on")) {
        event.start();
        this._lastTriggeredEventEntity = entity;
        this._lastTriggeredEventBattler = entity.battler();
        return event._stopWhenStepped;
    }
    return false;
};

BattleManagerTBS.executeEventsWhen = function (condition) {
    var tbsEvents = this._tbsEvents;
    for (var i = 0; i < tbsEvents.length; i++) {
        var tbsEvent = tbsEvents[i];
        if (tbsEvent.canTriggerWhen(condition))
            tbsEvent.start();
    }
    this.allEntities().forEach(function (entity) {
        this.executeEntityEventsWhen(condition, entity);
    }, this);
};

BattleManagerTBS.executeEventsByForce = function (id) {
    var tbsEvents = this._tbsEvents;
    for (var i = 0; i < tbsEvents.length; i++) {
        var tbsEvent = tbsEvents[i];
        if (tbsEvent._event.eventId() === id) {
            tbsEvent.start();
            break;
        }
    }
};

BattleManagerTBS.executeEntityEventsWhen = function (condition, entity) {
    var events = entity.getTiedEvents();
    for (var i = 0; i < events.length; i++) {
        var tbsEvent = events[i];
        if (tbsEvent && tbsEvent.canTriggerWhen(condition)) {
            var id = tbsEvent.event()._commonEventId;
            if (!this._entityEventsCooldown[id]) {
                var str = tbsEvent.triggerConditions();
                if (!str || this.evaluateEntityEventConditions(str)) {
                    this._triggeredEventEntity = entity;
                    var list = $dataCommonEvents[id].list;
                    $gameTroop._interpreter.setupInQueue(list);
                    this._entityEventsCooldown[id] = tbsEvent._cooldown;
                }
            }
        }
    }
};

BattleManagerTBS.updateTiedEventsCooldown = function (entity) {
    entity.getTiedEvents().forEach(function (tbsEvent) {
        var id = tbsEvent.event()._commonEventId;
        this._entityEventsCooldown[id] = Math.max(0, this._entityEventsCooldown[id] - 1);
    }, this);
};

BattleManagerTBS.hideEntity = function (entity) {
    this.destroyEntity(entity);
    this._hiddenEntities.push(entity);
    entity.hideTurn();
    this._turnOrderVisual.updateOnEntityHide();
};

BattleManagerTBS.showEntity = function (entity) {
    if (entity._isNeutral)
        this._neutralEntities.push(entity);
    else
        this._battlerEntities.push(entity);
    entity.showTurn();
    this._turnOrderVisual.updateOnEntityShow();
    LeUtilities.removeInArray(this._hiddenEntities, entity);
};

BattleManagerTBS.allyStartCells = function () {
    return this._startCells.filter(function (cell) {
        return cell._positioningData.type === "actor";
    });
};

BattleManagerTBS.enemyStartCells = function () {
    return this._startCells.filter(function (cell) {
        return cell._positioningData.type === "enemy";
    });
};

BattleManagerTBS.allyEntities = function () {
    return this.allPlayableEntities().filter(function (ent) {
        return ent._battler.isActor();
    });
};

BattleManagerTBS.enemyEntities = function () {
    return this.allPlayableEntities().filter(function (ent) {
        return !ent._battler.isActor();
    });
};

BattleManagerTBS.isCellFree = function (cell) {
    if (cell == null) return true;
    return cell.getEntity() == null;
};

BattleManagerTBS.getCellAt = function (x, y) {
    if (this._groundCells[x])
        return this._groundCells[x][y];
    return null;
};

BattleManagerTBS.getAllCells = function () {
    var cells = [];
    for (var i = 0; i < $gameMap.width(); i++) {
        for (var j = 0; j < $gameMap.height(); j++) {
            cells.push(this._groundCells[i][j]);
        }
    }
    return cells;
};

BattleManagerTBS.shiftScope = function (scope, centerCell) {
    var cells = [];
    for (var i = 0; i < scope.length; i++) {
        var cell = scope[i];
        cells.push(this.getCellAt(cell.x + centerCell.x, cell.y + centerCell.y));
    }
    return cells;
};

BattleManagerTBS.getEntityAt = function (x, y) {
    var cell = this.getCellAt(x, y);
    if (cell)
        return cell.getEntity();
    return null;
};

BattleManagerTBS.getEntitiesXY = function (excludeActive) {
    var arr = [];
    if (!this.allEntities()) return arr;
    for (var i = 0; i < this.allEntities().length; i++) {
        var entity = this.allEntities()[i];
        if (!(excludeActive && entity == this.activeEntity()))
            arr.push([entity._cell.x, entity._cell.y]);
    }
    return arr;
};

BattleManagerTBS.getEntityByBattler = function (battler) {
    var entities = this.allEntitiesWithHidden();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity.battler() === battler)
            return entity;
    }
};

BattleManagerTBS.getEntitiesByEnemyId = function (enemyId) {
    var result = [];
    var entities = this.enemyEntities();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity.battler().enemyId() === enemyId)
            result.push(entity);
    }
    return result;
};

BattleManagerTBS.getEntityByEnemyId = function (enemyId) {
    return this.getEntitiesByEnemyId(enemyId)[0];
};

BattleManagerTBS.getEntityByActorId = function (actorId) {
    var entities = this.allyEntities();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity.battler().actorId() === actorId)
            return entity;
    }
    return null;
};

BattleManagerTBS.getEntityByName = function (name) {
    var entities = this.allEntitiesWithHidden();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        var battler = entity.battler();
        if (battler.isActor() && battler.name === name || battler.isEnemy() && battler.originalName() === name)
            return entity;
    }
    return null;
};

BattleManagerTBS.getFlaggedEntity = function (flagId) {
    var entities = this.allEntitiesWithHidden();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity._flag === flagId)
            return entity;
    }
    return null;
};

BattleManagerTBS.getCellAwayParty = function (scope, party) {
    var results = [];
    for (var j = 0; j < scope.length; j++) {
        var cell = scope[j];
        var data = {
            dist: 0,
            cell: cell
        };
        for (var i = 0; i < party.length; i++) {
            var entity = party[i];
            var dist = LeUtilities.distanceBetweenCells(cell, entity.getCell());
            data.dist += dist;
        }
        results.push(data);
    }
    var best = LeUtilities.getMaxInArrayBy(results, "dist");
    return best ? best.cell : null;
};

BattleManagerTBS.getCellTowardParty = function (scope, party) {
    var results = [];
    for (var j = 0; j < scope.length; j++) {
        var cell = scope[j];
        var data = {
            dist: 0,
            cell: cell
        };
        for (var i = 0; i < party.length; i++) {
            var entity = party[i];
            var dist = LeUtilities.distanceBetweenCells(cell, entity.getCell());
            data.dist += dist;
        }
        results.push(data);
    }
    var best = LeUtilities.getMinInArrayBy(results, "dist");
    return best ? best.cell : null;
};

BattleManagerTBS.getCellNear = function (center, destCell, maxRange) {
    var foundCell = null;
    var range = 1;
    var reachables = [];
    var grid = this.getWalkableGridForEasyStar();
    this._easystar.setGrid(grid);
    this._easystar.setAcceptableTiles([0]);
    this._easystar.enableSync();
    if (!destCell.isSame(center) && BattleManagerTBS.isCellReachable(destCell, maxRange, center, reachables))
        return destCell;
    do {
        var scope = this.makeCircleScope(destCell, range, null, {});
        scope = LeUtilities.sortByClosestDistance(center, scope);
        for (var i = 0; i < scope.length; i++) {
            var cell = scope[i];
            if (!cell.isSame(center) && BattleManagerTBS.isCellReachable(cell, maxRange, center, reachables)) {
                foundCell = cell;
                break;
            }
        }
        range += 1;
    } while (!foundCell || foundCell.isSame(center));
    return foundCell;
};

BattleManagerTBS.getCellAway = function (center, destCell, maxRange) {
    var range = Math.min(LeUtilities.distanceBetween(center, destCell), maxRange);
    var scope = [];
    do {
        scope = this.makeCircleScope(center, range, null, {}).filter(function (cell) {
            return !cell.isSame(center) && BattleManagerTBS.isCellReachable(cell, maxRange, center, []);
        });
        range++;
        if (range >= maxRange)
            break;
    } while (scope.length === 0);
    return LeUtilities.farthestByDistance(destCell, scope);
};

BattleManagerTBS.centerActiveCell = function () {
    this.centerCell(this._activeCell);
};

BattleManagerTBS.centerCell = function (cell) {
    $gamePlayer.center(cell.x, cell.y);
};

BattleManagerTBS.scrollRight = function (distance) {
    var oldX = $gameMap._displayX;
    var oldY = $gameMap._displayY;
    var oldPX = $gameMap._parallaxX;
    var oldPY = $gameMap._parallaxY;
    $gameMap.setDisplayPos(oldX + distance, oldY);
};

BattleManagerTBS.scrollDown = function (distance) {
    var oldX = $gameMap._displayX;
    var oldY = $gameMap._displayY;
    var oldPX = $gameMap._parallaxX;
    var oldPY = $gameMap._parallaxY;
    $gameMap.setDisplayPos(oldX, oldY + distance);
};

BattleManagerTBS.scrollLeft = function (distance) {
    this.scrollRight(-distance);
};

BattleManagerTBS.scrollUp = function (distance) {
    this.scrollDown(-distance);
};

BattleManagerTBS.isAnimationPlaying = function () {
    return this.getLayer("animations").isAnimationPlaying() || this.allEntities().some(function (entity) {
        return entity._sprite.isAnimationPlaying();
    });
};

BattleManagerTBS.isAllEnemyDead = function () {
    return this.enemyEntities().every(function (entity) {
        return entity.battler().isDead();
    });
};

BattleManagerTBS.evaluateEntityEventConditions = function (str) {
    var aEntity = this.activeEntity();
    var aBattler = aEntity ? aEntity.battler() : null;
    var aAction = this.activeAction();
    var aObject = aAction ? aAction.item() : null;

    var isActiveEntity = function () {
        if (!aEntity) return false;
        var queries = arguments;
        for (var i = 0; i < queries.length; i++) {
            var query = queries[i];
            var result = false;
            if (query.match(/actor\s(.+)/i))
                result = aBattler.isActor() && aBattler.actor().id === Number(RegExp.$1);
            else if (query.match(/enemy\s(.+)/i))
                result = aBattler.isEnemy() && aBattler.enemy().id === Number(RegExp.$1);
            else if (query.match(/flag\s(.+)/i))
                result = aEntity._flag === RegExp.$1;
            else
                result = query === (aBattler.isActor() ? aBattler.name() : aBattler.originalName());
            if (result) return true;
        }
        return false;
    };
    var isActiveSkill = function () {
        if (!aAction) return;
        if (!aAction.isSkill()) return;
        var queries = arguments;
        for (var i = 0; i < queries.length; i++) {
            var query = queries[i];
            var result = false;
            var number = Number(query);
            if (isNaN(number)) {
                result = aObject.name === query;
            } else {
                result = aObject.id === number;
            }
            if (result) return true;
        }
        return false;
    };

    return eval(str);
};

BattleManagerTBS.evaluateSequenceConditions = function (seqMng, str) {

    var entity = function (query) {
        query = query.trim();
        if (query === "user")
            return seqMng.getUser();
        else if (query.match(/actor\s(.+)/i))
            return this.getEntityByActorId(Number(RegExp.$1));
        else if (query.match(/enemy\s(.+)/i))
            return this.getEntityByEnemyId(Number(RegExp.$1));
        else if (query.match(/flag\s(.+)/i))
            return this.getFlaggedEntity(RegExp.$1);
        return null;
    };

    var isHit = function (entityTargets) {
        var entities = seqMng.readTargets(entityTargets);
        return entities.every(function (e) {
            var result = e.battler().result();
            if (result) return result.isHit();
            return false;
        });
    };

    var isAnyHit = function (entityTargets) {
        var entities = seqMng.readTargets(entityTargets);
        return entities.some(function (e) {
            var result = e.battler().result();
            if (result) return result.isHit();
            return false;
        });
    };

    try {
        return eval(str);
    } catch (e) {
        throw new Error("Condition eval error!");
    }
};


BattleManagerTBS.makeTrajectory = function (sx, sy, dx, dy, h, d, type) {
    var mx, my, p1, p2, p3, p4;
    var xDist = Math.abs(dx - sx);
    var yDist = Math.abs(dy - sy);
    var topY = (dx >= sy) ? sy : dy;

    if (type.match(/(.+)\((\d+)\)/i)) {
        var data = Lecode.S_TBS.Config.Trajectories[RegExp.$1];
        var dataPoints = data.points.slice();
        var range = -Number(RegExp.$2);
        var distance = LeUtilities.distanceBetween(
            { x: sx, y: sy },
            { x: dx, y: dy }
        );
        var angle = Math.atan2(dy - sy, dx - sx);
        var result = [];

        //-Handle special cases
        var startPoint, endPoint;
        for (var i = 0; i < dataPoints.length; i++) {
            var content = dataPoints[i];
            var path = [];
            if (typeof content === "string") {
                if (content.match(/\((.+)\)/i)) {
                    var strTable = RegExp.$1.split(",");
                    var sx1 = sx + Number(strTable[0]) * distance;
                    var sy1 = sy + Number(strTable[1]) * range;
                    var dx1 = sx + Number(strTable[2]) * distance;
                    var dy1 = sy + Number(strTable[3]) * range;
                    startPoint = LeUtilities.rotatePoint(sx, sy, angle, {
                        x: sx1, y: sy1
                    });
                    endPoint = LeUtilities.rotatePoint(sx, sy, angle, {
                        x: dx1, y: dy1
                    });
                }
                if (content.match(/parabola\((.+)\)/i)) {
                    path = LeUtilities.getPixelsOfJump(startPoint.x, startPoint.y,
                        endPoint.x, endPoint.y, -range);
                } else if (content.match(/linear\((.+)\)/i)) {
                    path = LeUtilities.getPixelsOfLine(startPoint.x, startPoint.y,
                        endPoint.x, endPoint.y);
                }
                if (Math.round(path[0][0]) != startPoint.x || Math.round(path[0][1]) != startPoint.y)
                    path = path.reverse();
                path.push("control");
                result = result.concat(path);
            }
        }
        //-Work with splines from now on
        dataPoints = dataPoints.filter(function (content) {
            return typeof content !== "string";
        });

        if (angle > Math.PI / 2)
            range *= -1;
        var pointsArray = dataPoints.join(",").split(",");
        var points = LeUtilities.getCurvePoints(pointsArray);
        var coords = [];
        //- Scale curved points to player's landmark
        //- And rotate them
        for (var i = 0; i < points.length; i += 2) {
            var x = sx + points[i] * distance;
            var y = sy + points[i + 1] * range;
            var newPoint = LeUtilities.rotatePoint(sx, sy, angle, {
                x: x, y: y
            });
            coords.push([newPoint.x, newPoint.y]);
        }
        coords.push("control");
        return result.concat(coords);
    } else if (type === "normal_jump") {
        mx = sx + (dx - sx) / 2;
        my = sy + ((dy - sy) / 2) - h;
    } else {
        mx = dx;
        my = dy;
    }
    p1 = { x: sx, y: sy };
    p2 = { x: mx, y: my };
    p3 = { x: mx, y: my };
    p4 = { x: dx, y: dy };
    var path = LeUtilities.getBezierTrajectory(d, p1, p2, p3, p4);
    if (path[0][0] != sx || path[0][1] != sy)
        path = path.reverse();
    path.push("control");
    return path;

    /*if (sx === dx) {
        if (type === "curverd_jump" && h !== 0) {
            var sign = LeUtilities.aOrB(1, -1);
            var extraX = sign * this.randValueBetween(14, 20);
            p1 = { x: sx, y: sy };
            p2 = {
                x: sx + extraX,
                y: sy + yDist * 0.1
            };
            p3 = {
                x: sx + extraX,
                y: sy + yDist * 0.5
            };
            p4 = { x: dx, y: dy };
            return LeUtilities.getBezierTrajectory(d, p1, p2, p3, p4);
        } else {
            mx = sx;
            my = sy - h;
        }
    }*/
};


/*-------------------------------------------------------------------------
* AI Manager
-------------------------------------------------------------------------*/
function TBSAiManager() {
    this.initialize.call(this, arguments);
}

TBSAiManager.prototype.initialize = function () {
    this._entity = null;
    this._battler = null;
    this._commandRunning = null;
    this._ifArray = [];
    this._targetData = null;
    this._cellTarget = null;
    this._failureCode = "";
    this._constructionDelay = 0;
};

TBSAiManager.prototype.process = function (entity, aiOptions) {

    if (this.getEnemiesOf(entity.battler(), true).length === 0) {
        this.forceEnd();
        return;
    }

    this._aiOptions = aiOptions || {};
    this._entity = entity;
    this._battler = entity._battler;
    this._phase = 0;
    this._commands = this.getBehavior().slice();
    this._commandRunning = null;
    this._commandNextPhaseCallBack = null;
    this._commandExtraData = {};
    this._actionBuilding = {};
    this._actionData = null;
    this._actionDataType = null;
    this._builtData = {};
    this._isBuilding = true;
    this._commandPhase = "init";
    this.makeOffenseData();
    this.makeHealingData();
    this.makeSupportData();
    this.makeMoveData();
    this.makeSummonData();
    this.updateEscapeCooldown();
    this.updateSupportCooldown();
};

TBSAiManager.prototype.updateEscapeCooldown = function () {
    if (!this._entity._aiEscapeCount)
        this._entity._aiEscapeCount = 0;
    if (this._entity._aiEscapeCount > 0)
        this._entity._aiEscapeCount--;
};

TBSAiManager.prototype.updateSupportCooldown = function () {
    if (!this._entity._aiSupportCount)
        this._entity._aiSupportCount = 0;
    if (this._entity._aiSupportCount > 0)
        this._entity._aiSupportCount--;
};

TBSAiManager.prototype.makeOffenseData = function () {
    var party = this.getEnemiesOf(this._battler, true);
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (!this._entity.rpgObject().TagsLetbs.aiNoAttack && skill.id === this._battler.attackSkillId() || skill.TagsLetbsAi.type.match("offense")) {
            objects.push(skill);
        }
    }
    this.makeActionData("offense", party, objects);
};

TBSAiManager.prototype.makeHealingData = function () {
    var party = this.getAlliesOf(this._battler, false);
    party.push(this._entity);
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (skill.TagsLetbsAi.type.match("healing")) {
            objects.push(skill);
        }
    }
    this.makeActionData("healing", party, objects);
};

TBSAiManager.prototype.makeSupportData = function () {
    var party = this.getAlliesOf(this._battler, false);
    party.push(this._entity);
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (skill.TagsLetbsAi.type.match("support")) {
            objects.push(skill);
        }
    }
    this.makeActionData("support", party, objects);
};

TBSAiManager.prototype.makeMoveData = function () {
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (skill.TagsLetbsAi.type.match("move")) {
            objects.push(skill);
        }
    }
    this.makeActionData("move", [], objects);
};

TBSAiManager.prototype.makeSummonData = function () {
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (skill.TagsLetbsAi.type.match("summon")) {
            objects.push(skill);
        }
    }
    this.makeActionData("summon", [], objects);
};

TBSAiManager.prototype.updateOffenseActionsBuilding = function () {
    this.updateActionsBuilding("offense", "nbrEnemies");
};

TBSAiManager.prototype.updateHealingActionsBuilding = function () {
    this.updateActionsBuilding("healing", "nbrAllies");
};

TBSAiManager.prototype.updateSupportActionsBuilding = function () {
    this.updateActionsBuilding("support", "nbrAllies");
};

TBSAiManager.prototype.updateMoveActionsBuilding = function () {
    this.updateMoveActionsBuilding();
};

TBSAiManager.prototype.updateSummonActionsBuilding = function () {
    this.updateSummonActionsBuilding();
};

TBSAiManager.prototype.makeActionData = function (type, party, skills) {
    this._builtData[type] = null;
    this._actionBuilding[type] = {};
    this._actionBuilding[type].objects = skills;
    this._actionBuilding[type].data = [];
    var entity = this._entity;

    this._actionBuilding[type].party = LeUtilities.sortByClosestDistance(entity, party);
};

TBSAiManager.prototype.updateMoveActionsBuilding = function () {
    var object = this._actionBuilding["move"].objects.shift();
    var user = this._battler;
    var entity = this._entity;
    var center = entity.getCell().toCoords();
    var a = entity.battler();

    if (!object) {
        this.onActionBuildingEnd("move");
        return;
    }

    var data = object.id === user.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(object);
    var param = this.BM().makeObjScopeParam(object, entity, center);
    var scope = this.BM().getScopeFromData(data, center, param).filter(function (cell) {
        return cell._selectable;
    });
    if (scope.length === 0) return;
    var closestCellToEnemy = BattleManagerTBS.getCellTowardParty(scope, this.getEnemiesOf(this._battler, true));
    var farthestCellToEnemy = BattleManagerTBS.getCellAwayParty(scope, this.getEnemiesOf(this._battler, true));

    var action = {};
    action.type = "move";
    action.cellToMoveTo = entity.getCell();
    action.userCell = entity.getCell();
    action.cellTarget = null;
    action.obj = object;
    action.targets = [];
    action.nbrTargets = 0;
    var a = entity.battler();
    if (eval(object.TagsLetbsAi.escapeCondition)) {
        action.escapeCellTarget = farthestCellToEnemy;
        action.escapeDistance = LeUtilities.distanceBetween(center, farthestCellToEnemy);
    } else {
        action.escapeCellTarget = null;
        action.escapeDistance = 0;
    }
    if (eval(object.TagsLetbsAi.rushCondition)) {
        action.rushCellTarget = closestCellToEnemy;
        action.rushDistance = LeUtilities.distanceBetween(center, closestCellToEnemy);
    } else {
        action.rushCellTarget = null;
        action.rushDistance = 0;
    }
    this._actionBuilding["move"].data.push(action);
};

TBSAiManager.prototype.updateSummonActionsBuilding = function () {
    var object = this._actionBuilding["summon"].objects.shift();
    var user = this._battler;
    var entity = this._entity;
    var center = entity.getCell().toCoords();
    var a = entity.battler();

    if (!object) {
        this.onActionBuildingEnd("summon");
        return;
    }

    var data = object.id === user.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(object);
    var param = this.BM().makeObjScopeParam(object, entity, center);
    var scope = this.BM().getScopeFromData(data, center, param).filter(function (cell) {
        return cell._selectable;
    });
    if (scope.length === 0) return;
    var closestCellToEnemy = BattleManagerTBS.getCellTowardParty(scope, this.getEnemiesOf(this._battler, true));
    var closestCellToAlly = BattleManagerTBS.getCellTowardParty(scope, this.getAlliesOf(this._battler, true));
    var closestCellToCaster = BattleManagerTBS.getCellTowardParty(scope, [entity]);

    var action = {};
    action.type = "summon";
    action.cellToMoveTo = entity.getCell();
    action.userCell = entity.getCell();
    action.obj = object;
    action.targets = [];
    action.nbrTargets = 0;
    var summonNear = object.TagsLetbsAi.summonNear;
    switch (summonNear) {
        case "caster":
            action.cellTarget = closestCellToCaster;
            break;
        case "enemies":
            action.cellTarget = closestCellToEnemy;
            break;
        case "allies":
            action.cellTarget = closestCellToAlly;
            break;
    }
    this._actionBuilding["summon"].data.push(action);
};

TBSAiManager.prototype.updateActionsBuilding = function (type, nbrMembers) {
    var object = this._actionBuilding[type].objects.shift();
    var party = this._actionBuilding[type].party;
    var entity = this._entity;
    var center = entity.getCell().toCoords();
    var a = entity.battler();
    var opNbrMembers = nbrMembers === "nbrEnemies" ? "nbrAllies" : "nbrEnemies";

    if (!object) {
        this.onActionBuildingEnd(type);
        return;
    }

    //- Handle AOEs
    if (object.TagsLetbsAi.maximiseTargets) {
        var possibilities = this.getAoEPossibleMoves(entity, object, center)
            .sort(function (p1, p2) {
                return (p1[nbrMembers] > p2[nbrMembers]) ? -1 : ((p1[nbrMembers] < p2[nbrMembers]) ? 1 : 0);
            });
        if (possibilities.length === 0) return;
        //- If the best move sorted by number of members has only one member,
        //- discard the possibilities where an ally is also targeted (it won't make sens otherwise)
        //- OR simply avoid friendly fire based on the config %
        if (type === "offense" && possibilities[0][nbrMembers] === 1
            || Math.random() < object.TagsLetbsAi.avoidFriendlyFire) {
            possibilities = possibilities.filter(function (p) {
                return p[opNbrMembers] === 0;
            });
            if (possibilities.length === 0) return;
        }
        //- Keep possibilities with best nbr of members
        var best = possibilities[0][nbrMembers];
        possibilities = possibilities.filter(function (p) {
            return p[nbrMembers] === best;
        });
        //- Sort by average hpRate of the targets in the AOE
        if (possibilities.length > 1) {
            possibilities = possibilities.sort(function (p1, p2) {
                var avgHpRate1 = LeUtilities.avgOfArray(
                    p1.targets.map(function (ent) {
                        return ent.battler().hpRate();
                    }.bind(this))
                );
                var avgHpRate2 = LeUtilities.avgOfArray(
                    p2.targets.map(function (ent) {
                        return ent.battler().hpRate();
                    }.bind(this))
                );
                return avgHpRate1 - avgHpRate2;
            }.bind(this));
        }
        //- Keep possibilities with lowest hpRate
        best = LeUtilities.avgOfArray(
            possibilities[0].targets.map(function (ent) {
                return ent.battler().hpRate();
            }.bind(this))
        );
        possibilities = possibilities.filter(function (p) {
            var avgHpRate = LeUtilities.avgOfArray(
                p.targets.map(function (ent) {
                    return ent.battler().hpRate();
                }.bind(this))
            );
            return avgHpRate === best;
        }.bind(this));
        //- Sort by lowest requiredMp
        possibilities = possibilities.sort(function (p1, p2) {
            var req1 = LeUtilities.distanceBetweenCells(entity.getCell(), p1.moveCell);
            var req2 = LeUtilities.distanceBetweenCells(entity.getCell(), p2.moveCell);
            return req1 - req2;
        }.bind(this));

        //- Keep possibilities where at least one target matches the use condition
        possibilities = possibilities.filter(function (p) {
            for (var i = 0; i < p.targets.length; i++) {
                var target = p.targets[i];
                var b = target.battler();
                if (eval(object.TagsLetbsAi.useCondition))
                    return true;
            }
        });

        var move = possibilities[0];
        if (!move) return;
        var action = {};
        action.type = type;
        action.requiredMp = LeUtilities.distanceBetweenCells(entity.getCell(), move.moveCell);
        action.cellToMoveTo = move.moveCell;
        action.cellTarget = move.actionCell;
        action.userCell = entity.getCell();
        action.obj = object;
        action.targets = move.targets;
        action.nbrTargets = move[nbrMembers];
        this._actionBuilding[type].data.push(action);
    }
    //- If maximising targets isn't required (faster)
    else {
        for (var i = 0; i < party.length; i++) {
            var member = party[i];
            var b = member.battler();
            if (eval(object.TagsLetbsAi.useCondition)) {
                var cellToMoveTo = this.getCellToMoveToForAction(entity, member.getCell(), object, center);
                if (cellToMoveTo) {
                    var action = {};
                    action.type = type;
                    action.requiredMp = LeUtilities.distanceBetweenCells(entity.getCell(), cellToMoveTo);
                    action.cellToMoveTo = cellToMoveTo;
                    action.cellTarget = member.getCell();
                    action.userCell = entity.getCell();
                    action.obj = object;
                    action.targets = [member];
                    action.nbrTargets = 1;
                    this._actionBuilding[type].data.push(action);
                }
            }
        }
    }
};

TBSAiManager.prototype.onActionBuildingEnd = function (type) {
    this._builtData[type] = this._actionBuilding[type].data;
};

TBSAiManager.prototype.getClosestActionCellToTarget = function (cellTarget, obj, center) {
    var entity = this._entity;
    var data = obj.id === entity._battler.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(obj);
    var param = this.BM().makeObjScopeParam(obj, entity, center);
    var scope = this.BM().getScopeFromData(data, center, param);
    if (this.BM().isCellInScope(cellTarget, scope)) {
        return scope.filter(function (cell) {
            return cell.isSame(cellTarget);
        })[0];
    }
    var closestCell = LeUtilities.closestByDistance(cellTarget, scope);
    var oldActiveCell = BattleManagerTBS._activeCell;
    BattleManagerTBS._activeCell = closestCell; //- Support path scope

    var aoeData = obj.id === entity._battler.attackSkillId() ? entity.getAttackAoEData() : entity.getObjectAoEData(obj);
    var aoeCenter = closestCell.toCoords();
    param = this.BM().makeObjAoEParam(obj, entity, aoeCenter);
    var aoe = this.BM().getScopeFromData(aoeData, aoeCenter, param);
    var closestCellInAoE = LeUtilities.closestByDistance(cellTarget, aoe);
    BattleManagerTBS._activeCell = oldActiveCell;
    return closestCellInAoE;
};

TBSAiManager.prototype.getCellToMoveToForAction = function (entity, targetCell, obj, center) {
    var moveParam = this.BM().makeMoveScopeParam(entity);
    var moveData = entity.getMoveScopeData();
    var scope = this.BM().getScopeFromData(moveData, center, moveParam);

    var closestCell = this.getClosestActionCellToTarget(targetCell, obj, entity.getCell());
    var exactDistance = LeUtilities.distanceBetweenCells(closestCell, targetCell);

    scope = scope.filter(function (cell) {
        return cell._walkable && LeUtilities.distanceBetweenCells(cell, entity.getCell()) === exactDistance;
    }.bind(this));

    //- Sort by closest cell to the user
    var cellsToCheck = LeUtilities.sortByClosestDistance(entity.getCell(), scope);

    //- Add entity's current cell
    cellsToCheck = [entity.getCell()].concat(cellsToCheck);

    var cellToMoveTo = null;
    while (cellsToCheck.length > 0) {
        var cell = cellsToCheck.shift();
        var currentCenter = cell.toCoords();
        var oldCell = entity.getCell();
        entity.setCell(cell);
        //- This call sets the los BTW
        closestCell = this.getClosestActionCellToTarget(targetCell, obj, currentCenter);
        entity.setCell(oldCell);
        if (closestCell.isSame(targetCell) && closestCell._selectable) {
            cellToMoveTo = cell;
            break;
        }
    }
    return cellToMoveTo;
};

TBSAiManager.prototype.getAoEPossibleMoves = function (entity, obj, center) {
    var possibilities = [];
    var scope = this.BM().makeMoveScope(entity, true).cells;
    scope = scope.filter(function (cell) {
        return cell._walkable;
    }.bind(this));
    var moveScope = [entity.getCell()].concat(scope);

    while (moveScope.length > 0) {
        var moveCell = moveScope.shift();
        var currentCenter = moveCell.toCoords();
        var oldCell = entity.getCell();
        entity.setCell(moveCell);

        var data = obj.id === entity._battler.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(obj);
        var actionScope = this.BM().makeActionScope(entity, data, obj, true)
            .cells
            .filter(function (cell) {
                return !(!cell._selectable || (cell.isObstacleForLOS() && !cell.isThereEntity()));
            });
        while (actionScope.length > 0) {
            var actionCell = actionScope.shift();
            var aoeData = obj.id === entity._battler.attackSkillId() ? entity.getAttackAoEData() : entity.getObjectAoEData(obj);
            var aoeCenter = actionCell.toCoords();
            var param = this.BM().makeObjAoEParam(obj, entity, aoeCenter);
            var aoe = this.BM().getScopeFromData(aoeData, aoeCenter, param);
            var entities = this.BM().getEntitiesInScope(aoe).filter(function (ent) {
                var b = ent.battler();
                var e = ent;
                return eval(obj.TagsLetbsAi.useCondition);
            });
            var nbrAllies = entities.filter(function (ent) {
                return this.isAlly(ent);
            }.bind(this)).length;
            var nbrEnemies = entities.filter(function (ent) {
                return this.isEnemy(ent);
            }.bind(this)).length;
            if (nbrAllies > 0 || nbrEnemies > 0) {
                possibilities.push({
                    moveCell: moveCell,
                    actionCell: actionCell,
                    nbrAllies: nbrAllies,
                    nbrEnemies: nbrEnemies,
                    targets: entities
                });
            }
        }
        entity.setCell(oldCell);
    }
    return possibilities;
};

TBSAiManager.prototype.getBehavior = function () {
    var behavior = this._aiOptions.behavior;
    if (behavior)
        return Lecode.S_TBS.Config.AI[behavior];
    return Lecode.S_TBS.Config.AI["default"];
};

TBSAiManager.prototype.currentCommand = function () {
    return this._commands[this._phase];
};

TBSAiManager.prototype.nextCommand = function () {
    this._phase++;
    this._commandRunning = null;
    this._commandPhase = "init";
    this._commandNextPhaseCallBack = null;
    this._commandExtraData = {};
};

TBSAiManager.prototype.areConditionsOkay = function () {
    if (this._ifArray.length === 0) return true;
    return !!this._ifArray[this._ifArray.length - 1];
};

TBSAiManager.prototype.update = function () {
    if (this._isBuilding && this.updateActionConstruction())
        return;
    if (this._commandRunning) {
        this.updateRunningCommand();
        return;
    }
    var command = this.currentCommand();
    if (command) {
        this.runCommand(command);
    } else
        this.forceEnd();
};

TBSAiManager.prototype.updateActionConstruction = function () {
    if (this._constructionDelay < Lecode.S_TBS.aiProcessDelay) {
        this._constructionDelay++;
        return true;
    }
    this._constructionDelay = 0;
    if (!this._builtData["offense"]) {
        this.updateOffenseActionsBuilding();
        return true;
    } else if (!this._builtData["healing"]) {
        this.updateHealingActionsBuilding();
        return true;
    } else if (!this._builtData["support"]) {
        this.updateSupportActionsBuilding();
        return true;
    } else if (!this._builtData["move"]) {
        this.updateMoveActionsBuilding();
        return true;
    } else if (!this._builtData["summon"]) {
        this.updateSummonActionsBuilding();
        return true;
    }
    this._isBuilding = false;
    return false;
};

TBSAiManager.prototype.forceEnd = function () {
    if (this._aiOptions) {
        var callback = this._aiOptions.endCallback;
        if (callback) {
            callback();
            return;
        }
    }
    this.BM().processCommandPass();
};

TBSAiManager.prototype.runCommand = function (command) {
    if (command === "else") {
        this.commandElse();
        this.nextCommand();
        return;
    } else if (command === "endif") {
        this.commandEndIf();
        this.nextCommand();
        return;
    } else if (command === "process_behaviors") {
        this.processBehaviors();
        this.nextCommand();
        return;
    } else if (command === "process_requested_action") {
        this.processRequestedAction();
        this.nextCommand();
        return;
    } else if (command === "force_end") {
        this.forceEnd();
        return;
    }

    if (!command.match(/(.+)\s?:\s?(.+)/i)) {
        this.nextCommand();
        return;
    }

    var main = String(RegExp.$1).trim();
    var paramStr = String(RegExp.$2).trim();
    var param = LeUtilities.stringSplit(paramStr, ",");
    param.forEach(function (p) {
        p = p.trim().replace(" ", "");
    }.bind(this));

    if (main === "if") {
        this.commandIf(paramStr);
        this.nextCommand();
        return;
    }

    if (this.areConditionsOkay()) {
        var functionName = LeUtilities.shrinkTextWithUnderscores(main);
        var func = eval("this.command" + functionName + ".bind(this,param)");
        func();
        this._commandRunning = main;
    } else {
        this.nextCommand();
    }
};

TBSAiManager.prototype.commandIf = function (condition) {
    var user = this._battler;
    var entity = this._entity;
    var canUseOffense = this.func_CanUseOffense.bind(this);
    var canUseHealing = this.func_CanUseHealing.bind(this);
    var canUseSupport = this.func_CanUseSupport.bind(this);
    var canUseEscape = this.func_CanUseEscape.bind(this);
    var canUseRush = this.func_CanUseRush.bind(this);
    var isTargetValid = this.func_IsTargetValid.bind(this);
    var chance = this.func_Chance.bind(this);
    var failureCode = this.func_FailureCode.bind(this);
    var battlerInRange = this.func_BattlerInRange.bind(this);
    var distanceBetween = this.func_DistanceBetween.bind(this);
    var distanceToEnemies = this.func_DistanceToEnemies.bind(this);
    var distanceToAllies = this.func_DistanceToAllies.bind(this);
    var isInMeleeWith = this.func_IsInMeleeWith.bind(this);
    var isInMelee = this.func_IsInMelee.bind(this);
    var pattern = function (str) {
        return this.func_GetPattern() === str;
    }.bind(this);
    var result = eval(condition);
    this._ifArray.push(result);
};

TBSAiManager.prototype.commandElse = function () {
    this._ifArray[this._ifArray.length - 1] = !this._ifArray.leU_last();
};

TBSAiManager.prototype.commandEndIf = function () {
    this._ifArray.pop();
};

TBSAiManager.prototype.processBehaviors = function () {
    if (!this._battler.canMove()) {
        return;
    }

    if (this._battler.isConfused()) {
        if (this.func_CanUseOffense())
            this.commandCallBehavior(["use_offense"]);
        return;
    }

    var order = Lecode.S_TBS.Config.AI.BehaviorsOrder;
    for (var i = 0; i < order.length; i++) {
        var tag = order[i];
        if (tag === "healing" && this.func_CanUseHealing()) {
            this.commandCallBehavior(["use_healing"]);
            break;
        } else if (tag === "escape" && this.func_CanUseEscape()) {
            this._entity._aiEscapeCount = Lecode.S_TBS.escapeCooldown + 1;
            this.commandCallBehavior(["escape"]);
            break;
        } else if (tag === "summon" && this.func_CanUseSummon()) {
            this._entity._aiSupportCount = Lecode.S_TBS.supportCooldown + 1;
            this.commandCallBehavior(["use_summon"]);
            break;
        } else if (tag === "support" && this.func_CanUseSupport()) {
            this.commandCallBehavior(["use_support"]);
            break;
        } else if (tag === "offense") {
            if (this.func_CanUseOffense())
                this.commandCallBehavior(["use_offense"]);
            else
                this.commandCallBehavior(["cant_use_offense"]);
            break;
        }
    }
};

TBSAiManager.prototype.processRequestedAction = function () {
    var type = this._aiOptions.behaviorType;
    var requestedTarget = this._aiOptions.entityTarget;

    //- Determine the target data for the requested action
    this._targetData = {};
    if (requestedTarget) {
        this._targetData.entity = requestedTarget;
    } else {
        if (type === "offense") {
            this.commandSearchTarget(["lowest_enemy", "100%", type]);
            if (!this._targetData)
                this.commandSearchTarget(["closest_enemy", "100%", type]);
        } else if (type === "healing") {
            this.commandSearchTarget(["self", "100%", type]);
            if (!this._targetData)
                this.commandSearchTarget(["lowest_ally", "100%", type]);
            if (!this._targetData)
                this.commandSearchTarget(["closest_ally", "100%", type]);
        } else if (type === "support") {
            this.commandSearchTarget(["lowest_ally", "100%", type]);
            if (!this._targetData)
                this.commandSearchTarget(["self", "100%", type]);
            if (!this._targetData)
                this.commandSearchTarget(["closest_ally", "100%", type]);
        }
        if (!this.func_IsTargetValid()) {
            Lecode.S_TBS.CommandSuccess = false;
            return;
        }
    }
    this.commandSetAction([type, "average"]);
    var commands = [
        "move_for_action: -",
        "use: defined_action"
    ];
    commands.reverse();
    for (var i = 0; i < commands.length; i++) {
        this._commands.splice(this._phase + 1, 0, commands[i]);
    }
};

TBSAiManager.prototype.commandWait = function (param) {
    var value = Number(param[0]);
    this.BM().wait(value);
};

TBSAiManager.prototype.commandCallBehavior = function (param) {
    var id = param[0].trim();
    var commands = Lecode.S_TBS.Config.AI[id].slice();
    commands.reverse();
    for (var i = 0; i < commands.length; i++) {
        this._commands.splice(this._phase + 1, 0, commands[i]);
    }
};

TBSAiManager.prototype.commandSetActionData = function (param) {
    var id = param[0].trim();
    this._actionDataType = this._builtData[id];
};

TBSAiManager.prototype.commandSearchTarget = function (param) {
    var search = param[0];
    var maxPm = param[1];
    var dataScope = param[2];

    this.commandSetActionData([dataScope]);
    if (maxPm.match(/(.+)%/i))
        maxPm = Number(RegExp.$1) * 0.01 * this._entity.getMovePoints();
    else
        maxPm = Number(maxPm);
    maxPm = Math.floor(maxPm);
    if (LeUtilities.isNumeric(maxPm)) {
        maxPm = Math.floor(maxPm);
        if (maxPm < 1)
            maxPm = 1;
        if (maxPm > this._entity.getMovePoints())
            maxPm = this._entity.getMovePoints();
    }

    var group = this.getGroupFromActionData(maxPm);

    var focusedEntities = this.getFocusedEntities(group, dataScope);
    if (focusedEntities.length > 0) {
        var entity = focusedEntities[0];
        this._targetData = {};
        this._targetData.entity = entity;
        return;
    }

    if (search.match(/self/i)) {
        group = group.filter(function (entity) {
            return entity === this._entity;
        });
    } else if (search.match(/enemy/i)) {
        group = group.filter(function (entity) {
            return this.isEnemy(entity);
        }.bind(this));
    } else if (search.match(/ally/i)) {
        group = group.filter(function (entity) {
            return this.isAlly(entity);
        }.bind(this));
    }

    if (search.match(/lowest/i)) {
        group = group.sort(function (a, b) {
            a = a._battler;
            b = b._battler;
            return (a.hpRate() > b.hpRate()) ? 1 : ((a.hpRate() < b.hpRate()) ? -1 : 0);
        });
    } else if (search.match(/closest/i)) {
        group = LeUtilities.sortByClosestDistance(this._entity, group);
    }

    this._targetData = null;
    if (!group || group.length === 0)
        return;

    //- Group is sorted so group[0] is the best match
    this._targetData = {};
    this._targetData.entity = group[0];
};

TBSAiManager.prototype.commandDrawMoveScope = function (param) {
    this.BM().drawMoveScope(this._entity);
};

TBSAiManager.prototype.commandMove = function (param) {
    var search = param[0];
    var maxPm = param[1];

    if (!this._entity.canMoveCommand()) return;

    if (maxPm.match(/(.+)%/i))
        maxPm = Number(RegExp.$1) * 0.01 * this._entity.getMovePoints();
    else if (maxPm.match(/minimum/i))
        maxPm = this._actionData.requiredMp; //"minimum";
    else
        maxPm = Number(maxPm);
    if (LeUtilities.isNumeric(maxPm)) {
        maxPm = Math.floor(maxPm);
        if (maxPm < 1)
            maxPm = 1;
        if (maxPm > this._entity.getMovePoints())
            maxPm = this._entity.getMovePoints();
    }

    if (Lecode.S_TBS.showScopes) {
        this.commandDrawMoveScope();
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    } else {
        this.BM().makeMoveScope(this._entity);
    }

    this._commandPhase = "move_scope_wait";
    this._commandNextPhaseCallBack = this.commandMoveP2.bind(this, param, search, maxPm);
};

TBSAiManager.prototype.commandMoveP2 = function (param, search, maxPm) {
    var cellTarget;
    var focusedEntities;
    if (search.match(/toward_target/i))
        cellTarget = this._targetData.cellTarget; //- TODO: WRONG
    else if (search.match(/enemies/i)) {
        focusedEntities = this.getFocusedEntities(this.getEnemiesOf(this._battler, true), "offense");
        if (search.match(/toward/i) && focusedEntities.length > 0)
            cellTarget = focusedEntities[0].getCell();
        else
            cellTarget = LeUtilities.closestByDistance(this._entity, this.getEnemiesOf(this._battler, true)).getCell();
    } else if (search.match(/allies/i)) {
        focusedEntities = this.getFocusedEntities(this.getEnemiesOf(this._battler, true), "healing");
        if (focusedEntities.length === 0)
            focusedEntities = this.getFocusedEntities(this.getEnemiesOf(this._battler, true), "support");
        if (search.match(/toward/i) && focusedEntities.length > 0)
            cellTarget = focusedEntities[0].getCell();
        else
            cellTarget = LeUtilities.closestByDistance(this._entity, this.getAlliesOf(this._battler, true)).getCell();
    }

    /*if (maxPm === "minimum") {
        maxPm = this._actionData.requiredMp;
    }*/

    var scope = this.BM().moveScope().cells;
    scope = scope.filter(function (cell) {
        return cell._walkable && LeUtilities.distanceBetweenCells(cell, this._entity.getCell()) <= maxPm;
    }.bind(this));

    var destCell;
    if (search.match(/toward/i))
        destCell = this.BM().closestWalkableCellTo(cellTarget, scope);
    else
        destCell = this.BM().farthestWalkableCellTo(cellTarget, scope);

    this.BM().setCursorCell(destCell);
    if (!this.BM().movePath() || this.BM().movePath().length === 0) {
        this.nextCommand();
        return;
    }

    if (Lecode.S_TBS.showScopes) {
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    }

    this._commandPhase = "move_selection_wait";
    this._commandNextPhaseCallBack = this.commandMoveP3.bind(this);
    this._commandExtraData.destCell = destCell;
    this._commandExtraData.savedParams = param.slice();
};

TBSAiManager.prototype.commandMoveP3 = function () {
    BattleManagerTBS.centerCell(this._entity.getCell());
    this._entity.processMovement(this.BM().movePath());
    this._commandPhase = "moving";
};

TBSAiManager.prototype.commandMoveForAction = function (param) {
    var cellToMoveTo = this._actionData.cellToMoveTo;
    if (cellToMoveTo.isSame(this._entity.getCell())) {
        return;
    }

    if (!this._entity.canMoveCommand()) return;

    if (Lecode.S_TBS.showScopes) {
        this.commandDrawMoveScope();
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    } else {
        this.BM().makeMoveScope(this._entity);
    }

    this._commandPhase = "move_scope_wait";
    this._commandNextPhaseCallBack = this.commandMoveForActionP2.bind(this, param);
};

TBSAiManager.prototype.commandMoveForActionP2 = function (param) {
    var cellToMoveTo = this._actionData.cellToMoveTo;

    this.BM().setCursorCell(cellToMoveTo);
    if (Lecode.S_TBS.showScopes) {
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    }

    this._commandPhase = "move_selection_wait";
    this._commandNextPhaseCallBack = this.commandMoveP3.bind(this);
    this._commandExtraData.destCell = cellToMoveTo;
    this._commandExtraData.savedParams = param;
};

TBSAiManager.prototype.commandSetAction = function (param) {
    var type = param[0];
    var priority = param[1];
    var possibilities = [];
    var data;

    //- Special case for move type actions
    if (type.match(/move/i)) {
        data = this._builtData["move"];
        var action, cellType;
        if (priority.match(/toward/i)) {
            action = data.sort(function (data1, data2) {
                var value1 = data1.rushCellDistance;
                var value2 = data2.rushCellDistance;
                return (value1 < value2) ? 1 : ((value1 > value2) ? -1 : 0);
            }.bind(this))[0];
            cellType = action.rushCellTarget;
        } else {
            action = data.sort(function (data1, data2) {
                var value1 = data1.escapeCellDistance;
                var value2 = data2.escapeCellDistance;
                return (value1 < value2) ? 1 : ((value1 > value2) ? -1 : 0);
            }.bind(this))[0];
            cellType = action.escapeCellTarget;
        }
        this._actionData = action;
        this._actionData.cellTarget = cellType;
        return;
    }

    //- Special case for summon type actions
    if (type.match(/summon/i)) {
        data = this._builtData["summon"];
        this._actionData = LeUtilities.getRandomValueInArray(data);
        return;
    }

    var searchedEntity = this._targetData.entity;

    if (type.match(/damage/i) || type.match(/offense/i)) {
        data = this._builtData["offense"];
    } else if (type.match(/healing/i)) {
        data = this._builtData["healing"];
    } else if (type.match(/support/i)) {
        data = this._builtData["support"];
    }
    for (var i = 0; i < data.length; i++) {
        var action = data[i];
        if (action.targets.indexOf(searchedEntity) >= 0) {
            possibilities.push(action);
        }
    }
    possibilities = possibilities.sort(function (data1, data2) {
        var value1 = data1.nbrTargets;
        var value2 = data2.nbrTargets;
        return (value1 < value2) ? 1 : ((value1 > value2) ? -1 : 0);
    }.bind(this));
    var bestNbrTargets = possibilities[0].nbrTargets;
    //- Only keep possibilities with the best nbr of targets with 80% of chance
    if (Math.random() < 0.8) {
        possibilities = possibilities.filter(function (p) {
            return p.nbrTargets === bestNbrTargets;
        });
    }
    if (type.match(/healing/i))
        possibilities = this.sortActionsByDmg(possibilities).reverse();
    else if (type.match(/damage/i))
        possibilities = this.sortActionsByDmg(possibilities);

    var action = null;
    if (priority.match(/average/i)) {
        var array = [];
        for (var i = 0; i < possibilities.length; i++) {
            var p = possibilities[i];
            var obj = p.obj;
            for (var j = 0; j < (obj._leTbsRating || 1); j++)
                array.push(p);
        }
        action = LeUtilities.getRandomValueInArray(array);
    } else if (priority.match(/best/i)) {
        action = possibilities[0];
    } else {
        action = possibilities.leU_last();
    }

    this._actionData = action;
};

TBSAiManager.prototype.sortActionsByDmg = function (actionsData) {
    return actionsData.sort(function (data1, data2) {
        var obj1 = data1.obj;
        var obj2 = data2.obj;
        var dummyAction1 = new TBS_FloatingAction(this._battler, false);
        dummyAction1.setItemObject(obj1);
        var dummyAction2 = new TBS_FloatingAction(this._battler, false);
        dummyAction2.setItemObject(obj2);
        var value1 = dummyAction1.evaluate();
        var value2 = dummyAction2.evaluate();
        return (value1 < value2) ? 1 : ((value1 > value2) ? -1 : 0);
    }.bind(this));
};

TBSAiManager.prototype.commandUse = function (param) {
    var info = param[0];

    if (!this._entity.canObjCommand()) return;

    var obj;
    if (info.match(/defined_action/i))
        obj = this._actionData.obj;

    if (obj) {
        this.BM().activeAction().setItemObject(obj);
        if (this.BM().activeAction().isAttack()) {
            if (Lecode.S_TBS.showScopes)
                this.BM().drawAttackScope(this._entity);
            else
                this.BM().makeAttackScope(this._entity);
        } else {
            if (Lecode.S_TBS.showScopes)
                this.BM().drawSkillScope(this._entity, obj);
            else
                this.BM().makeSkillScope(this._entity, obj);
        }

        if (Lecode.S_TBS.showScopes) {
            var wait = Lecode.S_TBS.aiWaitTime;
            this.BM().wait(wait);
        }

        this._commandPhase = "obj_scope_wait";
        this._commandNextPhaseCallBack = this.commandUseP2.bind(this, obj);
    }
};

TBSAiManager.prototype.commandUseP2 = function (obj) {
    var cellTarget = this._actionData.cellTarget;
    var center = this._entity.getCell().toCoords();
    var cell = this.getClosestActionCellToTarget(cellTarget, obj, center);

    this.BM().setCursorCell(cell);
    //this.BM().updateActionSelection();
    this._entity.lookAt(cell);
    if (Lecode.S_TBS.showScopes) {
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    }

    this._commandPhase = "obj_selection_wait";
    this._commandNextPhaseCallBack = this.commandUseP3.bind(this, obj);
};

TBSAiManager.prototype.commandUseP3 = function (obj) {
    this.BM().getLayer("scopes").clear();
    this.BM().clearActionSelection();
    this.BM().processAction();
    BattleManagerTBS._subPhase = "ai";
    this._commandPhase = "action_start";
};

TBSAiManager.prototype.commandPass = function (param) {
    var look = param[0];
    switch (look) {
        case "look_closest_enemy":
            this._entity.lookClosestBattler(this.getEnemiesOf(this._battler, true));
            break;
        case "look_closest_ally":
            this._entity.lookClosestBattler(this.getAlliesOf(this._battler, true));
            break;
    }
    this.forceEnd();
};

TBSAiManager.prototype.commandScript = function (param) {
    var script = param[0];
    eval(script);
};

TBSAiManager.prototype.getFocusedEntities = function (group, type) {
    var focusData = [];
    group.forEach(function (entity) {
        var priority = entity.isFocusedByAI(type);
        if (priority)
            focusData.push({ entity: entity, priority: priority });
    });
    return focusData.sort(function (da, db) {
        return db.priority - da.priority;
    }).map(function (data) {
        return data.entity;
    });
};

TBSAiManager.prototype.updateRunningCommand = function () {
    var functionName = LeUtilities.shrinkTextWithUnderscores(this._commandRunning);
    var func = eval("this.updateCommand" + functionName);
    if (func) {
        func.call(this);
    } else {
        this.nextCommand();
    }
};

TBSAiManager.prototype.onMoveInterrupted = function () {
    this.process(this._entity, this._aiOptions);
};

TBSAiManager.prototype.updateCommandWait = function () {
    if (!this.BM().isWaiting())
        this.nextCommand();
};

TBSAiManager.prototype.updateCommandMove = function () {
    var phase = this._commandPhase;
    switch (phase) {
        case "move_scope_wait":
        case "move_selection_wait":
            if (!this.BM().isWaiting())
                this._commandNextPhaseCallBack();
            break;
        case "moving":
            if (!this._entity.isMoving()) {
                this.BM().onActiveEntityMoveEnd();
                this.BM()._subPhase = "ai";
                if (this._entity.getCell() === this._commandExtraData.destCell)
                    this.nextCommand();
                else {
                    if (this._entity.canMoveCommand())
                        this.commandMove(this._commandExtraData.savedParams);
                    else
                        this.onMoveInterrupted();
                }
            }
            break;
        default:
            this.nextCommand();
            break;
    }
};

TBSAiManager.prototype.updateCommandMoveForAction = function () {
    var phase = this._commandPhase;
    switch (phase) {
        case "move_scope_wait":
        case "move_selection_wait":
            if (!this.BM().isWaiting())
                this._commandNextPhaseCallBack();
            break;
        case "moving":
            if (!this._entity.isMoving()) {
                this.BM().onActiveEntityMoveEnd();
                this.BM()._subPhase = "ai";
                if (this._entity.getCell() === this._commandExtraData.destCell)
                    this.nextCommand();
                else {
                    if (this._entity.canMoveCommand())
                        this.commandMoveForAction();
                    else
                        this.onMoveInterrupted();
                }
            }
            break;
        default:
            this.nextCommand();
            break;
    }
};

TBSAiManager.prototype.updateCommandUse = function () {
    var phase = this._commandPhase;
    switch (phase) {
        case "obj_scope_wait":
        case "obj_selection_wait":
            if (!this.BM().isWaiting())
                this._commandNextPhaseCallBack();
            break;
        case "action_start":
            this.BM().executeAction();
            this.BM()._subPhase = "ai";
            this._commandPhase = "invoking";
            break;
        case "invoking":
            if (!this.BM().anySequenceRunning()) {
                if (!Lecode.S_TBS.requestedAction)
                    this.BM().onActionEnd();
                else {
                    this.BM().onRequestedActionEnd(this._entity);
                }
                this.BM()._subPhase = "ai";
                this.nextCommand();
            }
            break;
        default:
            this.nextCommand();
            break;
    }
};

TBSAiManager.prototype.BM = function () {
    return BattleManagerTBS;
};

TBSAiManager.prototype.func_Chance = function (value) {
    return Math.random() < value * 0.01;
};

TBSAiManager.prototype.func_IsTargetValid = function () {
    return this._targetData != null;
};

TBSAiManager.prototype.func_FailureCode = function () {
    console.log("Code: ", this._failureCode);
    return this._failureCode;
};

TBSAiManager.prototype.func_CanUseOffense = function () {
    //this._failureCode = "";
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["offense"].length <= 0) {
        this._failureCode = "out_of_range";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseHealing = function () {
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["healing"].length <= 0) {
        this._failureCode = "unable_to_heal";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseSupport = function () {
    if (this._entity._aiSupportCount === 0) return false;
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["support"].length <= 0) {
        this._failureCode = "unable_to_use_support";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseSummon = function () {
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["summon"].length <= 0) {
        this._failureCode = "unable_to_use_summon";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseEscape = function () {
    if (this._entity._aiEscapeCount === 0) return false;
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["move"].filter(function (action) {
        return !!action.escapeCellTarget;
    }).length <= 0) {
        this._failureCode = "unable_to_escape_w_skill";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseRush = function () {
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["move"].filter(function (action) {
        return !!action.rushCellTarget;
    }).length <= 0) {
        this._failureCode = "unable_to_rush_w_skill";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_ReadTarget = function (target) {
    if (target.match(/defined_target/i)) {
        if (this._actionData)
            return this._actionData.cellTarget;
    }
    return null;
};

TBSAiManager.prototype.func_ReadAction = function (action) {
    if (action.match(/defined_action/i)) {
        if (this._actionData)
            return this._actionData.obj;
    }
    return null;
};

TBSAiManager.prototype.func_BattlerInRange = function (target, action) {
    var cellTarget = this.func_ReadTarget(target);
    var obj = this.func_ReadAction(action);

    if (!cellTarget || !!obj) return false;

    var data = (obj.id === this._battler.attackSkillId()) ? this._entity.getAttackScopeData() : this._entity.getObjectScopeData(obj);
    var center = this._entity.getCell().toCoords();
    var param = this.BM().makeObjScopeParam(obj, this._entity, center);
    var scope = this.BM().getScopeFromData(data, center, param);
    for (var i = 0; i < scope.length; i++) {
        var cell = scope[i];
        if (cellTarget.isSame(cell)) {
            return true;
        }
    }
    return false;
};

TBSAiManager.prototype.func_DistanceBetween = function (target) {
    var cellTarget = this.func_ReadTarget(target);
    if (!cellTarget) return 999;
    return LeUtilities.distanceBetweenCells(cellTarget, this._entity.getCell());
};

TBSAiManager.prototype.func_DistanceToEnemies = function () {
    var scope = this.BM().makeMoveScope(this._entity, true).cells;
    scope = scope.filter(function (cell) {
        return cell._walkable;
    }.bind(this));
    if (scope.length === 0)
        scope = [this._entity.getCell()];
    var cell = BattleManagerTBS.getCellTowardParty(scope, this.getEnemiesOf(this._battler, true));
    var result = LeUtilities.distanceBetweenCells(cell, this._entity.getCell());
    return result;
};

TBSAiManager.prototype.func_DistanceToAllies = function () {
    var scope = this.BM().makeMoveScope(this._entity, true).cells;
    scope = scope.filter(function (cell) {
        return cell._walkable;
    }.bind(this));
    if (scope.length === 0)
        scope = [this._entity.getCell()];
    var cell = BattleManagerTBS.getCellTowardParty(scope, this.getAlliesOf(this._battler, true));
    return LeUtilities.distanceBetweenCells(cell, this._entity.getCell());
};

TBSAiManager.prototype.func_IsInMeleeWith = function (target) {
    var cellTarget = this.func_ReadTarget(target);
    if (!cellTarget) return false;
    target = cellTarget.getEntity();
    if (!target) return false;
    if (target.isNonActiveSummon()) return false;
    return LeUtilities.distanceBetweenCells(cellTarget, this._entity.getCell()) <= 1;
};

TBSAiManager.prototype.func_IsInMelee = function () {
    return this.func_DistanceToEnemies() <= 1;
};

TBSAiManager.prototype.func_GetPattern = function () {
    return this._entity.getAiPattern();
};

TBSAiManager.prototype.getEnemiesOf = function (battler, needAlive) {
    if (battler.hasConfusionStateAttackAlly())
        return this.getAlliesOf(battler, needAlive);
    if (battler.hasConfusionStateAttackAnyone() && Math.randomInt(2) === 0)
        return this.getAlliesOf(battler, needAlive);
    var group = battler.isActor() ? this.BM().enemyEntities() : this.BM().allyEntities();
    if (needAlive) {
        return group.filter(function (ent) {
            return !ent.battler().isDead();
        });
    } else {
        return group;
    }
};

TBSAiManager.prototype.getAlliesOf = function (battler, needAlive) {
    if (battler.hasConfusionStateAttackEnemy())
        return this.getEnemiesOf(battler, needAlive);
    if (battler.hasConfusionStateAttackAnyone() && Math.randomInt(2) === 0)
        return this.getEnemiesOf(battler, needAlive);
    var group = battler.isEnemy() ? this.BM().enemyEntities() : this.BM().allyEntities();
    if (needAlive) {
        return group.filter(function (ent) {
            return !ent.battler().isDead();
        });
    } else {
        return group;
    }
};

TBSAiManager.prototype.isAlly = function (entity) {
    if (entity.isSummon()) return entity._summonData.caster.battler().isActor() === this._battler.isActor();
    return this._battler.isActor() === entity.battler().isActor();
};

TBSAiManager.prototype.isEnemy = function (entity) {
    return !this.isAlly(entity);
};

TBSAiManager.prototype.getUsableSkills = function (user) {
    var item = this._aiOptions.item;
    if (item) {
        return [item];
    }
    if (user.isActor()) {
        return user.usableSkills().concat($dataSkills[user.attackSkillId()]);
    }
    var actionList = user.enemy().actions.filter(function (a) {
        return user.isActionValid(a);
    });
    var skills = [];
    for (var i = 0; i < actionList.length; i++) {
        var action = actionList[i];
        var skill = $dataSkills[action.skillId];
        if (user.canUse(skill)) {
            skill._leTbsRating = action.rating;
            skills.push(skill);
        }
    }
    return skills;
};

TBSAiManager.prototype.getGroupFromActionData = function (maxPm) {
    var group = [];
    var data = this._actionDataType;
    for (var i = 0; i < data.length; i++) {
        if (data[i].requiredMp <= maxPm) {
            for (var j = 0; j < data[i].targets.length; j++) {
                var target = data[i].targets[j];
                if (!target._battler.isDead())
                    group.push(target);
            }
        }
    }
    return group;
};


/*-------------------------------------------------------------------------
* Sequence Manager
-------------------------------------------------------------------------*/
function TBSSequenceManager() {
    this.initialize.call(this, arguments);
}

TBSSequenceManager.prototype.initialize = function () {
    //this._sequence = null;
    this._sequence = {
        name: "",
        table: []
    };
    this._command = {
        instruction: "",
        waitWhile: function () { return false; },
        update: function () { },
        onEnd: function () { }
    };
    this._users = [];
    this._lastBattlerTargets = [];
    this._lastCellTargets = [];
    this._savedEntities = {};
    this._savedCells = {};
    this._sequenceQueue = [];
    this._obj = null;
    this._affectedTargets = [];
};

TBSSequenceManager.prototype.start = function (sequenceId, user, action) {
    var sequence = user.overloadedSequence(sequenceId);
    this._sequence = {
        name: sequenceId,
        table: this.parseSequence(sequence).slice(),
        started: true
    };
    this._users = [user];
    this._affectedTargets = [];
    this._action = action;
    if (action)
        this._obj = action.item();
    this._ifArray = [];
};

TBSSequenceManager.prototype.startWithData = function (sequence, user) {
    this._sequence = {
        name: "<improvised>",
        table: sequence,
        started: true
    };
    this._users = [user];
    this._affectedTargets = [];
    this._ifArray = [];
};

TBSSequenceManager.prototype.append = function (sequence, user, action) {
    this._sequenceQueue.push([sequence, user, action]);
};

TBSSequenceManager.prototype.unshift = function (sequence, user, action) {
    this._sequenceQueue.unshift([sequence, user, action]);
};

TBSSequenceManager.prototype.getUser = function () {
    return this._users.leU_last();
};

TBSSequenceManager.prototype.getObj = function () {
    return this._obj;
};

TBSSequenceManager.prototype.parseSequence = function (id) {
    if (id instanceof Array) return id;
    if (id.match(/\((.+)\)/i)) {
        var args = RegExp.$1.split(",");
        id = id.replace(/\(.+\)/i, "");
        var sequence = Lecode.S_TBS.Config.Sequences[id].slice();
        for (var i = 0; i < sequence.length; i++) {
            var line = sequence[i];
            for (var j = 0; j < args.length; j++) {
                var arg = args[j];
                sequence[i] = line.replace("$" + String(j + 1), arg);
            }
        }
        return sequence;
    }
    return Lecode.S_TBS.Config.Sequences[id];
};

TBSSequenceManager.prototype.update = function () {
    if (!this.isRunning()) return;
    this._command.update();
    var canContinue = !this._command.waitWhile();
    if (canContinue) {
        this._command.onEnd();
        //this._index++;
    } else {
        return;
    }
    var command = this._sequence.table.shift();
    if (command) {
        this.runCommand(command);
    } else
        this.endOfSequence();
};

TBSSequenceManager.prototype.runCommand = function (command) {
    if (command.match(/if\s?\:\s?(.+)/i)) {
        this.runIfCommand(RegExp.$1);
        return;
    } else if (command.trim() === "else") {
        this.runElseCommand();
        return;
    } else if (command.trim() === "end_if") {
        this.runEndIfCommand();
        return;
    } else if (command.match(/for_each\s?\:\s?(.+)/i)) {
        this.runForEachCommand(RegExp.$1);
        return;
    } else if (command.trim() === "end_for") {
        this.runEndForCommand();
        return;
    } else if (command.match(/(.+)\s?:\s?(.+)/i)) {

        if (this.areConditionsOkay()) {
            var main = String(RegExp.$1).trim();
            var param = LeUtilities.stringSplit(String(RegExp.$2).trim(), ",");

            //- Making parameters
            for (var i = 0; i < param.length; i++) {
                var line = param[i].trim();
                if (line.match(/\[(.+)\]/i)) {
                    var str = RegExp.$1;
                    if (str.match(/(.+)\.tag\.(.+)/i)) {
                        var obj;
                        switch (RegExp.$1) {
                            case "obj": obj = this.getObj(); break;
                            default: break;
                        }
                        if (obj)
                            line = obj._TagsLetbs[RegExp.$2];
                    }
                }
                param[i] = line;
            }

            var functionName = LeUtilities.shrinkTextWithUnderscores(main);
            var func = function () { };
            try {
                func = eval("this.command" + functionName + ".bind(this,param)");
            } catch (e) {
                console.log("[LeTBS]Can't find command \"", functionName);
                console.log(e);
            }
            var result = func();
            var requireWait = result.requestWait;
            if (result) {
                if (requireWait)
                    this._command.waitWhile = result.waitWhile || function () { return false; };
                else {
                    this._command.waitWhile = function () { return false; };
                }
                this._command.update = result.update || function () { };
                this._command.onEnd = result.onEnd || function () { };
            }
        }
    }
};

TBSSequenceManager.prototype.runIfCommand = function (condition) {
    var result = BattleManagerTBS.evaluateSequenceConditions(this, condition);
    this._ifArray.push(result);
};

TBSSequenceManager.prototype.runElseCommand = function () {
    this._ifArray[this._ifArray.length - 1] = !this._ifArray.leU_last();
};

TBSSequenceManager.prototype.runEndIfCommand = function () {
    this._ifArray.pop();
};

TBSSequenceManager.prototype.runForEachCommand = function (query) {
    if (query.match(/cell in (.+)/i)) {
        this._forEachCellArray = this.readCellTargets(RegExp.$1);

    }
};

TBSSequenceManager.prototype.areConditionsOkay = function () {
    if (this._ifArray.length === 0) return true;
    return !!this._ifArray[this._ifArray.length - 1];
};

//-----------------------

TBSSequenceManager.prototype.commandPlayPose = function (param) {
    var targets = this.readTargets(param[0]);
    var pose = param[1];
    var afterPose = param[2];
    var wait = false;
    if (afterPose === "wait") {
        wait = true;
        afterPose = null;
    }

    targets.forEach(function (target) {
        target.requestPlayPose();
        target.setPose(pose, afterPose);
    }.bind(this));

    return {
        requestWait: wait,
        waitWhile: function (targets) {
            return targets.some(function (entity) {
                return !entity.isRequestedPosePlayed();
            });
        }.bind(this, targets)
    };
};

TBSSequenceManager.prototype.commandSetFrame = function (param) {
    var targets = this.readTargets(param[0]);
    var pose = param[1];
    var frame = param[2];

    targets.forEach(function (target) {
        target.setFixedPose(pose, frame);
    }.bind(this));

    return {};
};

TBSSequenceManager.prototype.commandSetSpeed = function (param) {
    var targets = this.readTargets(param[0]);
    var value = param[1];

    if (value === "reset") {
        targets.forEach(function (target) {
            target.initializeSpeed();
        }.bind(this));
    } else if (value.match(/\+(.+)/i)) {
        targets.forEach(function (target) {
            target.changeSpeed(Number(RegExp.$1));
        }.bind(this));
    } else if (value.match(/\-(.+)/i)) {
        targets.forEach(function (target) {
            target.changeSpeed(-Number(RegExp.$1));
        }.bind(this));
    } else {
        targets.forEach(function (target) {
            target.setSpeed(Number(value));
        }.bind(this));
    }

    return {};
};

TBSSequenceManager.prototype.commandSetFrameDelay = function (param) {
    var targets = this.readTargets(param[0]);
    var value = param[1];

    if (value === "reset") {
        targets.forEach(function (target) {
            target.sprite().initializeFrameDelay();
        }.bind(this));
    } else if (value.match(/\+(.+)/i)) {
        targets.forEach(function (target) {
            target.sprite().changeFrameDelay(Number(RegExp.$1));
        }.bind(this));
    } else if (value.match(/\-(.+)/i)) {
        targets.forEach(function (target) {
            target.sprite().changeFrameDelay(-Number(RegExp.$1));
        }.bind(this));
    } else {
        targets.forEach(function (target) {
            target.sprite().setFrameDelay(Number(value));
        }.bind(this));
    }

    return {};
};

TBSSequenceManager.prototype.commandSpriteShake = function (param) {
    var targets = this.readTargets(param[0]);
    var power = Number(param[1]);
    var duration = Number(param[2]);
    var wait = (param[3] === "true");

    for (var i = 0; i < targets.length; i++) {
        targets[i].startShake(power, duration);
    }

    if (wait)
        return this.commandWait([duration]);
    return {};
};

TBSSequenceManager.prototype.commandSpriteProp = function (param) {
    var targets = this.readTargets(param[0]);
    var prop = param[1];
    var value = Number(param[2]);

    for (var i = 0; i < targets.length; i++) {
        targets[i]._sprite[prop] = value;
    }

    return {};
};

TBSSequenceManager.prototype.commandWait = function (param) {
    var duration = Number(param[0]);

    BattleManagerTBS.wait(duration);

    return {
        requestWait: true,
        waitWhile: function () {
            return BattleManagerTBS.isWaiting();
        }
    };
};

TBSSequenceManager.prototype.commandEffects = function (param) {
    var targets = this.readTargets(param[0]);
    var objData = param[1];
    var obj = this.readObject(objData);
    var hitAnim = this.readAnimation(param[2]);
    var animDelay = Number(param[3] || 0);
    var wait = String(param[4] || "false");
    wait = (wait === "true");

    BattleManagerTBS.invokeObjEffects(this.getUser(), obj, targets, hitAnim, animDelay);
    this._affectedTargets = this._affectedTargets.concat(targets);

    return {
        requestWait: wait,
        waitWhile: function () {
            return BattleManagerTBS.isAnimationPlaying();
        }.bind(this)
    };
};

TBSSequenceManager.prototype.commandMapEffects = function (param) {
    var cellTargets = this.readCellTargets(param[0]);
    var obj = this.readObject(param[1]);
    var hitAnim = this.readAnimation(param[2]);
    var animDelay = Number(param[3] || 0);
    var wait = String(param[4] || "false");
    wait = (wait == "true");

    BattleManagerTBS.invokeObjEffectsOnMap(this.getUser(), obj, cellTargets, hitAnim, animDelay);
    var targets = cellTargets.map(function (cell) {
        return cell.getEntity();
    });
    this._affectedTargets = this._affectedTargets.concat(targets);

    return {
        requestWait: wait,
        waitWhile: function () {
            return BattleManagerTBS.isAnimationPlaying();
        }.bind(this)
    };
};

TBSSequenceManager.prototype.commandValidateDeath = function (param) {
    var targets = this.readTargets(param[0]);

    for (var i = 0; i < targets.length; i++) {
        targets[i].validateDeath();
    }

    return {};
};

TBSSequenceManager.prototype.commandAnim = function (param) {
    var targets = this.readTargets(param[0]);
    var anim = this.readAnimation(param[1]);
    var animDelay = Number(param[2] || 0);
    var wait = String(param[3] || "false");
    wait = (wait == "true");

    targets.forEach(function (target) {
        target.newAnimation(anim, false, animDelay);
    }.bind(this));

    return {
        requestWait: wait,
        waitWhile: function () {
            return BattleManagerTBS.isAnimationPlaying();
        }.bind(this)
    };
};

TBSSequenceManager.prototype.commandMapAnim = function (param) {
    var cellTargets = this.readCellTargets(param[0]);
    var anim = this.readAnimation(param[1]);
    var animDelay = Number(param[2] || 0);
    var wait = String(param[3] || "false");
    wait = (wait == "true");

    cellTargets.forEach(function (cell) {
        BattleManagerTBS.getLayer("animations").newAnimation(anim, false, animDelay, cell);
    }.bind(this));

    return {
        requestWait: wait,
        waitWhile: function () {
            return BattleManagerTBS.isAnimationPlaying();
        }.bind(this)
    };
};

TBSSequenceManager.prototype.commandDirectionalAnim = function (param) {
    var targetData1 = param[0];
    var targetData2 = param[1];
    var anim_2 = param[2];
    var anim_4 = param[3];
    var anim_6 = param[4];
    var anim_8 = param[5];
    var animDelay = Number(param[6] || 0);
    var wait = String(param[7] || "false");
    var targets1 = this.readTargets(targetData1);

    if (targets1.length > 0) {
        var anim;
        switch (targets1[0].getDir()) {
            case 2:
                anim = anim_2;
                break;
            case 4:
                anim = anim_4;
                break;
            case 6:
                anim = anim_6;
                break;
            case 8:
                anim = anim_8;
                break;
        }
        param[0] = targetData2;
        param[1] = anim;
        param[2] = animDelay;
        param[3] = wait;
        return this.commandAnim(param);
    }
    return {};
};

TBSSequenceManager.prototype.commandWeaponAnim = function (param) {
    var targets = this.readTargets(param[0]);
    var type = param[1];
    var wtype = param[2];

    targets.forEach(function (entity) {
        entity.startWeaponAnimation(type, wtype);
    });

    return {};
};

TBSSequenceManager.prototype.commandLookAt = function (param) {
    var targets = this.readTargets(param[0]);
    var cellTargets = this.readCellTargets(param[1]);

    if (cellTargets.length > 0) {
        var cell = cellTargets[0];
        targets.forEach(function (target) {
            target.lookAt(cell);
        }.bind(this));
    }

    return {};
};

TBSSequenceManager.prototype.commandLookAway = function (param) {
    var targets = this.readTargets(param[0]);
    var cellTargets = this.readCellTargets(param[1]);

    if (cellTargets.length > 0) {
        var cell = cellTargets[0];
        targets.forEach(function (target) {
            target.lookAway(cell);
        }.bind(this));
    }

    return {};
};

TBSSequenceManager.prototype.commandSetDirection = function (param) {
    var targets = this.readTargets(param[0]);
    var dir = Number(param[1]);

    targets.forEach(function (entity) {
        entity.setDir(dir);
    });

    return {};
};

TBSSequenceManager.prototype.commandMoveToCell = function (param) {
    var targets = this.readTargets(param[0]);
    var cellTargets = this.readCellTargets(param[1]);
    var isInstant = String(param[2] || "false") === "true";

    if (targets.length > 0 && cellTargets.length > 0) {
        var target = targets[0];
        var cell = cellTargets[0];
        if (isInstant) {
            target.teleport(cell);
        } else {
            var path = BattleManagerTBS.getPathFromAToB(target._cell.x, target._cell.y, cell.x, cell.y, "walkable", []);
            target.processMovement(path);
        }
    }

    return {
        requestWait: true,
        waitWhile: function (targets) {
            return targets.some(function (entity) {
                return entity.isMoving();
            });
        }.bind(this, targets)
    };
};

TBSSequenceManager.prototype.commandSwitchCells = function (param) {
    var target1 = this.readTargets(param[0])[0];
    var target2 = this.readTargets(param[1])[0];

    if (target1 && target2)
        target1.switchCellWith(target2);

    return {};
};

TBSSequenceManager.prototype.commandJumpToCell = function (param) {
    var targets = this.readTargets(param[0]);
    var cellTargets = this.readCellTargets(param[1]);
    var height = param[2] || 120;

    if (targets.length > 0 && cellTargets.length > 0) {
        var target = targets[0];
        var cell = cellTargets[0];
        var sx = target.x;
        var sy = target.y;
        var dx = cell.x * $gameMap.tileWidth();
        var dy = cell.y * $gameMap.tileHeight();
        var trajectory = BattleManagerTBS.makeTrajectory(sx, sy, dx, dy, height, 60, "normal_jump");
        target.followTrajectory(trajectory, cell);
    }

    return {
        requestWait: true,
        waitWhile: function (targets) {
            return targets.some(function (entity) {
                return entity._sprite.hasTrajectory();
            });
        }.bind(this, targets)
    };
};

TBSSequenceManager.prototype.commandMoveStraight = function (param) {
    var targets = this.readTargets(param[0]);
    var nbr = Number(param[1] || 1);

    targets.forEach(function (target) {
        target.forceMoveStraight(nbr, false);
    }.bind(this));

    return {
        requestWait: true,
        waitWhile: function (targets) {
            return targets.some(function (entity) {
                return entity.isMoving();
            });
        }.bind(this, targets)
    };
};

TBSSequenceManager.prototype.commandPush = function (param) {
    var targets = this.readTargets(param[0]);
    var sourceCell = this.readCellTargets(param[1])[0];
    var distance = Number(param[2]);
    var damage = param[3] !== "false";

    for (var i = 0; i < targets.length; i++) {
        var entity = targets[i];
        entity.forcePush(this.getUser(), sourceCell, distance, this.getObj(), damage);
    }

    return {
        requestWait: true,
        waitWhile: function (targets) {
            return targets.some(function (entity) {
                return entity.isMoving();
            });
        }.bind(this, targets)
    };
};

TBSSequenceManager.prototype.commandPull = function (param) {
    var targets = this.readTargets(param[0]);
    var sourceCell = this.readCellTargets(param[1])[0];
    var distance = Number(param[2]);
    var damage = param[3] !== "false";

    for (var i = 0; i < targets.length; i++) {
        var entity = targets[i];
        entity.forcePull(this.getUser(), sourceCell, distance, this.getObj(), damage);
    }

    return {
        requestWait: true,
        waitWhile: function (targets) {
            return targets.some(function (entity) {
                return entity.isMoving();
            });
        }.bind(this, targets)
    };
};

TBSSequenceManager.prototype.commandReachTarget = function (param) {
    var user = this.readTargets(param[0])[0];
    var target = this.readTargets(param[1])[0];
    var type = param[2];
    var endIf = (param[3] || "true") === "true";

    if (target) {
        if (endIf && !user.reachEntity(target, type))
            this.endOfSequence();
    }

    return {};
};

TBSSequenceManager.prototype.commandProjectile = function (param) {
    var id = param[0];
    var cellTargets1 = this.readCellTargets(param[1]);
    var cellTargets2 = this.readCellTargets(param[2]);
    cellTargets2 = LeUtilities.uniqArray(cellTargets2);

    if (cellTargets1.length > 0 && cellTargets2.length > 0) {
        var cellStart = cellTargets1[0];
        cellTargets2.forEach(function (cellEnd) {
            var w = $gameMap.tileWidth();
            var h = $gameMap.tileHeight();
            var sx = cellStart.x * w + w / 2;
            var sy = cellStart.y * h + h / 2;
            var dx = cellEnd.x * w + w / 2;
            var dy = cellEnd.y * h + h / 2;
            var effects = {
                obj: param[3],
                anim: param[4],
                user: this.getUser()
            };
            BattleManagerTBS._projectilesManager.newProjectile(id, [sx, sy], [dx, dy], effects);
        }, this);
    }

    return {
        requestWait: true,
        waitWhile: function () {
            return BattleManagerTBS._projectilesManager.isRunning();
        },
    };
};

TBSSequenceManager.prototype.commandSaveEntities = function (param) {
    var id = param[0];
    var targets = this.readTargets(param[1]);
    var option = param[2];
    this._savedEntities[id] = targets;
    if (option === "shift") {
        this._savedEntities[id] = [targets.shift()];
    } else {
        this._savedEntities[id] = targets;
    }

    return {};
};

TBSSequenceManager.prototype.commandSaveCells = function (param) {
    var id = param[0];
    var targets = this.readCellTargets(param[1]);
    var option = param[2];
    if (option === "shift") {
        this._savedCells[id] = [targets.shift()];
    } else {
        this._savedCells[id] = targets;
    }

    return {};
};

TBSSequenceManager.prototype.commandFilterEntities = function (param) {
    var oriTargets = this.readTargets(param[0]);
    var targetsToExclude = this.readTargets(param[1]);
    var id = param[2];
    this._savedEntities[id] = oriTargets.filter(function (e) {
        return targetsToExclude.indexOf(e) === -1;
    });

    return {};
};

TBSSequenceManager.prototype.commandFilterCells = function (param) {
    var oriTargets = this.readCellTargets(param[0]);
    var targetsToExclude = this.readCellTargets(param[1]);
    var id = param[2];
    this._savedCells[id] = oriTargets.filter(function (e) {
        return targetsToExclude.indexOf(e) === -1;
    });

    return {};
};

TBSSequenceManager.prototype.commandSetCursor = function (param) {
    var targets = this.readCellTargets(param[0]);
    var cell = targets[0];
    BattleManagerTBS.setCursorCell(cell);

    return {};
};

TBSSequenceManager.prototype.commandCall = function (param) {
    var seq = param[0];
    var times = Number(param[1] || 1);

    var seqArray = param[2] || Lecode.S_TBS.Config.Sequences[seq].slice();
    for (var i = 0; i < times; i++) {
        for (var j = seqArray.length - 1; j >= 0; j--) {
            var command = seqArray[j];
            this._sequence.table.unshift(command);
        }
    }

    return {};
};

TBSSequenceManager.prototype.commandCallForEveryCell = function (param) {
    var seq = param[0];
    var aoe = this.readCellTargets(param[1]);
    var sortType = param[2] || "random";

    if (sortType === "close->far") {
        aoe = LeUtilities.sortByClosestDistance(this.getUser().getCell(), aoe);
    } else if (sortType === "far->close") {
        aoe = LeUtilities.sortByFarthestDistance(this.getUser().getCell(), aoe);
    } else if (sortType === "random") {
        aoe = aoe.filter(function (cell) {
            return true;
        });
    }
    if (aoe.length > 0) {
        this._savedCells["every_cell_base"] = aoe;

        var seqArray = param[3] || Lecode.S_TBS.Config.Sequences[seq].slice();
        for (var i = 0; i < aoe.length; i++) {
            for (var j = seqArray.length - 1; j >= 0; j--) {
                var command = seqArray[j];
                this._sequence.table.unshift(command);
            }
            this._sequence.table.unshift("save_cells: every_cell, saved(every_cell_base), shift");
        }
    }

    return {};
};

TBSSequenceManager.prototype.commandCallForEveryEntity = function (param) {
    var seq = param[0];
    var entities = this.readTargets(param[1]);
    var sortType = param[2] || "random";

    if (sortType === "close->far") {
        entities = entities.sort(function (a, b) {
            var obj_aDist = LeUtilities.distanceBetween(a.getCell(), this.getUser().getCell());
            var obj_bDist = LeUtilities.distanceBetween(b.getCell(), this.getUser().getCell());
            return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
        }.bind(this));
    } else if (sortType === "far->close") {
        entities = entities.sort(function (a, b) {
            var obj_aDist = LeUtilities.distanceBetween(a.getCell(), this.getUser().getCell());
            var obj_bDist = LeUtilities.distanceBetween(b.getCell(), this.getUser().getCell());
            return (obj_aDist > obj_bDist) ? -1 : ((obj_aDist < obj_bDist) ? 1 : 0);
        }.bind(this));
    } else if (sortType === "random") {
        entities = entities.filter(function (cell) {
            return true;
        });
    }
    if (entities.length > 0) {
        this._savedEntities["every_entity_base"] = entities;

        var seqArray = param[3] || Lecode.S_TBS.Config.Sequences[seq].slice();
        for (var i = 0; i < entities.length; i++) {
            for (var j = seqArray.length - 1; j >= 0; j--) {
                var command = seqArray[j];
                this._sequence.table.unshift(command);
            }
            this._sequence.table.unshift("save_entities: every_entity, saved(every_entity_base), shift");
        }
    }

    return {};
};

TBSSequenceManager.prototype.commandBounce = function (param) {
    var seq = param[0];
    var startEntity = param[1];
    var maxTargets = Number(param[2]);
    var aoe = param[3];
    var targetType = param[4] || "all";

    var seqArray = Lecode.S_TBS.Config.Sequences[seq].slice();
    startEntity = this.readTargets(startEntity)[0];
    var entities1 = [this.getUser()];
    var entities2 = [startEntity];
    var targeted = [this.getUser(), startEntity];
    var targets = 0;
    var entity1 = startEntity;
    do {
        var center = entity1.getCell().toCoords();
        var size = BattleManagerTBS.getScopeFromData(aoe, center, {});
        var entities = BattleManagerTBS.getEntitiesInScope(size).filter(function (entity) {
            if (targeted.indexOf(entity) > -1) return false;
            if (targetType === "all") return true;
            if (targetType === "enemy" && this.isEnemy(entity.battler())) return true;
            if (targetType === "ally" && this.isAlly(entity.battler())) return true;
            return false;
        }, this);
        if (entities.length === 0) break;
        var entity2 = LeUtilities.getRandomValueInArray(entities);
        targeted.push(entity2);
        entities1.push(entity1);
        entities2.push(entity2);
        entity1 = entity2;
        targets++;
    } while (targets != maxTargets);
    this._savedEntities["bounce_entities1"] = entities1;
    this._savedEntities["bounce_entities2"] = entities2;

    for (var i = 0; i <= targets; i++) {
        for (var j = seqArray.length - 1; j >= 0; j--) {
            var command = seqArray[j];
            this._sequence.table.unshift(command);
        }
        this._sequence.table.unshift("save_entities: bounce_entity1, saved(bounce_entities1), shift");
        this._sequence.table.unshift("save_entities: bounce_entity2, saved(bounce_entities2), shift");
    }

    return {};
};

TBSSequenceManager.prototype.commandDelegateCall = function (param) {
    var seq = param[0];
    var targets = this.readTargets(param[1]);

    if (targets.length > 0) {
        this._users.push(targets[0]);
        param[1] = 1;
        this.commandCall(param);
    }

    return {};
};

TBSSequenceManager.prototype.commandEndDelegatedCall = function () {
    this._users.pop();

    return {};
};

TBSSequenceManager.prototype.commandAskCall = function (param) {
    var seq = param[0];
    var targets = this.readTargets(param[1]);

    for (var i = 0; i < targets.length; i++) {
        targets[i].startSequence(seq);
    }

    return {};
};

TBSSequenceManager.prototype.commandUseSkill = function (param) {
    var targets = this.readTargets(param[0]);
    var skillId = param[1];
    var skill = $dataSkills[skillId];

    for (var i = 0; i < targets.length; i++) {
        BattleManagerTBS.forceAction(skill, targets[i]);
    }

    return {};
};

TBSSequenceManager.prototype.commandScript = function (param) {
    var code = param[0];
    var user = this.getUser();
    eval(code);

    return {};
};

TBSSequenceManager.prototype.commandCommonEvent = function (param) {
    var id = Number(param[1]);
    var wait = param[2] === "wait";
    var list = $dataCommonEvents[id].list;
    if (list)
        $gameTroop._interpreter.setupInQueue(list);

    return {};
};

TBSSequenceManager.prototype.commandPluginCommand = function (param) {
    var args = param.join(" ").split(",  ");
    console.log("args:", args);
    $gameTroop._interpreter.pluginCommand("LeTBS", args);
};

TBSSequenceManager.prototype.commandShowHuds = function (param) {
    var scene = LeUtilities.getScene();
    for (var i = 0; i < param.length; i++) {
        var hudStr = param[i];
        scene.showHud(hudStr);
    }

    return {};
};

TBSSequenceManager.prototype.commandHideHuds = function (param) {
    var scene = LeUtilities.getScene();
    for (var i = 0; i < param.length; i++) {
        var hudStr = param[i];
        scene.hideHud(hudStr);
    }

    return {};
};

TBSSequenceManager.prototype.commandShowPicture = function (param) {
    var picId = param[0];
    var filename = param[1];
    var xStr = param[2];
    var yStr = param[3];
    BattleManagerTBS._spriteset.showPicture(picId, filename, xStr, yStr);

    return {};
};

TBSSequenceManager.prototype.commandFreePicture = function (param) {
    var picId = param[0];
    BattleManagerTBS._spriteset.freePicture(picId);

    return {};
};

TBSSequenceManager.prototype.commandPictureOpacity = function (param) {
    var picId = param[0];
    var opacity = Number(param[1]);
    var time = param[2] ? Number(param[2]) : 0;
    var wait = (param[3] === "true");

    var picture = BattleManagerTBS._spriteset.getPicture(picId);
    LeUtilities.tweenProperty(picture, "opacity", opacity, time).start();

    return {
        requestWait: wait,
        waitWhile: function (picture, opacity) {
            return picture.opacity !== opacity;
        }.bind(this, picture, opacity)
    };
};

TBSSequenceManager.prototype.commandMovePicture = function (param) {
    var picId = param[0];
    var xStr = param[1];
    var yStr = param[2];
    var time = param[3];
    var wait = (param[4] === "true");

    var picture = BattleManagerTBS._spriteset.getPicture(picId);
    var coords = BattleManagerTBS._spriteset.movePicture(picId, xStr, yStr, time);

    return {
        waitWhile: function (picture, coords) {
            return picture.x != coords.x || picture.y != coords.y;
        }.bind(this, picture, coords)
    };
};

TBSSequenceManager.prototype.commandFlashPicture = function (param) {
    var picId = param[0];
    var r = Number(param[1]);
    var g = Number(param[2]);
    var b = Number(param[3]);
    var gray = Number(param[4]);
    var duration = Number(param[5]);
    var wait = (param[6] === "true");

    var picture = BattleManagerTBS._spriteset.getPicture(picId);
    picture.leU_startFlash([r, g, b, gray], duration);

    return {
        waitWhile: function (picture) {
            return picture._leU_flashDuration > 0;
        }.bind(this, picture)
    };
};

TBSSequenceManager.prototype.commandScreenTone = function (param) {
    var r = param[0];
    var g = param[1];
    var b = param[2];
    var gray = param[3];
    var duration = Number(param[4]);

    if (r === "clear") {
        $gameScreen.clearTone();
    } else {
        $gameScreen.startTint([Number(r), Number(g), Number(b), Number(gray)], duration);
    }

    return {};
};

TBSSequenceManager.prototype.commandScreenFlash = function (param) {
    var r = param[0];
    var g = param[1];
    var b = param[2];
    var gray = param[3];
    var duration = Number(param[4]);

    if (r === "clear") {
        $gameScreen.clearFlash();
    } else {
        $gameScreen.startFlash([Number(r), Number(g), Number(b), Number(gray)], duration);
    }

    return {};
};

//- TODO:
TBSSequenceManager.prototype.commandMapLayer = function (param) {
    var spriteset = BattleManagerTBS._spriteset;
    if (Graphics.isWebGL()) {
        /*var filter = new PIXI.filters.BlurFilter(1, 1, 0.5);
        spriteset.setMapFilter(filter, true);*/
    }

    return {};
};

TBSSequenceManager.prototype.commandPlaySe = function (param) {
    var audio = {};
    audio.name = param[0];
    audio.pitch = Number(param[1]) || 100;
    audio.volume = Number(param[2]) || 90;
    audio.pan = Number(param[3]) || 0;
    AudioManager.playSe(audio);

    return {};
};

//-------------------------------------------------------------------------------------------

TBSSequenceManager.prototype.baseAoE = function () {
    return BattleManagerTBS._actionAoE;
};

TBSSequenceManager.prototype.baseCursorCell = function () {
    return BattleManagerTBS._activeCell;
};

TBSSequenceManager.prototype.readTargets = function (data, deepRead) {
    if (deepRead == null) deepRead = true;
    if (data instanceof Array) return data;
    if (deepRead) {
        var cells = this.readCellTargets(data, false);
        if (cells.length > 0) {
            return BattleManagerTBS.getEntitiesInScope(cells);
        }
    }

    var targets = [];
    var cursorCell = this.baseCursorCell();
    var aoe = [];
    if (data.match(/\{(.+)\}/i)) {
        var aoeKey = RegExp.$1;
        if (aoeKey === "aoe") {
            aoe = this.baseAoE();
        } else if (aoeKey === "cursor") {
            aoe = [cursorCell];
        } else {
            var param = {
                user: this.getUser(),
                dir: this.getUser().getDirectionTo(cursorCell),
                need_check_los: false,
                exclude_center: false,
                line_of_sight: false
            };
            aoe = BattleManagerTBS.getScopeFromData(aoeKey, cursorCell, param);
        }
    }
    var aoeTargets = BattleManagerTBS.getEntitiesInScope(aoe);
    var aoeAllyTargets = aoeTargets.filter(function (entity) {
        return this.isAlly(entity.battler());
    }.bind(this));
    var aoeEnemyTargets = aoeTargets.filter(function (entity) {
        return this.isEnemy(entity.battler());
    }.bind(this));
    var aoeDeadTargets = aoeTargets.filter(function (entity) {
        return entity.battler().isDead();
    });
    var aoeDeadAllyTargets = aoeAllyTargets.filter(function (entity) {
        return entity.battler().isDead();
    });
    var aoeDeadEnemyTargets = aoeEnemyTargets.filter(function (entity) {
        return entity.battler().isDead();
    });
    var cursorTarget = [cursorCell.getEntity()];
    var cursorAllyTarget = (cursorTarget[0] && this.isAlly(cursorTarget[0].battler())) ? cursorTarget : [];
    var cursorEnemyTarget = (cursorTarget[0] && this.isEnemy(cursorTarget[0].battler())) ? cursorTarget : [];
    var cursorDeadTarget = (cursorTarget[0] && cursorTarget[0].battler().isDead()) ? cursorTarget : [];
    var cursorDeadAllyTarget = (cursorAllyTarget[0] > 0 && cursorAllyTarget[0].battler().isDead()) ? cursorAllyTarget : [];
    var cursorDeadEnemyTarget = (cursorEnemyTarget[0] > 0 && cursorEnemyTarget[0].battler().isDead()) ? cursorEnemyTarget : [];

    if (data.match(/^user$/i)) {    //user
        targets = [this.getUser()];
    } else if (data.match(/^all$/i)) {  //all
        BattleManagerTBS.allEntities().forEach(function (entity) {
            targets.push(entity);
        });
    } else if (data.match(/^allies$/i)) {   //allies
        BattleManagerTBS.allEntities().forEach(function (entity) {
            if (this.isAlly(entity.battler()))
                targets.push(entity);
        }.bind(this));
    } else if (data.match(/^enemies$/i)) {  //enemies
        BattleManagerTBS.allEntities().forEach(function (entity) {
            if (this.isEnemy(entity.battler()))
                targets.push(entity);
        }.bind(this));
    } else if (data.match(/^active_entity$/i)) { //active_entity
        targets = [BattleManagerTBS.activeEntity()];
    } else if (data.match(/^cursor_battler$/i)) { //cursor_battler
        targets = cursorTarget;
    } else if (data.match(/^cursor_ally$/i)) { //cursor_ally
        targets = cursorAllyTarget;
    } else if (data.match(/^cursor_enemy$/i)) { //cursor_enemy
        targets = cursorEnemyTarget;
    } else if (data.match(/^saved\((.+)\)$/i) && this._savedEntities[RegExp.$1]) { //saved(x)
        targets = this._savedEntities[RegExp.$1];
    } else if (data.match(/^\{.+\}_battlers$/i)) { //{x}_battlers
        targets = aoeTargets;
    } else if (data.match(/^\{.+\}_allies$/i)) {
        targets = aoeAllyTargets;
    } else if (data.match(/^\{.+\}_enemies$/i)) {
        targets = aoeEnemyTargets;
    } else if (data.match(/^(\d+)_battlers_in_\{.+\}$/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeTargets, Number(RegExp.$1));
    } else if (data.match(/^(\d+)_allies_in_\{.+\}$/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeAllyTargets, Number(RegExp.$1));
    } else if (data.match(/^(\d+)_enemies_in_\{.+\}$/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeEnemyTargets, Number(RegExp.$1));
    } else if (data.match(/^\{.+\}_dead_battlers$/i)) {
        targets = aoeDeadTargets;
    } else if (data.match(/^\{.+\}_dead_allies$/i)) {
        targets = aoeDeadAllyTargets;
    } else if (data.match(/^\{.+\}_dead_enemies$/i)) {
        targets = aoeDeadEnemyTargets;
    } else if (data.match(/^(\d+)_dead_battlers_in_\{.+\}$/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeDeadTargets, Number(RegExp.$1));
    } else if (data.match(/^(\d+)_dead_allies_in_\{.+\}$/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeDeadAllyTargets, Number(RegExp.$1));
    } else if (data.match(/^(\d+)_dead_enemies_in_\{.+\}$/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeDeadEnemyTargets, Number(RegExp.$1));
    } else if (data.match(/^cursor_dead_battler/i)) {
        targets = cursorDeadTarget;
    } else if (data.match(/^cursor_dead_ally$/i)) {
        targets = cursorDeadAllyTarget;
    } else if (data.match(/^cursor_dead_enemy$/i)) {
        targets = cursorDeadEnemyTarget;
    } else if (data.match(/^battler_toward_user$/i)) {
        var cell = this.getUser().getForwardCell();
        if (cell) {
            var target = cell.getEntity();
            if (target)
                targets = [target];
        }
    }

    return targets;
};

TBSSequenceManager.prototype.readCellTargets = function (data, deepRead) {
    if (deepRead == null) deepRead = true;
    if (data instanceof Array) return data;
    if (deepRead) {
        var entities = this.readTargets(data, false);
        if (entities.length > 0) {
            return entities.map(function (entity) {
                return entity.getCell();
            });
        }
    }

    var targets = [];
    var cursorCell = this.baseCursorCell();
    var aoe = [];
    if (data.match(/\{(.+)\}/i)) {
        var aoeKey = RegExp.$1;
        if (aoeKey === "aoe") {
            aoe = this.baseAoE();
        } else if (aoeKey === "cursor") {
            aoe = [cursorCell];
        } else {
            var param = {
                user: this.getUser(),
                dir: this.getUser().getDirectionTo(cursorCell),
                need_check_los: false,
                exclude_center: false,
                line_of_sight: false
            };
            aoe = BattleManagerTBS.getScopeFromData(aoeKey, cursorCell, param);
        }
    }

    if (data.match(/^(\d+)_cells_in_\{.+\}$/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoe, Number(RegExp.$1));
    } else if (data.match(/^cursor_cell$/i)) {
        targets = [cursorCell];
    } else if (data.match(/^user_cell$/i)) {
        targets = [this.getUser().getCell()];
    } else if (data.match(/^\{.+\}_ally_cells$/i)) {
        targets = aoe.filter(function (cell) {
            var e = cell.getEntity();
            if (e) {
                return this.isAlly(e.battler());
            }
            return false;
        }.bind(this));
    } else if (data.match(/^\{.+\}_enemy_cells$/i)) {
        targets = aoe.filter(function (cell) {
            var e = cell.getEntity();
            if (e) {
                return this.isEnemy(e.battler());
            }
            return false;
        }.bind(this));
    } else if (data.match(/^battlers_cells$/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            targets.push(entity.getCell());
        }.bind(this));
    } else if (data.match(/^ally_cells$/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            if (this.isAlly(entity.battler()))
                targets.push(entity.getCell());
        }.bind(this));
    } else if (data.match(/^enemy_cells$/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            if (this.isEnemy(entity.battler()))
                targets.push(entity.getCell());
        }.bind(this));
    } else if (data.match(/^last_targets$/i)) {
        targets = this._lastCellTargets;
    } else if (data.match(/^saved\((.+)\)$/i)) {
        targets = this._savedCells[RegExp.$1] || [];
    } else if (data.match(/^\{(.+)\}$/i)) {
        targets = aoe;
    }

    return targets;
};

TBSSequenceManager.prototype.readObject = function (data) {
    if (data.match(/current_obj/i))
        return this._obj;
    //return BattleManagerTBS.activeAction().item();
    else if (data.match(/skill\((.+)\)/i))
        return $dataSkills[Number(RegExp.$1)];
    else if (data.match(/item\((.+)\)/i))
        return $dataItems[Number(RegExp.$1)];
    return null;
};

TBSSequenceManager.prototype.readAnimation = function (data) {
    if (data.match(/obj_anim/i)) {
        if (this._action.isAttack())
            return BattleManagerTBS.activeEntity().getAttackAnimation();
        else
            return this._action.item().animationId;
    } else if (data.match(/collapse_anim/i)) {
        return "collapse_anim";
    }
    return parseInt(data);
};

TBSSequenceManager.prototype.endOfSequence = function () {
    this._sequence.name = "";
    this._sequence.table = [];
    this._sequence.finished = true;
    this._command = {
        instruction: "",
        waitWhile: function () { return false; },
        update: function () { },
        onEnd: function () { }
    };
    this._savedEntities = {};
    this._savedCells = {};
    var data = this._sequenceQueue.shift();
    if (data) {
        this.start(data[0], data[1], data[2]);
        this.update();
    } else {
        BattleManagerTBS.onPrimarySequenceEnd(this);
        this._affectedTargets = [];
    }
};

TBSSequenceManager.prototype.isRunning = function () {
    return this._sequence.started && !this._sequence.finished;
};

TBSSequenceManager.prototype.isAlly = function (battler) {
    return this.getUser().battler().isActor() && battler.isActor() || this.getUser().battler().isEnemy() && battler.isEnemy();
};

TBSSequenceManager.prototype.isEnemy = function (battler) {
    return !this.isAlly(battler);
};

/*-------------------------------------------------------------------------
* TBSProjectilesManager
-------------------------------------------------------------------------*/
function TBSProjectilesManager() {
    this.initialize.apply(this, arguments);
}

TBSProjectilesManager.prototype.initialize = function (layer) {
    this._layer = layer;
    this._projectiles = [];
    this._running = false;
};

TBSProjectilesManager.prototype.isRunning = function () {
    return this._projectiles.length > 0;
};

TBSProjectilesManager.prototype.newProjectile = function (id, start, end, effects) {
    var proj = new TBSProjectileSprite(id, start, end, effects);
    this._projectiles.push(proj);
    this._layer.addChild(proj);
};

TBSProjectilesManager.prototype.update = function () {
    //this.updateProjectiles();
    this.destoryProjectiles();
};

TBSProjectilesManager.prototype.updateProjectiles = function () {
    for (var i = 0; i < this._projectiles.length; i++) {
        this._projectiles[i].update();
    }
};

TBSProjectilesManager.prototype.destoryProjectiles = function () {
    this._projectiles = this._projectiles.filter(function (proj) {
        if (proj.finished()) {
            this.triggerProjectileEffects(proj);
            this._layer.removeChild(proj);
            return false;
        }
        return true;
    }.bind(this));
};

TBSProjectilesManager.prototype.triggerProjectileEffects = function (proj) {
    var effects = proj._effects;
    if (effects.obj) {
        var seqMng = effects.user._sequenceManager;
        var end = proj._end;
        var w = $gameMap.tileWidth();
        var h = $gameMap.tileHeight();
        var x = end[0] / w - 1 / 2;
        var y = end[1] / h - 1 / 2;
        var cell = BattleManagerTBS.getCellAt(x, y);
        var obj = effects.obj;
        var hitAnim = effects.anim;
        var animDelay = 0;
        var wait = "false";
        seqMng.commandMapEffects([[cell], obj, hitAnim, animDelay, wait]);
    }
};

/*-------------------------------------------------------------------------
* TBSProjectileSprite
-------------------------------------------------------------------------*/
function TBSProjectileSprite() {
    this.initialize.apply(this, arguments);
}
TBSProjectileSprite.prototype = Object.create(Sprite_Base.prototype);
TBSProjectileSprite.prototype.constructor = TBSProjectileSprite;

TBSProjectileSprite.prototype.initialize = function (id, start, end, effects, trajType) {
    Sprite_Base.prototype.initialize.call(this);
    this._start = start;
    this._end = end;
    this._trajectory = [];
    this._speedFrame = 0;
    this._effects = effects;
    this.readData(id);
    this.iniPositions();
    this.makeTrajectory();
};

TBSProjectileSprite.prototype.readData = function (id) {
    var data = Lecode.S_TBS.Config.Projectiles[id];
    if (data.filename) {
        var bitmap = ImageManager.loadLeTBSProjectile(data.filename);
        this.bitmap = bitmap;
    } else if (data.anim) {
        this.bitmap = new Bitmap(data.anim[1], data.anim[2]);
        this.startAnimation(data.anim[0]);
    }
    this._trajectoryType = data.trajectory || "curved_jump(50)";
    this._speed = data.speed || 3;
    this._adaptAngle = false || data.adapt_angle;
    this.anchor.x = 0.5;
    this.anchor.y = 0.5;
};

TBSProjectileSprite.prototype.iniPositions = function () {
    this.x = this._start[0];
    this.y = this._start[1];
};

TBSProjectileSprite.prototype.makeTrajectory = function () {
    var sx = this._start[0];
    var sy = this._start[1];
    var dx = this._end[0];
    var dy = this._end[1];
    var type = this._trajectoryType;
    this._trajectory = BattleManagerTBS.makeTrajectory(sx, sy, dx, dy, 0, 60, type);
    var opts = { easing: TWEEN.Easing.Sinusoidal.In };
    var distance = LeUtilities.distanceBetween({ x: sx, y: sy }, { x: dx, y: dy });
    var time = (distance * 30) / this._speed;
    LeUtilities.tweenProperty(this, "_speedFrame", this._trajectory.length - 1, time, opts).start();
};

TBSProjectileSprite.prototype.update = function () {
    Sprite_Base.prototype.update.call(this);
    if (!this.finished()) {
        this.updateAngle();
        this.updateMove();
    }
};

TBSProjectileSprite.prototype.updateMove = function () {
    var frame = Math.round(this._speedFrame);
    if (frame >= this._trajectory.length - 1) {
        frame = this._trajectory.length - 1;
        this._finished = true;
    }
    var newPos = this._trajectory[frame];
    if (newPos !== "control") {
        this.x = newPos[0];
        this.y = newPos[1];
    }
};

TBSProjectileSprite.prototype.updateAngle = function () {
    var sx, sy, dx, dy;
    sx = this.x;
    sy = this.y;
    if (this._adaptAngle === "to_control_points") {
        var frame = Math.round(this._speedFrame);
        var controlPos;
        for (var i = frame; i < this._trajectory.length; i++) {
            if (this._trajectory[i] === "control") {
                controlPos = this._trajectory[i - 1];
                break;
            }
        }
        if (controlPos) {
            dx = controlPos[0];
            dy = controlPos[1];
        } else {
            dx = this._end[0];
            dy = this._end[1];
        }
    } else if (this._adaptAngle === "to_target") {
        dx = this._end[0];
        dy = this._end[1];
    } else if (this._adaptAngle) {
        var topFrame = parseInt(this._trajectory.length / 2);
        if (this._speedFrame > topFrame) {
            dx = this._end[0];
            dy = this._end[1];
        } else {
            var topCoord = this._trajectory[topFrame];
            dx = topCoord[0];
            dy = topCoord[1];
        }
    }
    if (dx && dy) {
        var rotation = Math.atan2(dy - sy, dx - sx);
        this.rotation = rotation;
    }
};

TBSProjectileSprite.prototype.startAnimation = function (animation) {
    animation = $dataAnimations[animation];
    var sprite = new Sprite_ProjectileAnimation();
    sprite.setup(this, animation);
    this.addChild(sprite);
    this._animationSprites.push(sprite);
};

TBSProjectileSprite.prototype.finished = function () {
    return this._finished;
};


/*-------------------------------------------------------------------------
* Sprite_ProjectileAnimation
-------------------------------------------------------------------------*/
function Sprite_ProjectileAnimation() {
    this.initialize.apply(this, arguments);
}
Sprite_ProjectileAnimation.prototype = Object.create(Sprite_Animation.prototype);
Sprite_ProjectileAnimation.prototype.constructor = Sprite_ProjectileAnimation;

Sprite_ProjectileAnimation.prototype.initialize = function () {
    Sprite_Animation.prototype.initialize.call(this);
};

Sprite_ProjectileAnimation.prototype.update = function () {
    Sprite_Animation.prototype.update.call(this);
    if (!this.isPlaying() && this._animation)
        this.setupDuration();
};

Sprite_ProjectileAnimation.prototype.setup = function (target, animation) {
    this._target = target;
    this._animation = animation;
    this._mirror = false;
    this._delay = false;
    if (this._animation) {
        this.remove();
        this.setupRate();
        this.setupDuration();
        this.loadBitmaps();
        this.createSprites();
    }
};

Sprite_ProjectileAnimation.prototype.updatePosition = function () {
    this.x = 0; //this._target.x;
    this.y = 0; //this._target.y;
};

Sprite_ProjectileAnimation.prototype.updateCellSprite = function (sprite, cell) {
    Sprite_Animation.prototype.updateCellSprite.call(this, sprite, cell);
    sprite.rotation += this._target.rotation * Math.PI / 180;
};


/*-------------------------------------------------------------------------
* Cell entity
-------------------------------------------------------------------------*/
function TBSCell(x, y) {
    this.x = x;
    this.y = y;
    this._regionId = -1;
    this._type = null;
    this._event = null;
    this._visible = false;
    this._opacity = 0;
    this._color = "";
}

TBSCell.prototype.isSame = function (otherCell) {
    return otherCell && this.x === otherCell.x && this.y === otherCell.y;
};

TBSCell.prototype.select = function () {
    BattleManagerTBS._activeCell = this;
};

TBSCell.prototype.isImpassableTile = function () {
    var x = this.x,
        y = this.y;
    if (!$gameMap.isValid(x, y)) return true;
    if (!$gameMap.isPassable(x, y, 2)) return true;
    if (!$gameMap.isPassable(x, y, 4)) return true;
    if (!$gameMap.isPassable(x, y, 6)) return true;
    if (!$gameMap.isPassable(x, y, 8)) return true;
    return false;
};

TBSCell.prototype.isObstacle = function () {
    if (this.regionId() === Lecode.S_TBS.obstacleRegionId) return true;
    if (this.regionId() === Lecode.S_TBS.freeObstacleRegionId) return true;
    if (this.isThereEntity()) return true;
    var tbsEvent = BattleManagerTBS.getTBSEventAt(this.x, this.y);
    if (tbsEvent && tbsEvent.isObstacle()) return true;
    return false;
};

TBSCell.prototype.isObstacleForLOS = function () {
    if (this.regionId() === Lecode.S_TBS.obstacleRegionId) return true;
    if (this.isThereEntity()) {
        var entity = this.getEntity();
        if (entity.isPassable()) return false;
        return true;
    }
    var tbsEvent = this.getEvent();
    if (tbsEvent && tbsEvent.isObstacleForLOS()) return true;
    return false;
};

TBSCell.prototype.isThereEntity = function () {
    return this.getEntity() != null;
};

TBSCell.prototype.getEntity = function () {
    var entities = BattleManagerTBS.allEntities();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        /*if (entity.getCell().isSame(this))
            return entity;*/
        if (entity.isOnCell(this))
            return entity;
    }
    return null;
};

TBSCell.prototype.getEvent = function () {
    return BattleManagerTBS.getTBSEventAt(this.x, this.y);
};

TBSCell.prototype.regionId = function () {
    var tbsEvent = this.getEvent();
    if (tbsEvent && tbsEvent._tileEffect && tbsEvent._tileEffect > -1) {
        return tbsEvent._tileEffect;
    }
    return this._regionId;
};

TBSCell.prototype.toCoords = function () {
    return {
        x: this.x,
        y: this.y
    };
};

/*-------------------------------------------------------------------------
* SpriteCursorTBS
-------------------------------------------------------------------------*/
function SpriteCursorTBS() {
    this.initialize.apply(this, arguments);
}

SpriteCursorTBS.prototype = Object.create(Sprite.prototype);
SpriteCursorTBS.prototype.constructor = SpriteCursorTBS;

SpriteCursorTBS.prototype.initialize = function (bitmap) {
    Sprite.prototype.initialize.call(this, bitmap);
    this.cellX = this.cellY = 0;
    this._leU_loopFlash = true;
    this._leU_loopFlashData = {
        color: [255, 255, 255, 255],
        duration: 30
    };
};

SpriteCursorTBS.prototype.setCell = function (cell) {
    var x = cell.x;
    var y = cell.y;
    this.cellX = x;
    this.cellY = y;
    x *= $gameMap.tileWidth();
    y *= $gameMap.tileHeight();
    this.x = x;
    this.y = y;
    //this.checkSizeArea();
};

SpriteCursorTBS.prototype.checkSizeArea = function () {
    var entity = this.getCell().getEntity();
    if (entity && entity === BattleManagerTBS.activeEntity()) {
        if (BattleManagerTBS._subPhase === "move") {
            var scope = entity.getSizeArea();
            if (scope.length > 1) {
                var bounds = BattleManagerTBS.getScopeBoundaries(scope);
                var w = bounds.right - bounds.left + 1;
                var h = bounds.bottom - bounds.top + 1;
                this.width = w * $gameMap.tileWidth();
                this.height = h * $gameMap.tileHeight();
            }
        }
    }
    this.width = this.height = 48;
}

SpriteCursorTBS.prototype.hide = function () {
    this.visible = false;
};

SpriteCursorTBS.prototype.show = function () {
    this.visible = true;
};

SpriteCursorTBS.prototype.getCell = function () {
    return BattleManagerTBS.getCellAt(this.cellX, this.cellY);
}

/*-------------------------------------------------------------------------
* TBSTurnOrderVisual
-------------------------------------------------------------------------*/
function TBSTurnOrderVisual() {
    this.initialize.apply(this, arguments);
}


/*-------------------------------------------------------------------------
* TBSEntity
-------------------------------------------------------------------------*/
function TBSEntity() {
    this.initialize.apply(this, arguments);

    Object.defineProperty(this, 'x', {
        get: function () {
            return this._posX;
        },
        set: function (value) {
            this.setPosition(value, this.y);
        },
        configurable: true
    });

    Object.defineProperty(this, 'y', {
        get: function () {
            return this._posY;
        },
        set: function (value) {
            this.setPosition(this.x, value);
        },
        configurable: true
    });
}

TBSEntity.prototype.initialize = function (battler, layer) {
    this._battler = battler;
    this._cell = null;
    this._moving = false;
    this._movePoints = 0;
    this._movingDistance = [0, 0];
    this._movePath = [];
    this._movingNextCell = null;
    this._moveReducePoints = false;
    this._movePerformed = false;
    this._actionPerformed = false;
    this._dead = false;
    this._flag = null;
    this._isMouseOver = false;
    this._turnHidden = false;
    this.createSprite(battler, layer);
    this.createSpriteValues();
    this.createComponents();
    this.setMovePoints();
    this.initializeSpeed();
};

TBSEntity.prototype.createSprite = function (battler, layer) {
    this._sprite = new TBSEntity_Sprite(battler, this);
    this._layer = layer;
    layer.addChild(this._sprite);
};

TBSEntity.prototype.createSpriteValues = function () {
    this._posX = 0;
    this._posY = 0;
    this._dir = 2;
    this._lastDir = 2;
    this._pose = this.defaultPose();
    this._afterPose = this.defaultPose();
    this._poseLoop = false;
    this._fixedPose = null;
};

TBSEntity.prototype.createComponents = function () {
    this._sequenceManager = new TBSSequenceManager();
};

TBSEntity.prototype.getTiedEvents = function () {
    var ids = this.battler().collectLeTBSTags("tiedEvents");
    return ids.map(function (id) {
        var e = new Game_CommonEvent(id);
        return new TBSEvent(e);
    });
};

TBSEntity.prototype.initializeSpeed = function () {
    var moveSpeed = this.battler().getLeTBSTagNumberValue("moveSpeed",Lecode.S_TBS.battlersMoveSpeed);
    this.setSpeed(moveSpeed);
};

TBSEntity.prototype.setSpeed = function (speed) {
    this._speed = speed;
};

TBSEntity.prototype.changeSpeed = function (speed) {
    this._speed += speed;
};

TBSEntity.prototype.destroy = function () {
    var sprites = this._sprite._animationSprites;
    for (var i = 0; i < sprites.length; i++) {
        var anim = sprites[i];
        BattleManagerTBS.getLayer("animations").removeChild(anim);
    }
    this._layer.removeChild(this._sprite);
};

TBSEntity.prototype.startSequence = function (id, action) {
    this._sequenceManager.start(id, this, action);
};

TBSEntity.prototype.executeSequence = function (sequence) {
    this._sequenceManager.startWithData(sequence, this);
};

TBSEntity.prototype.runningSequence = function () {
    return this._sequenceManager._sequenceName;
};

TBSEntity.prototype.callSequence = function (id) {
    if (this._sequenceManager.isRunning()) {
        this._sequenceManager.commandCall([id, 1]);
    } else {
        this.startSequence(id);
    }
};

TBSEntity.prototype.appendSequence = function (id, action) {
    if (this._sequenceManager.isRunning()) {
        this._sequenceManager.append(id, this, action);
    } else {
        this.startSequence(id, action);
    }
};

TBSEntity.prototype.unshiftSequence = function (id, action) {
    if (this._sequenceManager.isRunning()) {
        this._sequenceManager.unshift(id, this, action);
    } else {
        this.startSequence(id, action);
    }
};

TBSEntity.prototype.requestPlayPose = function () {
    this._requestPlayPose = true;
};

TBSEntity.prototype.isRequestedPosePlayed = function () {
    return !this._requestPlayPose;
};

TBSEntity.prototype.defaultPose = function () {
    return "idle";
};

TBSEntity.prototype.setPose = function (pose, afterPose) {
    this._fixedPose = null;
    this._pose = pose;
    this._afterPose = afterPose || this.defaultPose();
    this._poseLoop = (afterPose === pose);
    this._sprite.updatePose();
    this._sprite.resetFrameCount();
    this._sprite.setFixedFrame(null);
    this._sprite.updateBitmap();
    this._sprite.updatePosition();
};

TBSEntity.prototype.setFixedPose = function (pose, frame) {
    this._pose = pose;
    this._sprite.updatePose();
    if (frame === "last")
        frame = this._sprite._maxFrame[this._sprite.getPose()];
    this._fixedPose = pose;
    this._afterPose = null;
    this._poseLoop = false;
    this._sprite.resetFrameCount();
    this._sprite.setFixedFrame(Number(frame));
    this._sprite.updateBitmap();
    this._sprite.updatePosition();
};

TBSEntity.prototype.onPosePlayed = function (oldPose) {
    if (this._fixedPose) {
        this._pose = this._fixedPose;
        this._sprite.updatePose();
        return;
    }
    if (this._poseLoop) {
        this.setPose(oldPose, oldPose);
    } else {
        this.setPose(this._afterPose);
        this._afterPose = this.defaultPose();
    }
    this._requestPlayPose = false;
};

TBSEntity.prototype.setDir = function (dir) {
    if (![2, 4, 6, 8].contains(dir)) return;
    this._lastDir = this.getDir();
    this._dir = dir;
    this._sprite.update();
};

TBSEntity.prototype.getDir = function () {
    return this._dir;
};

TBSEntity.prototype.setCell = function (cell) {
    var x = cell.x * $gameMap.tileWidth();
    var y = cell.y * $gameMap.tileHeight();
    this.setPosition(x, y);
    this._cell = cell;
    if (this._event && Lecode.S_TBS.moveEntityEvents) {
        this._event.setPosition(cell.x, cell.y);
    }
};

TBSEntity.prototype.getSizeArea = function () {
    //var data = this.rpgObject().TagsLetbsBodySize;
    var bodySize = this.rpgObject().TagsLetbs.bodySizeArray;
    if (!bodySize || bodySize.length === 0)
        return [this._cell];
    var center = this._cell.toCoords();
    var w = bodySize[0];
    var h = bodySize[1];
    var scope = BattleManagerTBS.makeRectScope(center, w, h, {});
    return LeUtilities.uniqArray(scope);
};

TBSEntity.prototype.getSizeAreaModel = function () {
    var bodySize = this.rpgObject().TagsLetbs.bodySizeArray;
    if (!bodySize || bodySize.length === 0)
        return [BattleManagerTBS.getCellAt(0, 0)];
    var center = { x: 0, y: 0 };
    var w = bodySize[0];
    var h = bodySize[1];
    var scope = BattleManagerTBS.makeRectScope(center, w, h, {});
    return LeUtilities.uniqArray(scope);
};

TBSEntity.prototype.isOnCell = function (cell) {
    return BattleManagerTBS.isCellInScope(cell, this.getSizeArea());
};

TBSEntity.prototype.isStatic = function () {
    var pose = this._sprite.getPose();
    return this._sprite.isPoseStatic(pose);
};

TBSEntity.prototype.setPosition = function (x, y) {
    this._posX = x;
    this._posY = y;
};

TBSEntity.prototype.shiftPosition = function (x, y) {
    this._posX += x;
    this._posY += y;
};

TBSEntity.prototype.update = function () {
    this.checkDeath();
    this.updateMove();
    this.checkMouseEvents();
};

TBSEntity.prototype.updateSprite = function () {
    this._sprite.update();
};

TBSEntity.prototype.checkDeath = function () {
    if (!this._sequenceManager.isRunning()) {
        if (this._battler.isDead() && !this._dead)
            this.onDeath();
        if (!this._battler.isDead() && this._dead)
            this.onRevive();
    }
};

TBSEntity.prototype.onBattleStart = function () {
    this._battler.onBattleStart();
    this.setMovePoints();
};

TBSEntity.prototype.onTurnStart = function () {
    this._battler.clearResult();
    this.setMovePoints();
    this.callSequence("turn_start");
    this._turnPlayed = false;
    this._sprite._leU_loopFlash = true;
    this._sprite._leU_loopFlashData = {
        color: [255, 255, 255, 255],
        duration: 20
    };
    setTimeout(function (sprite) {
        sprite._leU_loopFlash = false;
        sprite.leU_clearFlash();
    }.bind(this, this._sprite), 1000);
};

TBSEntity.prototype.onTurnEnd = function () {
    this._battler.onTurnEnd();
    this.addPopup();
    this._battler.clearResult();
    this.setMovePoints();
    this._turnPlayed = true;
    this._movePerformed = false;
    this._actionPerformed = false;
};

TBSEntity.prototype.onDeath = function () {
    /*
    if has death sequence
        remove death state
        startSequence(death seq) <-- At the end must add dead state again
        appendSequence(dead) <-- Or at the start, add dead state here
    */
    if (this.runningSequence() === "damaged")
        this.appendSequence("dead");
    else
        this.startSequence("dead");
};

TBSEntity.prototype.validateDeath = function () {
    this._dead = true;
    BattleManagerTBS.onEntityDeath(this);
};

TBSEntity.prototype.onRevive = function () {
    this._dead = false;
    this.appendSequence("revived");
    BattleManagerTBS.onEntityRevive(this);
};

TBSEntity.prototype.onDamage = function (user) {
    this.addPopup();
    this.checkDeath();
};

TBSEntity.prototype.onActionStart = function (id, fastSequence, action) {
};

TBSEntity.prototype.onObjectEffects = function (user, obj) {
    this.applyMovePointsAlteration(obj);
};

TBSEntity.prototype.onNewState = function (state) {
    this.checkFilenameChange(state);
    this.applyMovePointsAlteration(state);
};

TBSEntity.prototype.onStateErased = function (state) {
    this.applyStateErasedAnimation(state);
    this.checkFilenameChange(state);
    this.restoreMovePointsAlteration(state);
};

TBSEntity.prototype.applyStateErasedAnimation = function (state) {
    var id = state.TagsLetbs.erasedAnimation;
    if (id) {
        this.newAnimation(id);
    }
};

TBSEntity.prototype.applyMovePointsAlteration = function (obj) {
    var main = obj.TagsLetbs.movePoints_Add || 0;
    var rate = obj.TagsLetbs.movePoints_Rate || 0;
    var nbr = rate * this.getMovePoints() + main;
    this.changeMovePoints(nbr);
};

TBSEntity.prototype.restoreMovePointsAlteration = function (obj) {
    var main = obj.TagsLetbs.movePoints_Add || 0;
    var rate = obj.TagsLetbs.movePoints_Rate || 0;
    var nbr = rate * this.getMovePoints() + main;
    this.changeMovePoints(-nbr);
};

TBSEntity.prototype.checkFilenameChange = function (state) {
    //var needChange = !!state.TagsLetbs.spriteName;
    var needChange = !!state.TagsLetbsSprite;
    if (needChange)
        this.applyFilenameChange();
};

TBSEntity.prototype.applyFilenameChange = function () {
    this.sprite().createBitmaps();
    this.sprite().resetFrameCount();
    this.sprite().updateBitmap();
    BattleManagerTBS._turnOrderVisual.refresh();
};

TBSEntity.prototype.hideTurn = function () {
    this._turnHidden = true;
};

TBSEntity.prototype.showTurn = function () {
    this._turnHidden = false;
    this._layer.addChild(this._sprite);
};

TBSEntity.prototype.isTurnHidden = function () {
    return !!this._turnHidden;
};

TBSEntity.prototype.checkMouseEvents = function () {
    var triggered = false;
    if (this.isMouseOverMe()) {
        if (!this._isMouseOver) {
            this._isMouseOver = true;
            this.onMouseOver();
        }
        this.whileMouseOver();
    }
    if (!this.isMouseOverMe()) {
        if (this._isMouseOver) {
            this.onMouseOut();
        }
        this._isMouseOver = false;
    }
};

TBSEntity.prototype.isMouseOverMe = function () {
    var data = TouchInput._leTBSMoveData;
    return this._sprite.getBounds().contains(data.x, data.y);
};

TBSEntity.prototype.onMouseOver = function () {

};

TBSEntity.prototype.onMouseOut = function () {

};

TBSEntity.prototype.whileMouseOver = function () {

};

TBSEntity.prototype.lookAt = function (cell) {
    var downD = cell.y - this._cell.y;
    var upD = this._cell.y - cell.y;
    var rightD = cell.x - this._cell.x;
    var leftD = this._cell.x - cell.x;
    var maxD = LeUtilities.getMaxInArray([downD, upD, rightD, leftD]);
    switch (maxD) {
        case downD:
            this.setDir(2);
            break;
        case upD:
            this.setDir(8);
            break;
        case leftD:
            this.setDir(4);
            break;
        case rightD:
            this.setDir(6);
            break;
    }
};

TBSEntity.prototype.lookAway = function (cell) {
    this.lookAt(cell);
    switch (this.getDir()) {
        case 2:
            this.setDir(8);
            break;
        case 4:
            this.setDir(6);
            break;
        case 6:
            this.setDir(4);
            break;
        case 8:
            this.setDir(2);
            break;
    }
};

TBSEntity.prototype.getDirectionTo = function (cell) {
    var oldDir = this.getDir();
    this.lookAt(cell);
    var dir = this.getDir();
    this.setDir(oldDir);
    return dir;
};

TBSEntity.prototype.getDirectionAwayFrom = function (cell) {
    var oldDir = this.getDir();
    this.lookAway(cell);
    var dir = this.getDir();
    this.setDir(oldDir);
    return dir;
};

TBSEntity.prototype.startShake = function (power, duration) {
    this._sprite._shakeEffect = {
        power: power,
        duration: duration
    };
};

TBSEntity.prototype.lookClosestBattler = function (entities) {
    if (entities.length === 0) return;
    var entity = LeUtilities.closestByDistance(this, entities);
    var cell = entity.getCell();
    this.lookAt(cell);
};

TBSEntity.prototype.processMovement = function (path, freeMove) {
    if (!path || path.length === 0) return;
    this._moving = true;
    this._movePath = path;
    this._movePath.reverse();
    this.setPose("move", "move");
    this._moveReducePoints = !freeMove;
    this._moveUpdateDir = true;
};

TBSEntity.prototype.processMovementNear = function (cell, maxPM, freeMove) {
    var destCell = BattleManagerTBS.getCellNear(this.getCell(), cell, maxPM);
    this.processMovementTo(destCell, maxPM, freeMove);
};

TBSEntity.prototype.processMovementAway = function (cell, maxPM, freeMove) {
    var destCell = BattleManagerTBS.getCellAway(this.getCell(), cell, maxPM);
    this.processMovementTo(destCell, maxPM, freeMove);
};

TBSEntity.prototype.processMovementTo = function (cell, maxPM, freeMove) {
    var sx = this._cell.x;
    var sy = this._cell.y;
    var dx = cell.x;
    var dy = cell.y;
    var path = BattleManagerTBS.getPathFromAToB(sx, sy, dx, dy, "walkable", []);
    if (path.length <= maxPM)
        this.processMovement(path, freeMove);
};

TBSEntity.prototype.processJump = function (destCell, height) {
    var sx = this.getCell().x * $gameMap.tileWidth();
    var sy = this.getCell().y * $gameMap.tileHeight();
    var dx = destCell.x * $gameMap.tileWidth();
    var dy = destCell.y * $gameMap.tileHeight();
    var trajectory = BattleManagerTBS.makeTrajectory(sx, sy, dx, dy, height, 60, "normal_jump");
    this.followTrajectory(trajectory, destCell);
};

TBSEntity.prototype.processJumpNear = function (cell, maxPM, height) {
    var destCell = BattleManagerTBS.getCellNear(this.getCell(), cell, maxPM);
    this.processJumpTo(destCell, maxPM, height);
};

TBSEntity.prototype.processJumpAway = function (cell, maxPM, height) {
    var destCell = BattleManagerTBS.getCellAway(this.getCell(), cell, maxPM);
    this.processJumpTo(destCell, maxPM, height);
};

TBSEntity.prototype.processJumpTo = function (cell, maxPM, height) {
    var sx = this._cell.x;
    var sy = this._cell.y;
    var dx = cell.x;
    var dy = cell.y;
    var path = BattleManagerTBS.getPathFromAToB(sx, sy, dx, dy, "free", []);
    if (path.length <= maxPM)
        this.processJump(cell, height);
};

TBSEntity.prototype.forceMoveStraight = function (nbrCells, checkCollision) {
    if (nbrCells <= 0) return;
    this._movePath = [];
    var cx = this._cell.x;
    var cy = this._cell.y;
    this._collisionData = {
        distance: nbrCells,
        covered: 0,
        dir: this.getDir(),
        endCell: null
    };
    for (var i = 0; i < nbrCells; i++) {
        var cell = this.getForwardCell(cx, cy);
        if (!cell || cell.isObstacle()) { //  || cell.isImpassableTile()
            this._collisionData.endCell = cell;
            break;
        }
        this._collisionData.covered++;
        this._movePath.push(cell);
        switch (this.getDir()) {
            case 2:
                cy++;
                break;
            case 4:
                cx--;
                break;
            case 6:
                cx++;
                break;
            case 8:
                cy--;
                break;
        }
    }
    if (!checkCollision) this._collisionData = null;
    if (this._movePath.length === 0) return;
    this._moving = true;
    this._movingStraight = true;
    this._movePath.reverse();
    this._moveReducePoints = false;
    this._moveUpdateDir = true;
};

TBSEntity.prototype.forcePush = function (user, sourceCell, distance, obj, damage) {
    if (this.isImmuneToKnockback())
        return;
    distance += user.getKnockbackBonus(obj) - this.getKnockbackReduction(obj);
    var old = this.getDir();
    this.lookAway(sourceCell);
    this.forceMoveStraight(distance, damage);
    this.setDir(old);
    this._moveUpdateDir = false;
    if (this._collisionData) {
        this._collisionData.user = user;
        this._collisionData.obj = obj;
    }

    if (this._movePath.length === 0 && this._collisionData)
        BattleManagerTBS.processCollisionEffects(this);
};

TBSEntity.prototype.forcePull = function (user, sourceCell, distance, obj, damage) {
    if (this.isImmuneToKnockback())
        return;
    var old = this.getDir();
    this.lookAt(sourceCell);
    this.forceMoveStraight(distance, damage);
    this.setDir(old);
    this._moveUpdateDir = false;
    if (this._collisionData) {
        this._collisionData.user = user;
        this._collisionData.obj = obj;
    }

    if (this._movePath.length === 0 && this._collisionData)
        BattleManagerTBS.processCollisionEffects(this);
};

TBSEntity.prototype.reachEntity = function (entity, type) {
    var cells = [];
    switch (type) {
        case "back":
            cells.push(entity.getBackwardCell());
            break;
        case "front":
            cells.push(entity.getForwardCell());
            break;
        case "side":
            cells = cells.concat(entity.getSideCells());
            break;
        case "random":
            cells.push(entity.getBackwardCell());
            cells.push(entity.getForwardCell());
            cells = cells.concat(entity.getSideCells());
            break;
    }
    var dest = LeUtilities.getXRandomValuesInArray(cells, 1)[0];
    if (dest && !dest.isObstacle()) {
        this.setCell(dest);
        return true;
    }
    return false;
};

TBSEntity.prototype.getForwardCell = function (cx, cy) {
    cx = cx || this._cell.x;
    cy = cy || this._cell.y;
    switch (this.getDir()) {
        case 2:
            return BattleManagerTBS.getCellAt(cx, cy + 1);
        case 4:
            return BattleManagerTBS.getCellAt(cx - 1, cy);
        case 6:
            return BattleManagerTBS.getCellAt(cx + 1, cy);
        case 8:
            return BattleManagerTBS.getCellAt(cx, cy - 1);
    }
    return null;
};

TBSEntity.prototype.getBackwardCell = function () {
    var cell = this.getForwardCell();
    if (cell) {
        this.lookAway(cell);
        var backCell = this.getForwardCell();
        this.lookAt(cell);
        return backCell;
    }
    return null;
};

TBSEntity.prototype.getSideCells = function () {
    var cell = this.getForwardCell();
    if (!cell) {
        return; //- WIP if forward cell is null, use back cell.
    }
    var sideCell1;
    var sideCell2;
    if (this.getDir() === 8 || this.getDir() === 2) {
        sideCell1 = BattleManagerTBS.getCellAt(cell.x - 1, cell.y - 1);
        sideCell2 = BattleManagerTBS.getCellAt(cell.x + 1, cell.y - 1);
    } else {
        sideCell1 = BattleManagerTBS.getCellAt(cell.x - 1, cell.y - 1);
        sideCell2 = BattleManagerTBS.getCellAt(cell.x - 1, cell.y + 1);
    }
    return [sideCell1, sideCell2];
};

TBSEntity.prototype.updateMove = function () {
    if (!this._moving) return;
    if (!this._movingNextCell) {
        this._movingNextCell = this._movePath.pop();
        this._movingDistance = [0, 0];
    }
    var cell = this._movingNextCell;
    var oldDir = this.getDir();
    this.lookAt(cell);
    this.moveForward(cell);
    if (!this._moveUpdateDir)
        this.setDir(oldDir);
    if (this._cell.x == cell.x && this._cell.y == cell.y) {
        var stop = this.onCellCovered();
        if (this._movePath.length === 0 || stop)
            this.onMoveEnd(!stop);
    }
};

TBSEntity.prototype.onCellCovered = function () {
    BattleManagerTBS.centerCell(this.getCell());
    var stop = BattleManagerTBS.executeEventsByStep(this);
    this._movingNextCell = null;
    if (this._moveReducePoints) {
        this._movePoints--;
        if (this.getMovePoints() === 0)
            return true;
    }
    //if (BattleManagerTBS.anySequenceRunning()) return true;
    // When returning true, the movement is stoped
    return stop;
};

TBSEntity.prototype.moveForward = function (cell) {
    var speed = this._speed;
    var dir = this._sprite._dir;
    switch (dir) {
        case 2:
            this.shiftPosition(0, speed);
            this._movingDistance[1] += speed;
            break;
        case 4:
            this.shiftPosition(-speed, 0);
            this._movingDistance[0] += speed;
            break;
        case 6:
            this.shiftPosition(speed, 0);
            this._movingDistance[0] += speed;
            break;
        case 8:
            this.shiftPosition(0, -speed);
            this._movingDistance[1] += speed;
            break;
    }
    if (this._movingDistance[0] >= $gameMap.tileWidth() || this._movingDistance[1] >= $gameMap.tileHeight())
        this.setCell(cell);
};

TBSEntity.prototype.onMoveEnd = function () {
    this._moving = false;
    if (this._dead)
        this.setPose("dead", "dead");
    else
        this.setPose(this.defaultPose());
    this._moveReducePoints = false;

    if (this._collisionData)
        BattleManagerTBS.processCollisionEffects(this);
    this._collisionData = null;
    this._movingStraight = false;
    BattleManagerTBS.executeEventsByTouch(this);
};

TBSEntity.prototype.teleport = function (cell) {
    this.setCell(cell);
};

TBSEntity.prototype.switchCellWith = function (entity) {
    var old = this.getCell();
    this.teleport(entity.getCell());
    entity.teleport(old);
};

TBSEntity.prototype.followTrajectory = function (trajectory, cell) {
    this._sprite.setTrajectory(trajectory, cell);
};

TBSEntity.prototype.setMovePoints = function () {
    this._movePoints = this.battler().getLeTBSTagNumberValue("movePoints", Lecode.S_TBS.defaultMovePoints);
    if (this._movePoints < 0)
        this._movePoints = 0;
};

TBSEntity.prototype.changeMovePoints = function (plus) {
    this._movePoints += plus;
};

TBSEntity.prototype.getMovePoints = function () {
    if (this.oneTimeMove() && this._movePerformed) return 0;
    return this._movePoints.clamp(0, this._movePoints);
};

TBSEntity.prototype.canMoveCommand = function () {
    if (this.getMovePoints() === 0) return false;
    return true;
};

TBSEntity.prototype.canAttackCommand = function () {
    if (!this._battler.canAttack()) return false;
    if (!this.canObjCommand()) return false;
    return true;
};

TBSEntity.prototype.canSkillCommand = function () {
    if (!this.canObjCommand()) return false;
    return true;
};

TBSEntity.prototype.canItemCommand = function () {
    if (!this.canObjCommand()) return false;
    return true;
};

TBSEntity.prototype.canObjCommand = function () {
    if (this.oneTimeOffense() && this._actionPerformed) return false;
    return true;
};

TBSEntity.prototype.playableByAI = function () {
    return this.battler().isEnemy() || this.battler().isConfused() || !this.battler().canMove()
        || this.aiControl();
};

//---

TBSEntity.prototype.aiControl = function () {
    return this.battler().hasLeTBSTag("aiControl");
};

TBSEntity.prototype.getAttackAnimation = function () {
    if (this._battler.isActor()) {
        return this._battler.attackAnimationId1();
    } else {
        return this._battler.enemy().TagsLetbs.atkAnim || Lecode.S_TBS.defaultAttackAnimation;
    }
};

TBSEntity.prototype.getAttackScopeData = function () {
    if (this._battler.isEnemy())
        return this._battler.enemy().TagsLetbs.atkScope || Lecode.S_TBS.defaultAttackScope;
    else {
        for (var i = 0; i < this._battler.weapons().length; i++) {
            var weapon = this._battler.weapons()[i];
            if (weapon && weapon.TagsLetbs.scope)
                return weapon.TagsLetbs.scope;
        }
        return this._battler.actor().TagsLetbs.atkScope || Lecode.S_TBS.defaultAttackScope;
    }
};

TBSEntity.prototype.getObjectScopeData = function (obj) {
    var defaultScope = DataManager.isSkill(obj) ? Lecode.S_TBS.defaultSkillScope : Lecode.S_TBS.defaultItemScope;
    return obj.TagsLetbs.scope || defaultScope;
};

TBSEntity.prototype.getAttackAoEData = function () {
    if (this._battler.isEnemy())
        return this._battler.enemy().TagsLetbs.atkAoe || Lecode.S_TBS.defaultAttackAoE;
    else {
        for (var i = 0; i < this._battler.weapons().length; i++) {
            var weapon = this._battler.weapons()[i];
            if (weapon && weapon.TagsLetbs.aoe)
                return weapon.TagsLetbs.aoe;
        }
        return this._battler.actor().TagsLetbs.atkAoe || Lecode.S_TBS.defaultAttackAoE;
    }
};

TBSEntity.prototype.getObjectAoEData = function (obj) {
    var defaultAoe = DataManager.isSkill(obj) ? Lecode.S_TBS.defaultSkillAoE : Lecode.S_TBS.defaultItemAoE;
    return obj.TagsLetbs.aoe || defaultAoe;
};

TBSEntity.prototype.getMoveScopeData = function () {
    return this.getMoveScopeRawData().replace("_mp_", String(this.getMovePoints()));
};

TBSEntity.prototype.getMoveScopeRawData = function () {
    return this.battler().getLeTBSTagStringValue("moveScope", Lecode.S_TBS.defaultMoveScope);
};

TBSEntity.prototype.getMoveScopeParamData = function () {
    return this.battler().getLeTBSTagStringValue("moveScopeOptions");
};

TBSEntity.prototype.getWeaponSequenceData = function () {
    if (this._battler.isEnemy())
        return this._battler.enemy().TagsLetbs.atkSequenceData || Lecode.S_TBS.defaultAttackSequence;
    else {
        for (var i = 0; i < this._battler.weapons().length; i++) {
            var weapon = this._battler.weapons()[i];
            if (weapon && weapon.TagsLetbs.sequence)
                return weapon.TagsLetbs.sequence;
        }
        return this._battler.actor().TagsLetbs.atkSequenceData || Lecode.S_TBS.defaultAttackSequence;
    }
};

TBSEntity.prototype.getWeaponFastSequence = function () {
    if (this._battler.isEnemy())
        return [];
    else {
        for (var i = 0; i < this._battler.weapons().length; i++) {
            var weapon = this._battler.weapons()[i];
            if (weapon && weapon.TagsLetbsSequence)
                return weapon.TagsLetbsSequence;
        }
        return [];
    }
};

TBSEntity.prototype.getObjectSequenceData = function (obj) {
    var defaultSeqId = DataManager.isSkill(obj) ? Lecode.S_TBS.defaultSkillSequence : Lecode.S_TBS.defaultItemSequence;
    return obj.TagsLetbs.sequence || defaultSeqId;
};

TBSEntity.prototype.getObjectFastSequence = function (obj) {
    return obj.TagsLetbsSequence;
};

TBSEntity.prototype.overloadedSequence = function (seqId) {
    var data = this.battler().getLeTBSTagObjectValue("sequence");
    return data[seqId] || seqId;
};

TBSEntity.prototype.passAfterObjUse = function (obj) {
    if (DataManager.isSkill(obj)) {
        if (this._battler.isEnemy())
            return !!this._battler.hasLeTBSTag("passOnAtkUse");
        if (obj.id == this._battler.attackSkillId()) {
            if (this._battler.weapons().length > 0)
                return !!this._battler.weapons()[0].TagsLetbs.passOnUse;
        }
    }
    return this._battler.hasLeTBSTag("passOnUse", obj);
};

TBSEntity.prototype.oneTimeMove = function () {
    return !!this.battler().hasLeTBSTag("oneTimeMove") || Lecode.S_TBS.oneTimeMove;
};

TBSEntity.prototype.oneTimeOffense = function () {
    return !!this.battler().hasLeTBSTag("oneTimeOffense") || Lecode.S_TBS.oneTimeOffense;
};

TBSEntity.prototype.getCollapseAnimation = function () {
    return this.battler().getLeTBSTagNumberValue("collapseAnim", Lecode.S_TBS.collapseAnimation);
};

TBSEntity.prototype.getAiPattern = function () {
    return this.battler().getLeTBSTagStringValue("aiPattern", Lecode.S_TBS.defaultAiPattern);
};

TBSEntity.prototype.isPassableOnDeath = function () {
    return this.hasNoCorpse() || this.battler().hasLeTBSTag("passableOnDeath");
};

TBSEntity.prototype.isPassable = function () {
    return (this._battler.isDead() && this.isPassableOnDeath()) || this.battler().hasLeTBSTag("passable");
};

TBSEntity.prototype.entitiesCanLayOnMe = function () {
    if (this._battler.isDead()) {
        if (this.hasNoCorpse()) return true;
        if (this._sprite.opacity === 0) return true;
        return this.battler().hasLeTBSTag("canStayOnMeOnDeath");
    }
    return this.battler().hasLeTBSTag("canStayOnMe");
};

TBSEntity.prototype.hasNoCorpse = function () {
    return !this.sprite().isValidPose("dead");
};

TBSEntity.prototype.hasBlankSprite = function () {
    return this.battler().hasLeTBSTag("blankSprite");
};

TBSEntity.prototype.isFocusedByAI = function (type) {
    type = type.trim();
    var obj = this.battler().getLeTBSTagObjectValue("focusedByAiFor", {});
    return obj[type];
};

TBSEntity.prototype.getSpriteScaleX = function () {
    var values = this.battler().getLeTBSTagArrayValue("spriteScale", [1.0, 1.0]);
    return values[0];
};

TBSEntity.prototype.getSpriteScaleY = function () {
    var values = this.battler().getLeTBSTagArrayValue("spriteScale", [1.0, 1.0]);
    return values[1];
};

TBSEntity.prototype.getSpriteTone = function () {
    return this.battler().getLeTBSTagArrayValue("spriteTone", [0, 0, 0, 0]);
};

TBSEntity.prototype.getSpriteHue = function () {
    return this.battler().getLeTBSTagNumberValue("spriteHue", 0);
};

TBSEntity.prototype.getSpriteOpacity = function () {
    return this.battler().getLeTBSTagNumberValue("spriteOpacity", 255);
};

TBSEntity.prototype.getLoopAnimations = function () {
    return this.battler().collectLeTBSTags("loopAnimation");
};

TBSEntity.prototype.startFlash = function (colorArray, duration, loop) {
    if (loop)
        this._sprite.leU_startLoopFlash(colorArray, duration);
    else
        this._sprite.leU_startFlash(colorArray, duration);
};

TBSEntity.prototype.stopFLash = function () {
    this._sprite.leU_endLoopFlash();
    this._sprite.leU_clearFlash();
};

TBSEntity.prototype.getCollisionDamageBonus = function (damage, item) {
    var bonus = this.battler().getLeTBSTagNumberValue("collisionDmgBonus", 0);
    bonus += this.battler().getLeTBSTagNumberValue("collisionDmgBonusRate", 0.0) * damage;
    return bonus;
};

TBSEntity.prototype.getCollisionDamageReduction = function (damage, item) {
    var reduction = this.battler().getLeTBSTagNumberValue("collisionDmgReduction", 0);
    reduction += this.battler().getLeTBSTagNumberValue("collisionDmgReductionRate", 0.0) * damage;
    return reduction;
};

TBSEntity.prototype.getDirectionalDmgBonus = function (type, item) {
    type = type.trim();
    var obj = this.battler().getLeTBSTagObjectValue("dirDmgBonus", {}, item);
    return obj[type] || 0;
};

TBSEntity.prototype.getDirectionalDmgReduction = function (type, item) {
    type = type.trim();
    var obj = this.battler().getLeTBSTagObjectValue("dirDmgReduction", {}, item);
    return obj[type] || 0;
};

TBSEntity.prototype.isImmuneToKnockback = function () {
    return this.battler().hasLeTBSTag("immuneKnockback");
};

TBSEntity.prototype.getKnockbackBonus = function (item) {
    return this.battler().getLeTBSTagNumberValue("knockbackBonus", 0, item);
};

TBSEntity.prototype.getKnockbackReduction = function (item) {
    return this.battler().getLeTBSTagNumberValue("knockbackReduction", 0, item);
};

TBSEntity.prototype.filenameID = function () {
    var battler = this.battler();
    var def = battler.isActor() ? battler.name() : battler.originalName();
    return battler.getLeTBSTagStringValue("spriteName", def);
};

TBSEntity.prototype.addPopup = function () {
    this._sprite.addPopup();
};

TBSEntity.prototype.newAnimation = function (id, mirror, delay, isLoop) {
    if (id === "collapse_anim")
        id = this.getCollapseAnimation();
    this._sprite.newAnimation(id, mirror, delay, isLoop);
};

TBSEntity.prototype.fadeIn = function (duration) {
    duration = duration * 1000 || 1000;
    this._sprite.opacity = 0;
    LeUtilities.tweenProperty(this._sprite, "opacity", this.defaultOpacity(), duration).start();
};

TBSEntity.prototype.fadeOut = function (duration) {
    duration = duration * 1000 || 1000;
    this._sprite.opacity = this.defaultOpacity();
    LeUtilities.tweenProperty(this._sprite, "opacity", 0, duration).start();
};

TBSEntity.prototype.defaultOpacity = function () {
    return 255;
};

TBSEntity.prototype.startBalloon = function (id) {
    this._sprite.startBalloon(id);
};

TBSEntity.prototype.startWeaponAnimation = function (type, wType) {
    var battler = this.battler();
    var weapon = wType === "main_hand" ? battler.weapons()[0]
        : (wType === "off_hand" ? battler.weapons()[1] : null);
    var data = Lecode.S_TBS.Config.Weapon_Anims[type].slice();
    if (weapon && data) {
        var weaSprite = weapon.TagsLetbs.weaponSprite;
        this.sprite().startWeaponAnimation(data, weaSprite);
    }
};

TBSEntity.prototype.attachWindow = function (win) {
    var x = this._posX - win.windowWidth() / 2;
    var y = this._posY - win.windowHeight();
    win.x = x + this.width() / 2;
    win.y = y;
    var maxW = $gameMap.width() * $gameMap.tileWidth();
    if (win.y < 0) win.y = 0;
    if (win.x < 0) win.x = 0
    if ((win.x + win.width) > maxW)
        win.x = maxW - win.width;
};

TBSEntity.prototype.battler = function () {
    return this._battler;
};

TBSEntity.prototype.sprite = function () {
    return this._sprite;
};

TBSEntity.prototype.width = function () {
    return this._sprite.width;
};

TBSEntity.prototype.height = function () {
    return this._sprite.height;
};

TBSEntity.prototype.getCell = function () {
    return this._cell;
};

TBSEntity.prototype.isMoving = function () {
    return this._moving;
};

TBSEntity.prototype.rpgObject = function () {
    return this.battler().isActor() ? this.battler().actor() : this.battler().enemy();
};

/*-------------------------------------------------------------------------
* TBSEntity_Sprite
-------------------------------------------------------------------------*/
function TBSEntity_Sprite() {
    this.initialize.apply(this, arguments);
}

TBSEntity_Sprite.prototype = Object.create(Sprite_Base.prototype);
TBSEntity_Sprite.prototype.constructor = TBSEntity_Sprite;

TBSEntity_Sprite.prototype.initialize = function (battler, entity) {
    Sprite_Base.prototype.initialize.call(this);
    this._battler = battler;
    this._entity = entity;
    this.anchor.x = 0.5;
    this.anchor.y = 1;
    this.initializeProperties();
    this.initializeFrameDelay();
    this.createBitmaps();
    this.createWeaponSprite();
};

TBSEntity_Sprite.prototype.initializeProperties = function () {
    this._frameCount = 0;
    this._bitmaps = {};
    this._maxFrame = {};
    this._nbrLines = {};
    this._fixedFrame = null;
    this._updateCount = 0;
    this._poses = [];
    this._staticPoses = {};
    this._frameLoaded = 0;
    this._filenameID = null;
    this._popups = [];
    this._shakeEffect = {
        power: 0,
        duration: 0
    };
    this._trajectoryIndex = 0;
    this._trajectory = [];
    this._trajectoryEndCell = null;
    this._bodyAnimRandomized = {};
};

TBSEntity_Sprite.prototype.initializeFrameDelay = function () {
    this.setFrameDelay(Lecode.S_TBS.battlersFrameDelay);
};

TBSEntity_Sprite.prototype.setFrameDelay = function (delay) {
    this._frameDelay = delay;
};

TBSEntity_Sprite.prototype.changeFrameDelay = function (delay) {
    this._frameDelay += delay;
};

TBSEntity_Sprite.prototype.onPosePlayed = function () {
    this._frameCount = 0;
    this._entity.onPosePlayed(this.getPose());
};

TBSEntity_Sprite.prototype.resetFrameCount = function () {
    this._frameCount = 0;
};

TBSEntity_Sprite.prototype.setFixedFrame = function (frame) {
    this._fixedFrame = frame;
};

TBSEntity_Sprite.prototype.setTrajectory = function (trajectory, cell) {
    this._trajectoryIndex = 0;
    this._trajectory = trajectory;
    this._trajectoryEndCell = cell;
    var opts = { easing: TWEEN.Easing.Sinusoidal.In };
    var sx = this._trajectory[0][0];
    var sy = this._trajectory[0][1];
    var dx = this._trajectory[this._trajectory.length - 2][0];
    var dy = this._trajectory[this._trajectory.length - 2][1];
    var distance = LeUtilities.distanceBetween({ x: sx, y: sy }, { x: dx, y: dy });
    var speed = 10;
    var time = (distance * 30) / speed;
    LeUtilities.tweenProperty(this, "_trajectoryIndex", this._trajectory.length - 1, time, opts)
        .start();
};

TBSEntity_Sprite.prototype.createBitmaps = function () {
    var battler = this._battler;
    var config = this.getConfig();
    var hue = this._entity.getSpriteHue();
    this.bitmap = new Bitmap(48, 48); //- Prevents anims misplacement before bitmaps loaded

    if (config.length === 0) {
        throw new Error("[LeTBS] - The battler '" + battler.name() + "' has no sprite configuration!");
    }

    config.forEach(function (poseConfig) {
        this.processBitmapsConfig(poseConfig, hue);
    }.bind(this));
};

TBSEntity_Sprite.prototype.processBitmapsConfig = function (poseConfig, hue) {
    var pose = poseConfig.pose;
    var data = poseConfig.data;
    this._poses.push(pose);

    if (data.match(/blank_sprite/i)) {
        this._maxFrame[pose] = 0;
        this._nbrLines[pose] = 1;
        this._bitmaps[pose] = new Bitmap(48, 48);
        this._frameLoaded++;
        return;
    } else if (data.match(/static/i)) {
        this._maxFrame[pose] = 0;
        this._nbrLines[pose] = 1;
        var filename = this.filenameID();
        if (data.match(/static\s\,\s?(.+)/i))
            filename = RegExp.$1.trim();
        this._bitmaps[pose] = ImageManager.loadLeTBSBattler(filename, hue);
        this._frameLoaded++;
        this._staticPoses[pose] = true;
        return;
    }

    var array = data.split(",");
    var filename = this.filenameID() + array[0].trim();
    var nbrFrames = Number(array[1].trim());
    var fullBitmap = ImageManager.loadLeTBSBattler(filename, hue);
    fullBitmap.addLoadListener(this.createPoseBitmaps.bind(this, fullBitmap, pose, nbrFrames));
};

TBSEntity_Sprite.prototype.createPoseBitmaps = function (fbitmap, pose, nbrFrames) {
    this._maxFrame[pose] = nbrFrames - 1;
    this._nbrLines[pose] = 4;
    this._bitmaps[pose] = fbitmap;
    this._frameLoaded++;
};

TBSEntity_Sprite.prototype.createWeaponSprite = function () {
    this._weaponSprite = new Sprite();
    this._weaponSpriteAnim = {
        data: [],
        index: 0,
        tween: null
    };
    this.addChild(this._weaponSprite);
};

TBSEntity_Sprite.prototype.hasTrajectory = function () {
    return !!this._trajectory[Math.round(this._trajectoryIndex)];
};

TBSEntity_Sprite.prototype.update = function () {
    Sprite_Base.prototype.update.call(this);
    if (!this.isReady()) return;
    this.updateDirection();
    this.updatePose();
    this.updateFrameDelay();
    this.updatePosition();
    this.updatePopups();
    this.updateSpriteEffects();
    this.checkLoopAnimations();
    this.updateBalloon();
    this.updateWeaponSprite();
};

TBSEntity_Sprite.prototype.updateBitmap = function () {
    var pose = this.getPose();
    this.bitmap = this._bitmaps[pose];
    if (this.bitmap) {
        var w = this.bitmap.width / (this._maxFrame[pose] + 1);
        var h = this.bitmap.height / this._nbrLines[pose];
        var x;
        var y;
        var frame = this._fixedFrame != null ? this._fixedFrame : this._frameCount;
        x = w * frame;
        y = this._nbrLines[pose] < 4 ? 0 : (h * this._dir) / 2 - h;
        this.setFrame(x, y, w, h);
    }
};

TBSEntity_Sprite.prototype.updateFrameCount = function () {
    var pose = this.getPose();
    if (this._frameCount > this._maxFrame[pose]) {
        this.onPosePlayed();
    } else {
        this._frameCount++;
    }
};

TBSEntity_Sprite.prototype.updateSpriteEffects = function () {
    var entity = this._entity;
    //this.scale.x = entity.getSpriteScaleX();
    //this.scale.y = entity.getSpriteScaleY();
    this.setColorTone(entity.getSpriteTone());
    //this.opacity = entity.getSpriteOpacity();
};

TBSEntity_Sprite.prototype.updateFrameDelay = function () {
    this._updateCount++;
    if (this._updateCount === this._frameDelay) {
        this._updateCount = 0;
        this.onNextFrame();
    }
};

TBSEntity_Sprite.prototype.onNextFrame = function () {
    this.updateBitmap();
    this.updateFrameCount();
};

TBSEntity_Sprite.prototype.updateDirection = function () {
    this._dir = this._entity._dir;
};

TBSEntity_Sprite.prototype.updatePose = function () {
    this._pose = this._entity._pose;
};

TBSEntity_Sprite.prototype.updatePosition = function () {
    this.updateTrajectoryMove();
    this.x = this._entity._posX;
    this.y = this._entity._posY;
    if (this.bitmap) {
        //var bounds = this.getBounds();
        var w = this.width;
        var h = this.height;
        if (this.isPoseStatic(this.getPose())) {
            this.x += w / 2;
            this.y += h / 2;
        } else {
            this.x += $gameMap.tileWidth() / 2;
            this.y += $gameMap.tileHeight();
        }
    }
    this.updateShakeEffect();
};

TBSEntity_Sprite.prototype.updateTrajectoryMove = function () {
    if (this.hasTrajectory()) {
        var index = Math.round(this._trajectoryIndex);
        var pos = this._trajectory[index];
        if (pos !== "control") {
            this._entity.setPosition(Math.round(pos[0]), Math.round(pos[1]));
        }
        if (index === this._trajectory.length - 1) {
            this._trajectory = [];
            this._entity.teleport(this._trajectoryEndCell);
        }
    }
};

TBSEntity_Sprite.prototype.updateShakeEffect = function () {
    var min = this._shakeEffect.power * 0.6;
    var max = this._shakeEffect.power * 1.6;
    var d = this._shakeEffect.duration--;
    if (d > 0) {
        this.x += LeUtilities.randValueBetween(min, max) * LeUtilities.randValueBetween(-1, 1);
        this.y += LeUtilities.randValueBetween(min, max) * LeUtilities.randValueBetween(-1, 1);
    }
};

TBSEntity_Sprite.prototype.updatePopups = function () {
    if (this._popups.length === 0) return;
    this._popups.forEach(function (popup) {
        popup.update();
    }.bind(this));
    if (!this._popups[0].isPlaying()) {
        this.removePopup(this._popups[0]);
    }
};

TBSEntity_Sprite.prototype.removePopup = function (popup) {
    BattleManagerTBS.getLayer("movableInfo").removeChild(popup);
    this._popups.shift();
};

TBSEntity_Sprite.prototype.addPopup = function () {
    var sprite = new Sprite_Damage();
    sprite.x = this.x;
    sprite.y = this.y - this.height;
    sprite.setup(this._battler);
    this._popups.push(sprite);
    BattleManagerTBS.getLayer("movableInfo").addChild(sprite);
};

TBSEntity_Sprite.prototype.newAnimation = function (id, mirror, delay, isLoop) {
    if (id <= 0) return;
    var sprite = new Sprite_TBSEntityAnimation();
    sprite._isLoopAnim = isLoop;
    sprite.setup(this, $dataAnimations[id], mirror, delay);
    BattleManagerTBS.getLayer("animations").addChild(sprite);
    this._animationSprites.push(sprite);
};

TBSEntity_Sprite.prototype.checkLoopAnimations = function () {
    var anims = this._entity.getLoopAnimations();
    var bodyAnim = this._entity.battler().getLeTBSTagObjectValue("bodyAnim", {})[this.getPose()];
    var bodyAnims = LeUtilities.stringToArray(bodyAnim);
    anims = anims.concat(this.randomizeBodyAnim(bodyAnims));
    var exists = {};
    anims.forEach(function (id) {
        exists[id] = false;
    });
    this._animationSprites.forEach(function (sprite) {
        for (var i = 0; i < anims.length; i++) {
            if (sprite._animation.id === anims[i] && sprite.isPlaying())
                exists[anims[i]] = true;
        }
    });
    anims.forEach(function (id) {
        if (!exists[id]) {
            this.newAnimation(id, false, 0, true);
        }
    }.bind(this));
};

TBSEntity_Sprite.prototype.randomizeBodyAnim = function (array) {
    var anim = LeUtilities.getRandomValueInArray(array);
    if (!anim) return [];
    var randomized = this._bodyAnimRandomized[this.getPose()];
    if (!randomized) {
        this._bodyAnimRandomized[this.getPose()] = anim;
        return [anim];
    }
    return [randomized];
};

TBSEntity_Sprite.prototype.isReady = function () {
    return this._frameLoaded === this._poses.length;
};

TBSEntity_Sprite.prototype.getPose = function () {
    return this.isValidPose(this._pose) ? this._pose : this._entity.defaultPose();
};

TBSEntity_Sprite.prototype.isPoseStatic = function (pose) {
    return !!this._staticPoses[pose];
};

TBSEntity_Sprite.prototype.getConfig = function () {
    var battler = this._battler;
    var object = battler.rpgObject().TagsLetbsSprite.pose;
    var config = [];
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            var element = object[key];
            config.push({
                pose: key,
                data: element
            });
        }
    }
    return config;
};

TBSEntity_Sprite.prototype.isValidPose = function (pose) {
    return this._poses.indexOf(pose) >= 0;
};

TBSEntity_Sprite.prototype.filenameID = function () {
    return this._entity.filenameID();
};

TBSEntity_Sprite.prototype.isAnimationPlaying = function () {
    return this._animationSprites.filter(function (sprite) {
        return !sprite._isLoopAnim;
    }).length > 0;
};

TBSEntity_Sprite.prototype.startBalloon = function (id) {
    if (!this._balloonSprite) {
        this._balloonSprite = new Sprite_Balloon();
    }
    this._balloonSprite.setup(id);
    BattleManagerTBS.getLayer("movableInfo").addChild(this._balloonSprite);
};

TBSEntity_Sprite.prototype.updateBalloon = function () {
    if (this._balloonSprite) {
        this._balloonSprite.x = this.x;
        this._balloonSprite.y = this.y - this.height;
        if (!this._balloonSprite.isPlaying()) {
            this.endBalloon();
        }
    }
};

TBSEntity_Sprite.prototype.endBalloon = function () {
    if (this._balloonSprite) {
        BattleManagerTBS.getLayer("movableInfo").removeChild(this._balloonSprite);
        this._balloonSprite = null;
    }
};

TBSEntity_Sprite.prototype.startWeaponAnimation = function (data, spriteName) {
    spriteName = "Dagger";
    var bitmap = ImageManager.loadLeTBSWeaponSprite(spriteName);
    this._weaponSprite = new Sprite(bitmap);
    this._weaponSprite.anchor.x = 0;
    this._weaponSprite.anchor.y = 1;
    this._weaponSpriteAnim.data = data;
    this._weaponSpriteAnim.index = -1;
    this._weaponSpriteAnim.tween = {
        x: 0,
        y: 0,
        angle: 0
    };
    this.addChild(this._weaponSprite);
    this.onWeaponSpriteTweenComplete();
};

TBSEntity_Sprite.prototype.onWeaponSpriteTweenComplete = function () {
    var index = ++this._weaponSpriteAnim.index;
    var dataTween = this._weaponSpriteAnim.data[index];
    if (dataTween) {
        var tween = new TWEEN.Tween(this._weaponSpriteAnim.tween)
            .to(dataTween, (dataTween.duration || 0) * 1000)
            .onComplete(this.onWeaponSpriteTweenComplete.bind(this))
            .start();
    } else {
        this.removeChild(this._weaponSprite);
        this._weaponSpriteAnim.data = [];
    }
}

TBSEntity_Sprite.prototype.updateWeaponSprite = function () {
    var data = this._weaponSpriteAnim.data;
    if (data.length > 0) {
        var dataTween = this._weaponSpriteAnim.tween;
        if (dataTween) {
            this._weaponSprite.x = dataTween.x || 0;
            this._weaponSprite.y = dataTween.y || 0;
            this._weaponSprite.rotation = dataTween.angle * Math.PI / 180 || 0;
        }
    }
};

TBSEntity_Sprite.prototype.isBalloonPlaying = function () {
    return !!this._balloonSprite;
};


/*-------------------------------------------------------------------------
* TBSNeutralEntity
-------------------------------------------------------------------------*/
function TBSNeutralEntity() {
    this.initialize.apply(this, arguments);
}
TBSNeutralEntity.prototype = Object.create(TBSEntity.prototype);
TBSNeutralEntity.prototype.constructor = TBSNeutralEntity;

TBSNeutralEntity.prototype.initialize = function (layer, tbsEvent, enemyId) {
    this._tbsEvent = tbsEvent;
    this._isNeutral = true;
    var battler = new Game_Enemy(enemyId, 0, 0);
    TBSEntity.prototype.initialize.call(this, battler, layer);
};


/*-------------------------------------------------------------------------
* TBSEvent
-------------------------------------------------------------------------*/
function TBSEvent() {
    this.initialize.apply(this, arguments);
}

TBSEvent.prototype.initialize = function (event) {
    this._event = event;
    this._triggerType = null;
    this._cooldown = 0;
    this._warmup = 0;
    this._obstacleForLOS = true;
    this._stopWhenStepped = false;
    this._tileEffect = null;
    this._oldPos = {};
    this._tiedMovingEntity = null;
    this.onEventPageSetup();
};

TBSEvent.prototype.onEventPageSetup = function () {
    this.setupFlags();
};

TBSEvent.prototype.onEventForceMoveRoute = function () {
    this.checkEntityOnEvent();
};

TBSEvent.prototype.setupFlags = function () {
    var condition = false;
    this._triggerConditions = [];
    for (var i = 0; i < this._event.list().length; i++) {
        var command = this._event.list()[i];
        if (command && command.code === 108 || command.code === 408) {
            var comment = command.parameters[0];
            if (comment.match(/<LeTBS>\s?Trigger_Type\s?:\s?(.+)/i))
                this._triggerType = String(RegExp.$1).toLowerCase();
            else if (comment.match(/<LeTBS>\s?Cooldown\s?:\s?(.+)/i))
                this._cooldown = Number(RegExp.$1);
            else if (comment.match(/<LeTBS>\s?Warmup\s?:\s?(.+)/i))
                this._warmup = Number(RegExp.$1);
            else if (comment.match(/<LeTBS>\s?Free_LOS/i))
                this._obstacleForLOS = false;
            else if (comment.match(/<LeTBS>\s?Stop_On_Step/i))
                this._stopWhenStepped = true;
            else if (comment.match(/<LeTBS>\s?Tile_Effect\s?:\s?(.+)/i))
                this._tileEffect = Number(RegExp.$1);
            else if (comment.match(/<LeTBS>\s?Tied_Mark\s?:\s?(.+)/i))
                this._tiedMark = String(RegExp.$1).toLowerCase();
            else if (comment.match(/<LeTBS Trigger Conditions>/i))
                condition = true;
            else if (comment.match(/<\/LeTBS Trigger Conditions>/i))
                condition = false;
            else {
                if (condition)
                    this._triggerConditions.push(comment);
            }
        }
    }
};

TBSEvent.prototype.update = function () {
    this.updateEntityMove();
};

TBSEvent.prototype.updateEntityMove = function () {
    if (this._tiedMovingEntity && (this.screenX() != this._oldPos.screenX || this.screenY() != this._oldPos.screenY)) {
        if (this._oldPos.screenX && this._oldPos.screenY) {
            var entity = this._tiedMovingEntity;
            var diffX = this._oldPos.screenX - this.screenX();
            var diffY = this._oldPos.screenY - this.screenY();
            entity.x -= diffX;
            entity.y -= diffY;
            var cell = BattleManagerTBS.getCellAt(this._event._realX, this._event._realY);
            if (cell)
                entity.setCell(cell);
        }
        this._oldPos.x = this._event._realX;
        this._oldPos.y = this._event._realY;
        this._oldPos.screenX = this.screenX();
        this._oldPos.screenY = this.screenY();
    }
};

TBSEvent.prototype.start = function () {
    this.checkEntityOnEvent();
    this._event.start();
};

TBSEvent.prototype.checkEntityOnEvent = function () {
    this._tiedMovingEntity = BattleManagerTBS.getEntityAt(this.x(), this.y());
};

TBSEvent.prototype.event = function () {
    return this._event;
};

TBSEvent.prototype.x = function () {
    return this._event.x;
};

TBSEvent.prototype.y = function () {
    return this._event.y;
};

TBSEvent.prototype.getCell = function () {
    return BattleManagerTBS.getCellAt(this.x(), this.y());
};

TBSEvent.prototype.screenX = function () {
    return this._event._realX * $gameMap.tileWidth();
};

TBSEvent.prototype.screenY = function () {
    return this._event._realY * $gameMap.tileHeight();
};

TBSEvent.prototype.isObstacle = function () {
    return !this._event.isThrough() && this._event.isNormalPriority();
};

TBSEvent.prototype.isObstacleForLOS = function () {
    return !!this._obstacleForLOS;
};

TBSEvent.prototype.canTriggerWhen = function (condition) {
    return this._triggerType === condition;
};

TBSEvent.prototype.triggerConditions = function () {
    return this._triggerConditions.join(" && ");
};


/*-------------------------------------------------------------------------
* TBSDirectionSelector
-------------------------------------------------------------------------*/
function TBSDirectionSelector() {
    this.initialize.apply(this, arguments);
}

TBSDirectionSelector.prototype.initialize = function (layer) {
    this._cell = null;
    this._battlerEntity = null;
    this.createSprite(layer);
};

TBSDirectionSelector.prototype.createSprite = function (layer) {
    var bitmap = ImageManager.loadLeTBS("DirectionSelector", 0);
    this._sprite = new Sprite(bitmap);
    this._sprite.anchor.x = 0.5;
    this._sprite.anchor.y = 0.5;
    this._sprite.opacity = 0;
    layer.addChild(this._sprite);
};

TBSDirectionSelector.prototype.set = function (cell, battler) {
    this._cell = cell;
    this._battlerEntity = battler;
    this._sprite.x = cell.x * $gameMap.tileWidth() + $gameMap.tileWidth() / 2;
    this._sprite.y = cell.y * $gameMap.tileHeight() + $gameMap.tileHeight() / 2;
    this._sprite.opacity = 255;
    this.setDir(battler.getDir());
};

TBSDirectionSelector.prototype.setDir = function (dir) {
    this._battlerEntity.setDir(dir);
    var r = 0;
    switch (dir) {
        case 2:
            r = 0;
            break;
        case 4:
            r = 90;
            break;
        case 6:
            r = 90 * 3;
            break;
        case 8:
            r = 90 * 2;
            break;
    }
    this._sprite.rotation = r * Math.PI / 180;
    SoundManager.playCursor();
};

TBSDirectionSelector.prototype.hide = function () {
    this._sprite.opacity = 0;
};


/*-------------------------------------------------------------------------
* Window_TBSConfirm
-------------------------------------------------------------------------*/
function Window_TBSConfirm() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSPositioning
-------------------------------------------------------------------------*/
function Window_TBSPositioning() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSPositioningConfirm
-------------------------------------------------------------------------*/
function Window_TBSPositioningConfirm() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSStatus
-------------------------------------------------------------------------*/
function Window_TBSStatus() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSCommand
-------------------------------------------------------------------------*/
function Window_TBSCommand() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSEndCommand
-------------------------------------------------------------------------*/
function Window_TBSEndCommand() {
    this.initialize.apply(this, arguments);
}


/*=========================================================================
*	RTPs MODIFS
=========================================================================*/



/*-------------------------------------------------------------------------
* Game_BattlerBase
-------------------------------------------------------------------------*/
Game_BattlerBase.prototype.hasConfusionStateAttackAlly = function () {
    return this.confusionLevel() === 1;
};

Game_BattlerBase.prototype.hasConfusionStateAttackAnyone = function () {
    return this.confusionLevel() === 2;
};

Game_BattlerBase.prototype.hasConfusionStateAttackEnemy = function () {
    return this.confusionLevel() === 3;
};


/*-------------------------------------------------------------------------
* Game_Battler
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameBattler_initMembers = Game_Battler.prototype.initMembers;
Game_Battler.prototype.initMembers = function () {
    Lecode.S_TBS.oldGameBattler_initMembers.call(this);
    this._leTbsDirectionalDmg = 0;
};

Game_Battler.prototype.leTBS_setDirectionalDmgEffects = function (amount) {
    this._leTbsDirectionalDmg = amount;
};

Lecode.S_TBS.oldGameBattler_addNewState = Game_Battler.prototype.addNewState;
Game_Battler.prototype.addNewState = function (stateId) {
    Lecode.S_TBS.oldGameBattler_addNewState.call(this, stateId);
    if (LeUtilities.isScene("Scene_Battle") && Lecode.S_TBS.commandOn) {
        var state = $dataStates[stateId];
        var entity = BattleManagerTBS.getEntityByBattler(this);
        if (entity)
            entity.onNewState(state);
    }
};

Lecode.S_TBS.oldGameBattler_eraseState = Game_Battler.prototype.eraseState;
Game_Battler.prototype.eraseState = function (stateId) {
    Lecode.S_TBS.oldGameBattler_eraseState.call(this, stateId);
    if (LeUtilities.isScene("Scene_Battle") && Lecode.S_TBS.commandOn) {
        var state = $dataStates[stateId];
        var entity = BattleManagerTBS.getEntityByBattler(this);
        if (entity)
            entity.onStateErased(state);
    }
};

Game_Battler.prototype.rpgObject = function () {
    return this.isActor() ? this.actor() : this.enemy();
};

Game_Battler.prototype.getEntity = function () {
    return BattleManagerTBS.getEntityByBattler(this);
};

Game_Battler.prototype.getLeTBSTagValue = function (str, isNumber, defaultValue) {
    defaultValue = defaultValue || (isNumber ? 0 : "");
    var main = this.getLeTBSTag(str);
    if (isNumber && isNaN(main))
        main = defaultValue;
    if (!isNumber) main = main || defaultValue;
    var add = this.getLeTBSTagSum(str + "_Add", isNumber);
    var rate = this.getLeTBSTagSum(str + "_Rate", isNumber);
    return isNumber ? Math.round((main + add) * (1 + rate)) : main + add;
};

Game_Battler.prototype.getLeTBSTagNumberValue = function (prop, defaultValue) {
    var result = this.getLeTBSTagValue(prop, true, defaultValue);
    return result;
};

Game_Battler.prototype.getLeTBSTagStringValue = function (prop, defaultValue) {
    var result = this.getLeTBSTagValue(prop, false, defaultValue);
    return LeUtilities.perfectStringList(result);
};

Game_Battler.prototype.collectLeTBSTags = function (str) {
    var result = LeUtilities.stringToArray(this.getLeTBSTagStringValue(str, null));
    return result;
};

Game_Battler.prototype.hasLeTBSTag = function (str) {
    var hasNegate = !!this.getLeTBSTag("!" + str);
    if (hasNegate) return false;
    var result = !!this.getLeTBSTag(str);
    return result;
};

Game_Battler.prototype.getLeTBSTagArrayValue = function (str, defaultValue) {
    str += "Array";
    defaultValue = defaultValue || [];
    var main = this.getLeTBSTag(str) || defaultValue;
    var add = this.collectLeTBSTag(str + "_Add");
    var rate = this.collectLeTBSTag(str + "_Rate");
    var i, j;
    for (i = 0; i < add.length; i++) {
        var array = add[i];
        for (j = 0; j < array.length; j++) {
            var value = main[j];
            if (isNaN(value))
                main[j] += ", " + add[i][j];
            else
                main[j] += add[i][j];
        }
    }
    for (i = 0; i < rate.length; i++) {
        var array = rate[i];
        for (j = 0; j < array.length; j++) {
            var value = main[j];
            if (!isNaN(value))
                main[j] *= 1 + rate[i][j];
        }
    }
    return main;
}

Game_Battler.prototype.getLeTBSTagObjectValue = function (str, defaultValue) {
    defaultValue = defaultValue || {};
    var main = JsonEx.makeDeepCopy(this.getLeTBSTag(str) || defaultValue);
    var add = this.collectLeTBSTag(str + "_Add");
    var rate = this.collectLeTBSTag(str + "_Rate");
    var i, j;
    for (i = 0; i < add.length; i++) {
        var obj = add[i];
        for (var property in obj) {
            if (main.hasOwnProperty(property) && !isNaN(main[property])) {
                main[property] += obj[property];
            }
        }
    }
    for (j = 0; j < rate.length; j++) {
        var obj = rate[j];
        for (var property in obj) {
            if (main.hasOwnProperty(property) && !isNaN(main[property])) {
                main[property] *= 1 + obj[property];
            }
        }
    }
    return main;
};


//-- Get the most priotary tag from the battler's data
//-------------------------------------------------------------------------------
Game_Battler.prototype.getLeTBSTag = function (str) {
    var i;
    //-- Get the tag from the battlers tag effects (first priority)
    var tagEffect = this.rpgObject().TagsLetbs_Effects[str];
    if (tagEffect != null) return tagEffect;
    //-- Get the tag from the battler's current action item (second priority)
    var obj = this._itemOnUse;
    if (obj && obj.TagsLetbs[str] != null)
        return obj.TagsLetbs[str];
    //-- Get the tag from the battler's states (third priority)
    for (i = 0; i < this.states().length; i++) {
        var state = this.states()[i];
        if (state && state.TagsLetbs[str] != null)
            return state.TagsLetbs[str];
    }
    if (this.isActor()) {
        //-- Get the tag from the battler's equipment (fourth priority)
        for (i = 0; i < this.equips().length; i++) {
            var equip = this.equips()[i];
            if (equip && equip.TagsLetbs[str] != null)
                return equip.TagsLetbs[str];
        }
        //-- Get the tag from the battler's class (fifth priority)
        var rpgClass = this.currentClass();
        if (rpgClass.TagsLetbs[str] != null)
            return rpgClass.TagsLetbs[str];
    }
    //-- Get the tag from the battler object
    return this.rpgObject().TagsLetbs[str];
};

//-- Get the sum of a tag from all the battler's data
//-------------------------------------------------------------------------------
Game_Battler.prototype.getLeTBSTagSum = function (str, isNumber) {
    //-- Get the tag from the battler object
    var value = isNumber ? (this.rpgObject().TagsLetbs[str] || 0) : (", " + (this.rpgObject().TagsLetbs[str] || ""));
    //-- Get the tag from the battlers tag effects
    var tagEffect = this.rpgObject().TagsLetbs_Effects[str];
    value += isNumber ? (tagEffect || 0) : (", " + (tagEffect || ""));
    //-- Get the tag from the battler's current action item
    var obj = this._itemOnUse;
    if (obj)
        value += isNumber ? (obj.TagsLetbs[str] || 0) : (", " + (obj.TagsLetbs[str] || ""));
    //-- Get the tag from the battler's states
    this.states().forEach(function (state) {
        if (state) {
            value += isNumber ? (state.TagsLetbs[str] || 0) : (", " + (state.TagsLetbs[str] || ""));
        }
    });
    if (this.isActor()) {
        //-- Get the tag from the battler's equipment
        this.equips().forEach(function (equip) {
            if (equip) {
                value += isNumber ? (equip.TagsLetbs[str] || 0) : (", " + (equip.TagsLetbs[str] || ""));
            }
        });
        //-- Get the tag from the battler's class
        var rpgClass = this.currentClass();
        value += isNumber ? (rpgClass.TagsLetbs[str] || 0) : (", " + (rpgClass.TagsLetbs[str] || ""));
    }
    return value;
};

//-- Collect a tag from all the battler's data in a array
//-------------------------------------------------------------------------------
Game_Battler.prototype.collectLeTBSTag = function (str) {
    var i, array = [];
    //-- Get the tag from the battler object
    if (this.rpgObject().TagsLetbs[str] != null)
        array.push(this.rpgObject().TagsLetbs[str]);
    //-- Get the tag from the battlers tag effects
    var tagEffect = this.rpgObject().TagsLetbs_Effects[str];
    if (tagEffect != null) array.push(tagEffect);
    //-- Get the tag from the battler's current action item
    var obj = this._itemOnUse;
    if (obj && obj.TagsLetbs[str] != null)
        array.push(obj.TagsLetbs[str]);
    //-- Get the tag from the battler's states
    for (i = 0; i < this.states().length; i++) {
        var state = this.states()[i];
        if (state && state.TagsLetbs[str] != null)
            array.push(state.TagsLetbs[str]);
    }
    if (this.isActor()) {
        //-- Get the tag from the battler's equipment
        for (i = 0; i < this.equips().length; i++) {
            var equip = this.equips()[i];
            if (equip && equip.TagsLetbs[str] != null)
                array.push(equip.TagsLetbs[str]);
        }
        //-- Get the tag from the battler's class
        var rpgClass = this.currentClass();
        if (rpgClass.TagsLetbs[str] != null)
            array.push(rpgClass.TagsLetbs[str]);
    }
    return array;
};


/*-------------------------------------------------------------------------
* Game_Action
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameAction_executeDamage = Game_Action.prototype.executeDamage;
Game_Action.prototype.executeDamage = function (target, value) {
    value += value * target._leTbsDirectionalDmg;
    Lecode.S_TBS.oldGameAction_executeDamage.call(this, target, Math.floor(value));
};


/*-------------------------------------------------------------------------
* Game_Event
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameEvent_setupPage = Game_Event.prototype.setupPage;
Game_Event.prototype.setupPage = function () {
    Lecode.S_TBS.oldGameEvent_setupPage.call(this);
    if (LeUtilities.isScene("Scene_Battle") && Lecode.S_TBS.commandOn) {
        BattleManagerTBS.onEventPageSetup(this);
    }
};

Lecode.S_TBS.oldGameEvent_forceMoveRoute = Game_Event.prototype.forceMoveRoute;
Game_Event.prototype.forceMoveRoute = function (route) {
    Lecode.S_TBS.oldGameEvent_forceMoveRoute.call(this, route);
    if (LeUtilities.isScene("Scene_Battle") && Lecode.S_TBS.commandOn) {
        BattleManagerTBS.onEventForceMoveRoute(this);
    }
};

/*-------------------------------------------------------------------------
* Game_Interpreter
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameInterpreter_initialize = Game_Interpreter.prototype.initialize;
Game_Interpreter.prototype.initialize = function (depth) {
    Lecode.S_TBS.oldGameInterpreter_initialize.call(this, depth);
    this._setupQueue = [];
};

//- Start TBS Event right away when their self-switch change
Lecode.S_TBS.oldGameInterpreter_command123 = Game_Interpreter.prototype.command123;
Game_Interpreter.prototype.command123 = function () {
    var result = Lecode.S_TBS.oldGameInterpreter_command123.call(this);
    if (this._eventId > 0 && this._params[1] === 0) {
        if (Lecode.S_TBS.commandOn && $gameParty.inBattle()) {
            var event = $gameMap.event(this._eventId);
            event.refresh();
            event.update();
        }
    }
    return result;
};

Game_Interpreter.prototype.setupInQueue = function (list, eventId) {
    this._setupQueue.push([list, eventId || 0]);
};

Lecode.S_TBS.oldGameInterpreter_update = Game_Interpreter.prototype.update;
Game_Interpreter.prototype.update = function () {
    Lecode.S_TBS.oldGameInterpreter_update.call(this);
    if (!this.isRunning()) {
        var data = this._setupQueue.shift();
        if (data) {
            this.setup(data[0], data[1]);
        }
    }
};

Lecode.S_TBS.oldGameInterpreter_command108 = Game_Interpreter.prototype.command108;
Game_Interpreter.prototype.command108 = function () {
    if (this._leTBSSequencePreparing) {
        this._leTBSSequence.push(this._params[0]);
        while (this.nextEventCode() === 408) {
            this._index++;
            this._leTBSSequence.push(this.currentCommand().parameters[0]);
        }
        return true;
    } else {
        return Lecode.S_TBS.oldGameInterpreter_command108.call(this);
    }
};

Lecode.S_TBS.oldGameInterpreter_pluginCommand = Game_Interpreter.prototype.pluginCommand;
Game_Interpreter.prototype.pluginCommand = function (command, args) {
    this._leTBSCommandFlow = null;
    Lecode.S_TBS.oldGameInterpreter_pluginCommand.call(this, command, args);

    if (command === 'LeTBS') {
        this._leTBSCommandFlow = {
            isWaiting: function () { return false; },
            update: function () { },
            onEnd: function () { }
        };

        var key = args[0];
        args = args.map(function (str) {
            return str;//.toLowerCase();
        });
        args.shift();
        Lecode.S_TBS.CommandSuccess = true;

        var func;
        try {
            func = eval("this.interpretLeTBS_" + key + ".bind(this,args)");
        } catch (e) {
            console.log("[LeTBS]    Can't find command \"", key);
            console.log(e);
        }
        var result = func(args);
        if (result) {
            if (result.waitWhile && args.join().match(/wait/i))
                this._leTBSCommandFlow.isWaiting = result.waitWhile;
            if (result.update)
                this._leTBSCommandFlow.update = result.update;
            if (result.onEnd)
                this._leTBSCommandFlow.onEnd = result.onEnd;
        } else {
            Lecode.S_TBS.CommandSuccess = false;
        }

    }
};

Lecode.S_TBS.oldGameInterpreter_updateWaitMode = Game_Interpreter.prototype.updateWaitMode;
Game_Interpreter.prototype.updateWaitMode = function () {
    if (this._leTBSCommandFlow) {
        this._leTBSCommandFlow.update();
        var waiting = this._leTBSCommandFlow.isWaiting();
        if (!waiting) {
            this._waitMode = '';
            this._leTBSCommandFlow.onEnd();
            this._leTBSCommandFlow = null;
            return Lecode.S_TBS.oldGameInterpreter_updateWaitMode.call(this);
        }
        return waiting;
    } else {
        return Lecode.S_TBS.oldGameInterpreter_updateWaitMode.call(this);
    }
};

Game_Interpreter.prototype.readEntityForLeTBS = function (data) {
    if (data.toLowerCase() === "entity")
        return BattleManagerTBS._triggeredEventEntity;
    else if (data.toLowerCase() === "activeentity")
        return BattleManagerTBS.activeEntity();
    else if (data.match(/^flaggedentity\((.+)\)$/i))
        return BattleManagerTBS.getFlaggedEntity(RegExp.$1);
    else if (data.match(/^actor\((.+)\)$/i)) {
        return BattleManagerTBS.getEntityByActorId(Number(RegExp.$1));
    }
    else if (data.match(/^enemy\((.+)\)$/i)) {
        return BattleManagerTBS.getEntityByEnemyId(Number(RegExp.$1));
    }
    else if (data.match(/^randomEnemy$/i)) {
        return LeUtilities.getRandomValueInArray(BattleManagerTBS.enemyEntities());
    }
    else if (data.match(/^randomActor$/i)) {
        return LeUtilities.getRandomValueInArray(BattleManagerTBS.allyEntities());
    }
    else if (data.match(/^closestEnemyOf\((.+)\)$/i)) {
        var entity = this.readEntityForLeTBS(RegExp.$1);
        if (!entity) return null;
        var group = entity.battler().isActor() ? BattleManagerTBS.enemyEntities() : BattleManagerTBS.allyEntities();
        return LeUtilities.sortByClosestDistance(entity.getCell(), group, function (obj) {
            return obj.getCell()
        })[0];
    }
    else if (data.match(/^closestAllyOf\((.+)\)$/i)) {
        var entity = this.readEntityForLeTBS(RegExp.$1);
        if (!entity) return null;
        var group = entity.battler().isEnemy() ? BattleManagerTBS.enemyEntities() : BattleManagerTBS.allyEntities();
        return LeUtilities.sortByClosestDistance(entity.getCell(), group, function (obj) {
            return obj.getCell()
        })[0];
    }
    return null;
};

Game_Interpreter.prototype.readCellForLeTBS = function (data) {
    var entity = this.readEntityForLeTBS(data);
    if (entity)
        return entity.getCell();
    if (data.match(/^\((\d+)\,(\d+)\)$/i)) {
        var x = Number(RegExp.$1);
        var y = Number(RegExp.$2);
        return BattleManagerTBS.getCellAt(x, y);
    }
    return null;
};

Game_Interpreter.prototype.readObjForLeTBS = function (data) {
    if (data.match(/^skill\((.+)\)$/i)) {
        return $dataSkills[Number(RegExp.$1)];
    } else if (data.match(/item\((.+)\)/i)) {
        return $dataItems[Number(RegExp.$1)];
    } else if (data.toLowerCase() === "activeitem") {
        var action = BattleManagerTBS.activeAction();
        if (action) {
            return action.item();
        }
        return null;
    }
    return null;
};

//---------------------------------------------------------------------------------------

Game_Interpreter.prototype.interpretLeTBS_ON = function (args) {
    Lecode.S_TBS.commandOn = true;
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_OFF = function (args) {
    Lecode.S_TBS.commandOn = false;
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_Wait = function (args) {
    var value = Number(args[0]);
    BattleManagerTBS.wait(value);
    return {
        waitWhile: function () {
            return BattleManagerTBS.isWaiting();
        }
    };
};

Game_Interpreter.prototype.interpretLeTBS_ResetEvents = function (args) {
    LeUtilities.resetMapEvents();
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ForceEventTrigger = function (args) {
    var type = args[0].toLowerCase();
    if (type === "byid") {
        var eventId = Number(args[1]);
        BattleManagerTBS.executeEventsByForce(eventId);
    } else if (type === "bytrigger") {
        var triggerType = args[1].toLowerCase();
        BattleManagerTBS.executeEventsWhen(triggerType);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ShowCursor = function (args) {
    BattleManagerTBS.cursor().show();
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_HideCursor = function (args) {
    BattleManagerTBS.cursor().hide();
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_SelectCell = function (args) {
    var cell = this.readCellForLeTBS(args[0]);
    if (cell) {
        BattleManagerTBS.setCursorCell(cell);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ResetCell = function (args) {
    var cell = BattleManagerTBS.activeEntity().getCell();
    if (cell) {
        BattleManagerTBS.setCursorCell(cell);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ForceMove = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var cell = this.readCellForLeTBS(args[2]);
    var type = args[1].toLowerCase();
    var maxPM = args[3].toLowerCase() === "infinity" ? Infinity : Number(args[3]);
    if (entity && entity.battler().isAlive() && cell) {
        if (type === "to") {
            entity.processMovementTo(cell, Infinity, true);
        } else if (type === "near") {
            entity.processMovementNear(cell, maxPM, true);
        } else if (type === "away") {
            entity.processMovementAway(cell, maxPM, true);
        }
        if (!entity.isMoving())
            return false;
    } else {
        return false;
    }
    return {
        waitWhile: function (entity) {
            return entity.isMoving();
        }.bind(this, entity),

        onEnd: function (entity) {
            BattleManagerTBS.setCursorCell(entity.getCell());
        }.bind(this, entity)
    };
}

Game_Interpreter.prototype.interpretLeTBS_ForceJump = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var cell = this.readCellForLeTBS(args[2]);
    var type = args[1].toLowerCase();
    var maxPM = args[3].toLowerCase() === "infinity" ? Infinity : Number(args[3]);
    var height = args[4] ? Number(args[4]) : 120;
    if (entity && entity.battler().isAlive() && cell) {
        if (type === "to") {
            entity.processJumpTo(cell, Infinity, height);
        } else if (type === "near") {
            entity.processJumpNear(cell, maxPM, height);
        } else if (type === "away") {
            entity.processJumpAway(cell, maxPM, height);
        }
        if (!entity.sprite().hasTrajectory())
            return false;
    } else {
        return false;
    }
    return {
        waitWhile: function (entity) {
            return entity.sprite().hasTrajectory();
        }.bind(this, entity),

        onEnd: function (entity) {
            BattleManagerTBS.setCursorCell(entity.getCell());
        }.bind(this, entity)
    };
}

Game_Interpreter.prototype.interpretLeTBS_SetEntityPosition = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var type = args[1].toLowerCase();
    var cell = this.readCellForLeTBS(args[2]);
    var anim = Number(args[3]);
    if (entity && cell) {
        if (type === "to") {
        } else if (type === "near") {
            cell = BattleManagerTBS.getCellNear(entity.getCell(), cell, Infinity);
        } else if (type === "away") {
            cell = BattleManagerTBS.getCellAway(entity.getCell(), cell, 30);
        }
        if (cell) {
            entity.teleport(cell);
            if (anim)
                entity.newAnimation(anim, false, 0);
            BattleManagerTBS.setCursorCell(cell);
        } else {
            return false;
        }
    } else {
        return false;
    }
    return {};
};

//- TODO: Handle this with the trigger "action_start"
Game_Interpreter.prototype.interpretLeTBS_ForceAction = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var item = this.readObjForLeTBS(args[1]);
    var oldActiveAction = JsonEx.makeDeepCopy(BattleManagerTBS.activeAction());
    if (entity && entity.battler().isAlive() && item) {
        BattleManagerTBS.onForcedActionStart(entity);
        BattleManagerTBS.forceAction(item, entity);
    } else
        return false;
    return {
        waitWhile: function (entity) {
            return entity._sequenceManager.isRunning();
        }.bind(this, entity),

        onEnd: function (entity, oldActiveAction) {
            BattleManagerTBS.onForcedActionEnd(entity);
            BattleManagerTBS._activeAction = oldActiveAction;
        }.bind(this, entity, oldActiveAction)
    };
}

//- TODO: Handle this with the trigger "action_start"
Game_Interpreter.prototype.interpretLeTBS_RequestAction = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var item = this.readObjForLeTBS(args[1]);
    var options = {
        endCallback: function () {
            BattleManagerTBS.cursor().show();
        }
    };
    if (entity && entity.battler().isAlive()) {
        if (item) {
            options.item = item;
            options.behaviorType = item.TagsLetbsAi.type;
            options.behavior = "action_requested";
            if (!options.behaviorType) {
                throw new Error("[LeTBS] - Requesting an action with no AI tag.");
            }
        } else { //- Requesting generic action (offense, healing, ect)
            var type = args[1].toLowerCase();
            options.behaviorType = type;
            options.behavior = "action_requested";
        }
        var oldData = {
            phase: BattleManagerTBS._subPhase,
            activeAction: JsonEx.makeDeepCopy(BattleManagerTBS.activeAction()),
            actionPerformed: entity._actionPerformed,
            movePerformed: entity._movePerformed
        };
        Lecode.S_TBS.requestedAction = true;
        var target = this.readEntityForLeTBS(args[2]);
        options.entityTarget = target;
        BattleManagerTBS.onRequestedActionStart(entity);
        BattleManagerTBS.startAiTurn(entity, options);
    } else {
        return false;
    };
    return {
        waitWhile: function () {
            return !!Lecode.S_TBS.requestedAction;
        },

        update: function () {
            BattleManagerTBS._aiManager.update();
        },

        onEnd: function (entity, oldData) {
            BattleManagerTBS._subPhase = oldData.phase;
            BattleManagerTBS._activeAction = oldData.activeAction;
            entity._actionPerformed = oldData.actionPerformed;
            entity._movePerformed = oldData.movePerformed;
        }.bind(this, entity, oldData)
    };
};

Game_Interpreter.prototype.interpretLeTBS_StartSequence = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var sequenceId = args[1].toLowerCase();
    if (entity && entity.battler().isAlive() && sequenceId) {
        entity.appendSequence(sequenceId);
    } else {
        return false;
    }
    return {
        waitWhile: function (entity) {
            return entity._sequenceManager.isRunning();
        }.bind(this, entity)
    };
};

Game_Interpreter.prototype.interpretLeTBS_PrepareSequence = function (args) {
    this._leTBSSequencePreparing = true;
    this._leTBSSequence = [];
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ExecuteSequence = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var sequence = this._leTBSSequence;
    if (entity && entity.battler().isAlive() && sequence) {
        entity.executeSequence(sequence);
        this._leTBSSequencePreparing = false;
        this._leTBSSequence = [];
    } else {
        return false;
    }
    return {
        waitWhile: function (entity) {
            return entity._sequenceManager.isRunning();
        }.bind(this, entity)
    };
};

Game_Interpreter.prototype.interpretLeTBS_Animation = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var animId = Number(args[1]);
    if (entity && animId) {
        entity.newAnimation(animId, false, 0);
    } else {
        return false;
    }
    return {
        waitWhile: function (entity) {
            return BattleManagerTBS.isAnimationPlaying();
        }.bind(this, entity)
    };
};

Game_Interpreter.prototype.interpretLeTBS_AddState = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var id = Number(args[1]);
    if (entity && id) {
        entity.battler().addState(id);
        if (args.join().toLowerCase().includes("showpopup"))
            entity.addPopup();
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ChangeHP = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var value = Number(args[1]);
    if (entity && !isNaN(value)) {
        entity.battler().gainHp(value);
        var str = args.join().toLowerCase();
        if (str.includes("showpopup"))
            entity.addPopup();
        if (str.includes("playdamaged"))
            entity.callSequence("damaged");
        if (str.includes("checkdeath"))
            entity.checkDeath();
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ChangeMP = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var value = Number(args[1]);
    if (entity && !isNaN(value)) {
        entity.battler().gainMp(value);
        var str = args.join().toLowerCase();
        if (str.includes("showpopup"))
            entity.addPopup();
        if (str.includes("playdamaged"))
            entity.callSequence("damaged");
        if (str.includes("checkdeath"))
            entity.checkDeath();
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ChangeTP = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var value = Number(args[1]);
    if (entity && !isNaN(value)) {
        entity.battler().gainTp(value);
        var str = args.join().toLowerCase();
        if (str.includes("showpopup"))
            entity.addPopup();
        if (str.includes("playdamaged"))
            entity.callSequence("damaged");
        if (str.includes("checkdeath"))
            entity.checkDeath();
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ShowPopup = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var str = args.join(" ");
    var text = str.regExValue(/text\((.+?)\)/i);
    var fontSize = str.regExValue(/fontsize\((.+?)\)/i) || 28;
    var color = str.regExValue(/color\((.+?)\)/i) || "#FFF";
    var icL = str.regExValue(/iconl\((.+?)\)/i) || 0;
    var icR = str.regExValue(/iconr\((.+?)\)/i) || 0;
    if (entity && text) {
        entity.addTextIconPopup(text, icL, icR, fontSize, color);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_AddEntity = function (args) {
    var type = args[0].match(/actor\((.+)\)/i) ? "actor" : (args[0].match(/enemy\((.+)\)/i) ? "enemy" : null);
    if (type) {
        var id = Number(RegExp.$1);
        var battler = type === "actor" ? new Game_Actor(id) : new Game_Enemy(id, 0, 0);
        var cell = this.readCellForLeTBS(args[1]);
        if (cell) {
            var orderType = args[2].toLowerCase();
            var anim = args[3].toLowerCase() === "defaultanim" ? Lecode.S_TBS.placedBattlerAnim : (Number(args[3]) || 0);
            var flag = args[4].toLowerCase() || null;
            var isNeutral = orderType === "neutral";
            var entity = BattleManagerTBS.addEntity(battler, cell, anim, isNeutral);
            entity._flag = flag;
            if (!isNeutral) {
                if (orderType.match(/order\((.+)\)/i)) {
                    var result = RegExp.$1;
                    if (result === "first") {
                        BattleManagerTBS._turnOrder.unshift(entity);
                        BattleManagerTBS._activeIndex++;
                    } else if (result === "last") {
                        BattleManagerTBS._turnOrder.push(entity);
                    } else if (result === "remake") {
                        //- TODO: Restore previous activeIndex
                        BattleManagerTBS.determineTurnOrder();
                    }
                    setTimeout(function () {
                        var order = BattleManagerTBS._turnOrder;
                        var index = BattleManagerTBS._activeIndex;
                        BattleManagerTBS._turnOrderVisual.set(order, index);
                    }, 500);
                }
            }
        } else {
            return false;
        }
    } else {
        return false;
    }
    return {
        waitWhile: function () {
            return BattleManagerTBS.isAnimationPlaying();
        }
    };
};

Game_Interpreter.prototype.interpretLeTBS_RemoveEntity = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var anim = Number(args[1]);
    if (entity) {
        if (!anim)
            BattleManagerTBS.destroyEntity(entity, true);
        else
            entity.newAnimation(anim, false, 0);
    } else {
        return false;
    }
    return {
        waitWhile: function (anim) {
            if (anim)
                return BattleManagerTBS.isAnimationPlaying();
            return false;
        }.bind(this, anim),
        onEnd: function (anim, entity) {
            if (anim) {
                BattleManagerTBS.destroyEntity(entity, true);
            }
        }.bind(this, anim, entity)
    };
};

Game_Interpreter.prototype.interpretLeTBS_HideEntity = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    if (entity) {
        BattleManagerTBS.hideEntity(entity);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ShowEntity = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    if (entity) {
        BattleManagerTBS.showEntity(entity);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_EntityFadeIn = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var duration = Number(args[1]);
    if (entity) {
        entity.fadeIn(duration);
    } else {
        return false;
    }
    return {
        waitWhile: function (entity) {
            return entity.sprite().opacity != entity.defaultOpacity();
        }.bind(this, entity)
    };
};

Game_Interpreter.prototype.interpretLeTBS_EntityFadeOut = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var duration = Number(args[1]);
    if (entity) {
        entity.fadeOut(duration);
    } else {
        return false;
    }
    return {
        waitWhile: function (entity) {
            return entity.sprite().opacity != 0;
        }.bind(this, entity)
    };
};

Game_Interpreter.prototype.interpretLeTBS_SetDirection = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var dir = LeUtilities.directionTextToCode(args[1]);
    if (entity && !isNaN(dir)) {
        entity.setDir(dir);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_LookAt = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var cell = this.readCellForLeTBS(args[1]);
    if (entity && cell) {
        entity.lookAt(cell);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_LookEnemies = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    if (entity) {
        var entities = entity.battler().isActor() ? BattleManagerTBS.enemyEntities()
            : BattleManagerTBS.allyEntities();
        entity.lookClosestBattler(entities);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_LookAllies = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    if (entity) {
        var entities = entity.battler().isEnemy() ? BattleManagerTBS.enemyEntities()
            : BattleManagerTBS.allyEntities();
        entity.lookClosestBattler(entities);
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ShowBalloon = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var id = Number(args[1]);
    if (args[0].toLowerCase() === "party" && !isNaN(id)) {
        BattleManagerTBS.allyEntities().forEach(function (e) {
            if (e.battler().isAlive())
                e.startBalloon(id);
        });
    } else if (args[1].toLowerCase() === "troop" && !isNaN(id)) {
        BattleManagerTBS.enemyEntities().forEach(function (e) {
            if (e.battler().isAlive())
                e.startBalloon(id);
        });
    } else if (args[1].toLowerCase() === "all" && !isNaN(id)) {
        BattleManagerTBS.allEntities().forEach(function (e) {
            if (e.battler().isAlive())
                e.startBalloon(id);
        });
    } else if (entity && !isNaN(id)) {
        if (entity.battler().isAlive())
            entity.startBalloon(id);
    } else {
        return false;
    }
    return {
        waitWhile: function () {
            return BattleManagerTBS.allEntities().some(function (entity) {
                return entity.sprite().isBalloonPlaying();
            });
        }
    };
};

Game_Interpreter.prototype.interpretLeTBS_SetTagValue = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var tagName = args[1];
    var tagValue = args[2];
    if (entity && tagName && tagValue) {
        tagName = LeUtilities.shrinkTextWithUnderscores(tagName, true);
        var value = isNaN(Number(tagValue)) ? tagValue : Number(tagValue);
        entity.battler().rpgObject().TagsLetbs_Effects[tagName] = value;
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_ResetTagValue = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    var tagName = args[1];
    if (entity && tagName) {
        tagName = LeUtilities.shrinkTextWithUnderscores(tagName, true);
        entity.battler().rpgObject().TagsLetbs_Effects[tagName] = null;
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_SetTurn = function (args) {
    var entity = this.readEntityForLeTBS(args[0]);
    if (entity && entity.battler().isAlive()) {
        var index = BattleManagerTBS._turnOrder.indexOf(entity);
        if (index) {
            BattleManagerTBS._activeIndex = index;
            var order = BattleManagerTBS._turnOrder;
            this._turnOrderVisual.updateOnNextTurn(this._turnOrder, index);
            BattleManagerTBS.startTurn();
        } else {
            return false;
        }
    } else {
        return false;
    }
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_EndTurn = function (args) {
    BattleManagerTBS.turnEnd();
    return {};
};

Game_Interpreter.prototype.interpretLeTBS_StopBattle = function (args) {
    var type = args[0];
    if (type) {
        switch (type) {
            case "abort": BattleManagerTBS.prepareAbort(); break;
            case "defeat": BattleManagerTBS.prepareDefeat(); break;
            case "victory": BattleManagerTBS.prepareVictory(); break;
        }
    } else {
        return false;
    }
    return {};
};

//--------------------------------------------------------------------------------------

Lecode.S_TBS.oldGameInterpreter_character = Game_Interpreter.prototype.character;
Game_Interpreter.prototype.character = function (param) {
    if (Lecode.S_TBS.commandOn && $gameParty.inBattle()) {
        return $gameMap.event(param > 0 ? param : this._eventId);
    }
    return Lecode.S_TBS.oldGameInterpreter_character.call(this, param);
};


/*-------------------------------------------------------------------------
* Game_Troop
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameTroop_updateInterpreter = Game_Troop.prototype.updateInterpreter;
Game_Troop.prototype.updateInterpreter = function () {
    if (!Lecode.S_TBS.commandOn) {
        Lecode.S_TBS.oldGameTroop_updateInterpreter.call(this);
        return;
    }
    this._interpreter.update();
    if (this._interpreter._list === null) {
        if (this.setupStartingMapEvent()) {
            return true;
        }
        if (this.setupAutorunCommonEvent()) {
            return true;
        }
    }
};

Game_Troop.prototype.setupStartingMapEvent = function () {
    var events = $gameMap.events();
    for (var i = 0; i < events.length; i++) {
        var event = events[i];
        if (event.isStarting()) {
            event.clearStartingFlag();
            this._interpreter.setup(event.list(), event.eventId());
            return true;
        }
    }
    return false;
};

Game_Troop.prototype.setupAutorunCommonEvent = function () {
    for (var i = 0; i < $dataCommonEvents.length; i++) {
        var event = $dataCommonEvents[i];
        if (event && event.trigger === 1 && $gameSwitches.value(event.switchId)) {
            this._interpreter.setup(event.list);
            return true;
        }
    }
    return false;
};


/*-------------------------------------------------------------------------
* Game_Map
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldIsPassable_method = Game_Map.prototype.isPassable;
Game_Map.prototype.isPassable = function (x, y, d) {
    var result = Lecode.S_TBS.oldIsPassable_method.call(this, x, y, d);
    if (LeUtilities.isScene("Scene_Battle") && BattleManagerTBS.activeEntity()) {
        var entityCell = BattleManagerTBS.activeEntity().getCell();
        var cell = BattleManagerTBS.getCellAt(x, y);
        if (cell && !(entityCell.x == x && entityCell.y == y) && cell.isThereEntity())
            return false;
    }
    return result;
};

Lecode.S_TBS.oldGameMap_updateInterpreter = Game_Map.prototype.updateInterpreter;
Game_Map.prototype.updateInterpreter = function () {
    if (LeUtilities.isScene("Scene_Battle") && Lecode.S_TBS.commandOn)
        return;
    Lecode.S_TBS.oldGameMap_updateInterpreter.call(this);
};


/*-------------------------------------------------------------------------
* TBS_FloatingAction
-------------------------------------------------------------------------*/
function TBS_FloatingAction() {
    this.initialize.apply(this, arguments);
}
TBS_FloatingAction.prototype = Object.create(Game_Action.prototype);
TBS_FloatingAction.prototype.constructor = TBS_FloatingAction;

TBS_FloatingAction.prototype.initialize = function (subject, forcing) {
    Game_Action.prototype.initialize.call(this, subject, forcing);
};

TBS_FloatingAction.prototype.setSubject = function (subject) {
    this._subject = subject;
};

TBS_FloatingAction.prototype.subject = function () {
    return this._subject;
};


/*-------------------------------------------------------------------------
* TouchInput
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldTouchInput_clear = TouchInput.clear;
TouchInput.clear = function () {
    Lecode.S_TBS.oldTouchInput_clear.call(this);
    this._leTBSMoveData = {
        x: 0,
        y: 0
    };
};

Lecode.S_TBS.oldTouchInput_onMouseMove = TouchInput._onMouseMove;
TouchInput._onMouseMove = function (event) {
    Lecode.S_TBS.oldTouchInput_onMouseMove.call(this, event);
    var x = Graphics.pageToCanvasX(event.pageX);
    var y = Graphics.pageToCanvasY(event.pageY);
    this._leTBSMoveData.x = x;
    this._leTBSMoveData.y = y;
};


/*-------------------------------------------------------------------------
* Scene_Boot
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldSceneBoot_start = Scene_Boot.prototype.start;
Scene_Boot.prototype.start = function () {
    this.processLeTBSTags();
    Lecode.S_TBS.oldSceneBoot_start.call(this);
};

Scene_Boot.prototype.processLeTBSTags = function () {
    this.initializeTagEffects();
    this.makeLeTBSTags();
    this.parseLeTBSTags();
};

Scene_Boot.prototype.getLeTBSMainTags = function () {
    return [
        { name: "letbs", type: "object" },          //TagsLetbs
        {
            name: "letbs_ai", type: "object",       //TagsLetbsAi
            default: {
                type: "",
                useCondition: "true",
                escapeCondition: "true",
                rushCondition: "true",
                maximiseTargets: false,
                summonNear: "enemies",
                avoidFriendlyFire: 0
            }
        },
        { name: "letbs_sprite", type: "object" },   //TagsLetbsSprite
        { name: "letbs_sequence", type: "array" },  //TagsLetbsSequene
        {
            name: "letbs_body_size", type: "string",
            default: "circle(0)"
        },                   //TagsLetbsBodySize
    ];
};

Scene_Boot.prototype.initializeTagEffects = function () {
    [$dataActors, $dataEnemies].forEach(function (group) {
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            this.getLeTBSMainTags().forEach(function (data) {
                var code = LeUtilities.shrinkTextWithUnderscores("tags_" + data.name);
                code += "_Effects";
                obj[code] = {};
            }, this);
        }
    }, this)
};

Scene_Boot.prototype.makeLeTBSTags = function () {
    var tags = this.getLeTBSMainTags().map(function (data) {
        return data.name;
    });
    var types = this.getLeTBSMainTags().map(function (data) {
        return data.type;
    });
    var groups = [$dataActors, $dataEnemies, $dataClasses,
        $dataWeapons, $dataArmors, $dataStates,
        $dataSkills, $dataItems, $dataWeapons];
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            var notedata = obj.note.split(/[\r\n]+/);
            var currentTag = null;
            var currentType = null;
            this.getLeTBSMainTags().forEach(function (data) {
                var code = LeUtilities.shrinkTextWithUnderscores("tags_" + data.name);
                if (data.type === "string")
                    obj[code] = "";
                else {
                    obj[code] = data.type === "array" ? [] : {};
                }
                if (data.default)
                    obj[code] = data.default;
            });

            for (var k = 0; k < notedata.length; k++) {
                var line = notedata[k];
                if (line.match(/<(.+)>/i) && tags.contains(RegExp.$1.toLocaleLowerCase())) {
                    currentTag = RegExp.$1.toLocaleLowerCase();
                    continue;
                } else if (line.match(/<\/(.+)>/i) && tags.contains(RegExp.$1.toLocaleLowerCase()))
                    currentTag = null;

                var result, arg;
                if (currentTag) {
                    currentType = types[tags.indexOf(currentTag)];
                    var code = LeUtilities.shrinkTextWithUnderscores("tags_" + currentTag);
                    if (currentType === "string") {
                        obj[code] += line;
                    } if (currentType === "array") {
                        obj[code].push(line);
                    } else if (currentType === "object") {
                        if (line.match(/(.+)\s?:\s?(.+)/i)) {
                            arg = RegExp.$1;
                            var result = RegExp.$2.replace(/(\d+)\%/ig, function (match, p1) {
                                return String(p1 * 0.01);
                            });
                            result = isNaN(Number(result)) ? String(result).trim() : Number(result);
                        } else {
                            arg = line;
                            result = true;
                        }
                        arg = LeUtilities.shrinkTextWithUnderscores(arg, true);
                        obj[code][arg] = result;
                    }
                }
            }
            /*if (Object.keys(obj.TagsLetbs).length > 0)
                console.log("obj.TagsLetbs:", obj.TagsLetbs);
            if (Object.keys(obj.TagsLetbsAi).length > 0)
                console.log("obj.TagsLetbsAi:", obj.TagsLetbsAi);
            if (obj.TagsLetbsSequence.length > 0)
                console.log("obj.TagsLetbsSequence:", obj.TagsLetbsSequence);*/
        }
    }
};

Scene_Boot.prototype.parseLeTBSTags = function () {
    var groups = [$dataActors, $dataEnemies, $dataClasses,
        $dataWeapons, $dataArmors, $dataStates,
        $dataSkills, $dataItems, $dataWeapons];
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            this.getLeTBSMainTags().forEach(function (data) {
                if (data.type === "object") {
                    var code = LeUtilities.shrinkTextWithUnderscores("tags_" + data.name);
                    for (var property in obj[code]) {
                        if (obj[code].hasOwnProperty(property)) {
                            this.processLeTBSTagsAutoParse(property, obj, obj[code]);
                            this.parseLeTBSTag(property, obj, obj[code]);
                        }
                    }
                }
            }, this);
        }
    }
};

Scene_Boot.prototype.processLeTBSTagsAutoParse = function (prop, obj, tags) {
    var element = tags[prop];
    var newProp;
    if (element instanceof Array) return;
    if (prop.match(/(.+)\((.+)\)/i)) {
        if (prop.includes("+"))
            newProp = RegExp.$1 + "_Add";
        else if (prop.includes("%"))
            newProp = RegExp.$1 + "_Rate";
        else
            newProp = RegExp.$1;
        tags[newProp] = tags[newProp] || {};
        tags[newProp][RegExp.$2] = element;
        delete tags[prop];
    } else if (prop.match(/\+/)) {
        tags[prop.replace("+", "_Add")] = element;
        delete tags[prop];
    } else if (prop.match(/\%/)) {
        tags[prop.replace("%", "_Rate")] = element;
        delete tags[prop];
    }
    if (String(element).match(",")) {
        var array = LeUtilities.stringToArray(element);
        if (prop.contains("+") || prop.contains("%"))
            newProp = prop.replace("+", "Array_Add").replace("%", "Array_Rate");
        else
            newProp = prop + "Array";
        if (array.length === 2) {
            tags[newProp.replace("Array", "X")] = array[0];
            tags[newProp.replace("Array", "Y")] = array[1];
        }
        tags[newProp] = array;
    }
};

Scene_Boot.prototype.parseLeTBSTag = function (prop, obj, tags) {

};

DataManager.processLeTBSTagsForBattlers = function () {
    var groups = [$dataActors, $dataEnemies, $dataClasses];
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            var notedata = obj.note.split(/[\r\n]+/);
            var letbs = false;

            obj._leTbsCustomTags = {};
            obj.leTBS_Tags = {};

            obj.TagsLetbs.movePoints = Lecode.S_TBS.defaultMovePoints;
            obj.TagsLetbs.moveScope = Lecode.S_TBS.defaultMoveScope;
            obj.TagsLetbs.moveScopeOptions = "";
            obj.TagsLetbs.atkAnim = Lecode.S_TBS.defaultAttackAnimation;
            obj.TagsLetbs.atkScope = Lecode.S_TBS.defaultAttackScope;
            obj.TagsLetbs.atkAoe = Lecode.S_TBS.defaultAttackAoE;
            obj.TagsLetbs.atkSequenceData = Lecode.S_TBS.defaultAttackSequence;
            obj.TagsLetbs.oneTimeMove = Lecode.S_TBS.oneTimeMove;
            obj.TagsLetbs.oneTimeOffense = Lecode.S_TBS.oneTimeOffense;
            obj.TagsLetbs.collapseAnim = Lecode.S_TBS.collapseAnimation;
            obj.TagsLetbs.passOnAtkUse = false;
            obj.TagsLetbs.aiPattern = Lecode.S_TBS.defaultAiPattern;
            obj.TagsLetbs.passable = false;
            obj.TagsLetbs.passableOnDeath = false;
            obj.TagsLetbs.hasNoCorpse = false;
            obj.TagsLetbs.canStayOnMe = false;
            obj.TagsLetbs.canStayOnMeOnDeath = false;
            obj.TagsLetbs.collisionDmgBonus = 0;
            obj.TagsLetbs.collisionDmgBonusRate = 0;
            obj.TagsLetbs.collisionDmgReduction = 0;
            obj.TagsLetbs.collisionDmgReductionRate = 0;
            obj.TagsLetbs.immuneKnockback = false;
            obj.TagsLetbs.knockbackBonus = 0;
            obj.TagsLetbs.knockbackReduction = 0;
            obj.TagsLetbs.directionalDmgBonus = {
                front: 0,
                back: 0,
                side: 0
            };
            obj.TagsLetbs.directionalDmgReduction = {
                front: 0,
                back: 0,
                side: 0
            };
            obj.TagsLetbs.spriteName = null;
            obj.TagsLetbs.spriteConfig = null;
            obj.TagsLetbs.hideStatusWindow = false;
            obj.TagsLetbs.spriteScaleX = 1.0;
            obj.TagsLetbs.spriteScaleY = 1.0;
            obj.TagsLetbs.spriteTone = [0, 0, 0, 0];
            obj.TagsLetbs.spriteHue = 0;
            obj.TagsLetbs.loopAnimation = null;
            obj.TagsLetbs.aiNoAttack = false;
            obj.TagsLetbs.aiControl = false;
            obj.TagsLetbs.sequencesOverload = {};

            for (var k = 0; k < notedata.length; k++) {
                var line = notedata[k];
                if (line.match(/<letbs>/i)) {
                    letbs = true;
                    continue;
                } else if (line.match(/<\/letbs>/i))
                    letbs = false;

                if (letbs) {
                    if (line.match(/move_points\s?:\s?(.+)/i))
                        obj.TagsLetbs.movePoints = Number(RegExp.$1);
                    else if (line.match(/move_scope\s?:\s?(.+)/i))
                        obj.TagsLetbs.moveScope = String(RegExp.$1);
                    else if (line.match(/move_scope_options\s?:\s?((.|\n)*)/i))
                        obj.TagsLetbs.moveScopeOptions = String(RegExp.$1);
                    else if (line.match(/atk_anim\s?:\s?(.+)/i))
                        obj.TagsLetbs.atkAnim = Number(RegExp.$1);
                    else if (line.match(/atk_scope\s?:\s?(.+)/i))
                        obj.TagsLetbs.atkScope = String(RegExp.$1);
                    else if (line.match(/atk_aoe\s?:\s?(.+)/i))
                        obj.TagsLetbs.atkAoe = String(RegExp.$1);
                    else if (line.match(/atk_sequence\s?:\s?(.+)/i))
                        obj.TagsLetbs.atkSequence = String(RegExp.$1);
                    else if (line.match(/one_time_move/i))
                        obj.TagsLetbs.oneTimeMove = true;
                    else if (line.match(/one_time_offense/i))
                        obj.TagsLetbs.oneTimeOffense = true;
                    else if (line.match(/collapse_anim\s?:\s?(.+)/i))
                        obj.TagsLetbs.collapseAnim = Number(RegExp.$1);
                    else if (line.match(/pass_on_atk_use/i))
                        obj.TagsLetbs.passOnAtkUse = true;
                    else if (line.match(/ai_pattern\s?:\s?(.+)/i))
                        obj.TagsLetbs.aiPattern = String(RegExp.$1);
                    else if (line.match(/passable_on_death/i))
                        obj.TagsLetbs.passableOnDeath = true;
                    else if (line.match(/passable/i))
                        obj.TagsLetbs.passable = true;
                    else if (line.match(/has_no_corpse/i))
                        obj.TagsLetbs.hasNoCorpse = true;
                    else if (line.match(/entities_can_stay_on_me/i))
                        obj.TagsLetbs.canStayOnMe = true;
                    else if (line.match(/entities_can_stay_on_me_on_death/i))
                        obj.TagsLetbs.canStayOnMeOnDeath = true;
                    else if (line.match(/collision_damage_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionDmgBonus = Number(RegExp.$1);
                    else if (line.match(/collision_damage_bonus\%\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionDmgBonusRate = Number(RegExp.$1);
                    else if (line.match(/collision_damage_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionDmgReduction = Number(RegExp.$1);
                    else if (line.match(/collision_damage_reduction\%\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionDmgReductionRate = Number(RegExp.$1);
                    else if (line.match(/immune_knockback/i))
                        obj.TagsLetbs.immuneKnockback = true;
                    else if (line.match(/knockback_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.knockbackBonus = Number(RegExp.$1);
                    else if (line.match(/knockback_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.knockbackReduction = Number(RegExp.$1);
                    else if (line.match(/back_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.back = Number(RegExp.$1);
                    else if (line.match(/back_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.back = Number(RegExp.$1);
                    else if (line.match(/front_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.front = Number(RegExp.$1);
                    else if (line.match(/front_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.front = Number(RegExp.$1);
                    else if (line.match(/side_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.side = Number(RegExp.$1);
                    else if (line.match(/side_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.side = Number(RegExp.$1);
                    else if (line.match(/sprite_name\s?:\s?(.+)/i))
                        obj.TagsLetbs.spriteName = String(RegExp.$1);
                    else if (line.match(/sprite_config\s?:\s?(.+)/i))
                        obj.TagsLetbs.spriteConfig = String(RegExp.$1);
                    else if (line.match(/hide_status_window/i))
                        obj.TagsLetbs.hideStatusWindow = true;
                    else if (line.match(/sprite_scale\s?:\s?(.+)/i)) {
                        var str = RegExp.$1.split(",");
                        obj.TagsLetbs.spriteScaleX = Number(str[0].trim());
                        obj.TagsLetbs.spriteScaleY = Number(str[1].trim());
                    }
                    else if (line.match(/sprite_tone\s?:\s?(.+)/i)) {
                        var str = RegExp.$1.split(",");
                        var r = Number(str[0].trim());
                        var g = Number(str[1].trim());
                        var b = Number(str[1].trim());
                        var gray = Number(str[1].trim());
                        obj.TagsLetbs.spriteTone = [r, g, b, gray];
                    }
                    else if (line.match(/sprite_hue\s?:\s?(.+)/i))
                        obj.TagsLetbs.spriteHue = Number(RegExp.$1);
                    else if (line.match(/loop_animation\s?:\s?(.+)/i))
                        obj.TagsLetbs.loopAnimation = Number(RegExp.$1);
                    else if (line.match(/ai_no_attack/i))
                        obj.TagsLetbs.aiNoAttack = true;
                    else if (line.match(/ai_control/i))
                        obj.TagsLetbs.aiControl = true;
                    else if (line.match(/sequence\((.+)\)\s?:\s?(.+)/i))
                        obj.TagsLetbs.sequencesOverload[RegExp.$1] = RegExp.$2;

                    else if (line.match(/(.+)\s?:\s?(.+)/i)) {
                        obj._leTbsCustomTags[RegExp.$1] = RegExp.$2;
                    }
                }
            }
        }
    }
};

DataManager.processLeTBSTagsForEquipmentsAndStates = function () {
    var groups = [$dataWeapons, $dataArmors, $dataStates];
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            var notedata = obj.note.split(/[\r\n]+/);
            var letbs = false;

            obj._leTbsCustomTags = {};
            obj.TagsLetbs.movePointsPlus = 0;
            obj.TagsLetbs.scope = null;
            obj.TagsLetbs.aoe = null;
            obj.TagsLetbs.sequence = null;
            obj.TagsLetbs.moveScope = null;
            obj.TagsLetbs.moveScopeOptions = null;
            obj.TagsLetbs.passable = false;
            obj.TagsLetbs.passableOnDeath = false;
            obj.TagsLetbs.hasNoCorpse = false;
            obj.TagsLetbs.canStayOnMe = false;
            obj.TagsLetbs.canStayOnMeOnDeath = false;
            obj.TagsLetbs.collisionDmgBonus = 0;
            obj.TagsLetbs.collisionDmgBonusRate = 0;
            obj.TagsLetbs.collisionDmgReduction = 0;
            obj.TagsLetbs.collisionDmgReductionRate = 0;
            obj.TagsLetbs.immuneKnockback = false;
            obj.TagsLetbs.knockbackBonus = 0;
            obj.TagsLetbs.knockbackReduction = 0;
            obj.TagsLetbs.directionalDmgBonus = {
                front: 0,
                back: 0,
                side: 0
            };
            obj.TagsLetbs.directionalDmgReduction = {
                front: 0,
                back: 0,
                side: 0
            };
            obj.TagsLetbs.onlyDeadTargets = false;
            obj.TagsLetbs.allowDeadTargets = false;
            obj.TagsLetbs.loopAnimation = null;
            obj.TagsLetbs.focusedByAiFor = {};
            obj.TagsLetbs.aiControl = false;
            obj.TagsLetbs.sequencesOverload = {};
            obj.TagsLetbs.spriteName = null;
            obj.TagsLetbs.spriteConfig = null;

            for (var k = 0; k < notedata.length; k++) {
                var line = notedata[k];
                if (line.match(/<letbs>/i))
                    letbs = true;
                else if (line.match(/<\/letbs>/i))
                    letbs = false;

                if (letbs) {
                    if (line.match(/move_points\s?:\s?(.+)/i))
                        obj.TagsLetbs.movePointsPlus = Number(RegExp.$1);
                    else if (line.match(/scope\s?:\s?(.+)/i))
                        obj.TagsLetbs.scope = String(RegExp.$1);
                    else if (line.match(/aoe\s?:\s?(.+)/i))
                        obj.TagsLetbs.aoe = String(RegExp.$1);
                    else if (line.match(/sequence\s?:\s?(.+)/i))
                        obj.TagsLetbs.sequence = String(RegExp.$1);
                    else if (line.match(/move_scope\s?:\s?(.+)/i))
                        obj.TagsLetbs.moveScope = String(RegExp.$1);
                    else if (line.match(/move_scope_options\s?:\s?((.|\n)*)/i))
                        obj.TagsLetbs.moveScopeOptions = String(RegExp.$1);
                    else if (line.match(/passable_on_death/i))
                        obj.TagsLetbs.passableOnDeath = true;
                    else if (line.match(/passable/i))
                        obj.TagsLetbs.passable = true;
                    else if (line.match(/has_no_corpse/i))
                        obj.TagsLetbs.hasNoCorpse = true;
                    else if (line.match(/entities_can_stay_on_me/i))
                        obj.TagsLetbs.canStayOnMe = true;
                    else if (line.match(/entities_can_stay_on_me_on_death/i))
                        obj.TagsLetbs.canStayOnMeOnDeath = true;
                    else if (line.match(/collision_damage_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionDmgBonus = Number(RegExp.$1);
                    else if (line.match(/collision_damage_bonus\%\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionDmgBonusRate = Number(RegExp.$1);
                    else if (line.match(/collision_damage_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionDmgReduction = Number(RegExp.$1);
                    else if (line.match(/collision_damage_reduction\%\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionDmgReductionRate = Number(RegExp.$1);
                    else if (line.match(/immune_knockback/i))
                        obj.TagsLetbs.immuneKnockback = true;
                    else if (line.match(/knockback_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.knockbackBonus = Number(RegExp.$1);
                    else if (line.match(/knockback_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.knockbackReduction = Number(RegExp.$1);
                    else if (line.match(/knockback_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.knockbackBonus = Number(RegExp.$1);
                    else if (line.match(/knockback_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.knockbackReduction = Number(RegExp.$1);
                    else if (line.match(/back_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.back = Number(RegExp.$1);
                    else if (line.match(/back_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.back = Number(RegExp.$1);
                    else if (line.match(/front_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.front = Number(RegExp.$1);
                    else if (line.match(/front_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.front = Number(RegExp.$1);
                    else if (line.match(/side_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.side = Number(RegExp.$1);
                    else if (line.match(/side_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.side = Number(RegExp.$1);
                    else if (line.match(/only_dead_targets/i))
                        obj.TagsLetbs.onlyDeadTargets = true;
                    else if (line.match(/allow_dead_targets/i))
                        obj.TagsLetbs.allowDeadTargets = true;
                    else if (line.match(/loop_animation\s?:\s?(.+)/i))
                        obj.TagsLetbs.loopAnimation = Number(RegExp.$1);
                    else if (line.match(/focused_by_ai_for_(.+)\s?:\s?(.+)/i))
                        obj.TagsLetbs.focusedByAiFor[RegExp.$1] = Number(RegExp.$2);
                    else if (line.match(/ai_control/i))
                        obj.TagsLetbs.aiControl = true;
                    else if (line.match(/sequence\((.+)\)\s?:\s?(.+)/i))
                        obj.TagsLetbs.sequencesOverload[RegExp.$1] = RegExp.$2;
                    else if (line.match(/sprite_name\s?:\s?(.+)/i))
                        obj.TagsLetbs.spriteName = String(RegExp.$1);
                    else if (line.match(/sprite_config\s?:\s?(.+)/i))
                        obj.TagsLetbs.spriteConfig = String(RegExp.$1);

                    else if (line.match(/(.+)\s?:\s?(.+)/i)) {
                        obj._leTbsCustomTags[RegExp.$1] = RegExp.$2;
                    }
                }
            }
        }
    }
};

DataManager.processLeTBSTagsForObjects = function () {
    var groups = [$dataSkills, $dataItems, $dataWeapons];
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            var notedata = obj.note.split(/[\r\n]+/);
            var letbs = false;
            var letbs_ai = false;
            var letbs_sequence = false;

            obj._leTbsCustomTags = {};
            obj.TagsLetbs.scope = null;
            obj.TagsLetbs.scopeSelect = null;
            obj.TagsLetbs.aoe = null;
            obj.TagsLetbs.sequence = null;
            obj.TagsLetbs.passOnUse = false;
            obj.TagsLetbs.maxUse = 1;
            obj.TagsLetbs.scopeOptions = [];
            obj.TagsLetbs.aoeOptions = [];
            obj.TagsLetbs.collisionFormula = null;
            obj.TagsLetbs.directionalDmgBonus = {
                front: 0,
                back: 0,
                side: 0
            };
            obj.TagsLetbs.directionalDmgReduction = {
                front: 0,
                back: 0,
                side: 0
            };
            obj.TagsLetbs.aiConfig = {
                type: "",
                use_condition: "true",
                escape_condition: "true",
                rush_condition: "true",
                use_on_dead: false,
                maximise_targets: false,
                summon_near: "enemies",
                avoid_friendly_fire: 0
            };
            obj.TagsLetbs.sequence = [];
            obj.TagsLetbs.loopAnimation = null;
            obj.TagsLetbs.changeMovePoints = "0";

            for (var k = 0; k < notedata.length; k++) {
                var line = notedata[k];
                if (line.match(/<letbs>/i))
                    letbs = true;
                else if (line.match(/<\/letbs>/i))
                    letbs = false;
                else if (line.match(/<letbs_ai>/i))
                    letbs_ai = true;
                else if (line.match(/<\/letbs_ai>/i))
                    letbs_ai = false;
                else if (line.match(/<letbs_sequence>/i))
                    letbs_sequence = true;
                else if (line.match(/<\/letbs_sequence>/i))
                    letbs_sequence = false;

                if (letbs) {
                    if (line.match(/scope\s?:\s?(.+)/i))
                        obj.TagsLetbs.scope = String(RegExp.$1);
                    else if (line.match(/aoe\s?:\s?(.+)/i))
                        obj.TagsLetbs.aoe = String(RegExp.$1);
                    else if (line.match(/scope_select\s?:\s?(.+)/i))
                        obj.TagsLetbs.scopeSelect = String(RegExp.$1);
                    else if (line.match(/sequence\s?:\s?(.+)/i))
                        obj.TagsLetbs.sequence = String(RegExp.$1);
                    else if (line.match(/pass_on_use/i))
                        obj.TagsLetbs.passOnUse = true;
                    else if (line.match(/max_use:\s?:\s?(.+)/i))
                        obj.TagsLetbs.maxUse = Number(RegExp.$1);
                    else if (line.match(/scope_options\s?:\s?((.|\n)*)/i))
                        obj.TagsLetbs.scopeOptions = String(RegExp.$1);
                    else if (line.match(/aoe_options\s?:\s?((.|\n)*)/i))
                        obj.TagsLetbs.aoeOptions = String(RegExp.$1);
                    else if (line.match(/collision_formula\s?:\s?(.+)/i))
                        obj.TagsLetbs.collisionFormula = String(RegExp.$1);
                    else if (line.match(/knockback_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.knockbackBonus = Number(RegExp.$1);
                    else if (line.match(/knockback_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.knockbackReduction = Number(RegExp.$1);
                    else if (line.match(/back_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.back = Number(RegExp.$1);
                    else if (line.match(/back_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.back = Number(RegExp.$1);
                    else if (line.match(/front_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.front = Number(RegExp.$1);
                    else if (line.match(/front_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.front = Number(RegExp.$1);
                    else if (line.match(/side_dmg_bonus\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgBonus.side = Number(RegExp.$1);
                    else if (line.match(/side_dmg_reduction\s?:\s?(.+)/i))
                        obj.TagsLetbs.directionalDmgReduction.side = Number(RegExp.$1);
                    else if (line.match(/loop_animation\s?:\s?(.+)/i))
                        obj.TagsLetbs.loopAnimation = Number(RegExp.$1);
                    else if (line.match(/change_move_points\s?:\s?(.+)/i))
                        obj.TagsLetbs.changeMovePoints = String(RegExp.$1);

                    else if (line.match(/(.+)\s?:\s?(.+)/i)) {
                        obj._leTbsCustomTags[RegExp.$1] = RegExp.$2;
                    }
                }
                else if (letbs_ai) {
                    if (line.match(/type\s?:\s?(.+)/i))
                        obj.TagsLetbs.aiConfig.type = String(RegExp.$1);
                    else if (line.match(/use_condition\s?:\s?(.+)/i))
                        obj.TagsLetbs.aiConfig.use_condition = String(RegExp.$1);
                    else if (line.match(/escape_condition\s?:\s?(.+)/i))
                        obj.TagsLetbs.aiConfig.escape_condition = String(RegExp.$1);
                    else if (line.match(/rush_condition\s?:\s?(.+)/i))
                        obj.TagsLetbs.aiConfig.rush_condition = String(RegExp.$1);
                    else if (line.match(/use_on_dead/i))
                        obj.TagsLetbs.aiConfig.use_on_dead = true;
                    else if (line.match(/maximise_targets/i))
                        obj.TagsLetbs.aiConfig.maximise_targets = true;
                    else if (line.match(/avoid_friendly_fire\s?:\s?(.+)\%/i))
                        obj.TagsLetbs.aiConfig.avoid_friendly_fire = Number(RegExp.$1) * 0.01;
                    else if (line.match(/summon_near\s?:\s?(.+)/i))
                        obj.TagsLetbs.aiConfig.summon_near = String(RegExp.$1);
                }
                else if (letbs_sequence) {
                    obj.TagsLetbs.sequence.push(line);
                }
            }
        }
    }
};

/*-------------------------------------------------------------------------
* ImageManager
-------------------------------------------------------------------------*/
ImageManager.loadLeTBS = function (filename, hue) {
    return this.loadBitmap('img/leTBS/', filename, hue, true);
};

ImageManager.loadLeTBSBattler = function (filename, hue) {
    return this.loadBitmap('img/leTBS/Battlers/', filename, hue, true);
};

ImageManager.loadLeTBSStatus = function (filename, hue) {
    return this.loadBitmap('img/leTBS/Status/', filename, hue, true);
};

ImageManager.loadLeTBSProjectile = function (filename, hue) {
    return this.loadBitmap('img/leTBS/Projectiles/', filename, hue, true);
};

ImageManager.loadLeTBSWeaponSprite = function (filename, hue) {
    return this.loadBitmap('img/leTBS/Weapons/', filename, hue, true);
};

ImageManager.loadLeTBS("Battle_Start");