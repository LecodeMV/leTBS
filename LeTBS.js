/*
#=============================================================================
# Lecode's Tactical Battle System
# LeTBS.js
# By Lecode
# Version 0.61
#-----------------------------------------------------------------------------
# TERMS OF USE
#-----------------------------------------------------------------------------
# https://github.com/LecodeMV/leTBS/blob/master/LICENSE.txt
#-----------------------------------------------------------------------------
# Version History
#-----------------------------------------------------------------------------
# - 0.0 : Beta started.
# - 0.1 : Battles start and end correctly.
#	      Troop events are correctly triggered in battle. (mostly)
#		  Added an end window which appears when pressing ESC on the command window.
#		  That window allows you to escape and change options.
#		  Added the tags and parameters for one time move only and one time offense only.
#		  Fixed some errors in the demo.
# - 0.2 : The Item command is functional.
#		  Added custom move scopes and options.
#		  Downgraded the turn order visual for now to fix some bugs.
#		  Added a new option for turn order: "fair repartition".
#		  Status window is updated when a target is selected.
#		  There's now a help window. Status window is shifted if needed.
# - 0.3 : The mouse is supported.
#		  Prototype of the projectiles system.
#		  Prototype of the AI.
#		  Fixed a bug and improved the Turn Order Visual Version A.
#		  85% of the tile effects and marks system.
#		  Fixed a bug with the line of sight.
# - 0.4 : Now there is ony one unique tag.
#		  Support custom sprites. (Yay !)
#		  AI improved.
#		  Added AI patterns. They can be used in AI commands.
#		  Now each entity has his own sequence system. This allows simultaneous sequences.
#		  Added some sequence commands.
#		  Now a sequence is played for the following events:
#		  battle start, turn start, victory, death, damaged, healed, buffed, weakened.
# - 0.5 : Projectile system completed
#         Tile, Mark & Aura effects completed
#         Added knockback damage
#         Fixed and added some sequence commands
#         Fixed some bugs
#         Created DamagePopupEX
# - 0.6 : Added these sequence commands: 'call_for_every_cell', 'call_for_every_entity', 'reach_target'
#         Added these sequence commands: 'save_cells', 'save_entities'
#         Added these tag instructions: 'sprite_name' and 'sprite_config'
#         Added a region ID to setup non-walkable tile but free for the line of sight (water)
#         Improved AI
#         Reduced lag generated by AI process
#         Created Win Conditions ADD-ON
#         New feature: TBS Events and Neutral entities
#         Map events are now supported - battlers can interact with them.
#         Support directional scope
#         Added a new scope type: path
#         Added an option to instantiate all enemies at the same time
#         Start messages can be disabled
#         Added some plugin command for in-battle eventing
#         Added some event tag for in-battle eventing
#         Fixed a bug where the system freezes on positioning phase
#         Fixed the "param is not defined" error when an enemy starts its turn
#         Fixed a bug where custom scopes ignore line of sight
#         Fixed parallax scrolling when the cursor move
#         Fixed a bug where move points could be negative
#         Fixed a bug where knockback distance could be negative
#         Fixed a bug where the game crashes when AI try to resume a move action
#         The entities layer has now a correct Z coordinate
#         Fixed a bug where entities overlap themselves
#         Fixed a bug where the scope and marks layers weren't visible
#         When the active entity die, the scope layer is correctly cleared
#         Dead enemies don't try to play their turn anymore
#         Dead actors can't be placed at the start of battles
#         Battlers are correctly revived
#         The turn order visual is correctly updated when en entity is revived
#         The wait parameter for tile effects is correctly applied
#         The parameter 'false' in the sequence commands 'push' and 'pull' to avoid 
#           knockback damage now works as intended
#         Fixed 2 bugs related to the mark and tile effect add-on and improved it (1.1)
#         Selected cells with TouchInput on large map are correctly handled
# - 0.61 : Optimized cells locating
#          Added a trigger type for battle end
# - 0.7 : Reworked the battle HUD
#         Improved the positioning phase, you can also specify fixed actor cells
#         The positioning phase is now correctly resumed
#         The mouse is now correctly supported during the positioning phase
#         Defeat is now based on actors in battle and not the whole party (bugfix)
#         Added a minimal parameter to scopes
#         Scopes and AoEs parameters are now evaluated
#         Added smooth map scrolling in battle
#         Added a parameter to hide AI's scopes
#         Counter attacks and magic reflection are now supported
#         Added a summon system (add-on)
#         The system now automatically use RPT ressources (add-on)
#         Added these sequence commands: switch_cells, use_skill
#         Added a fast sequence system as well as arguments for sequences
#         Added a HUD that appear on an entity when the mouse is over it (add-on)
#         Added some tag instructions to change sprite scale, tone and hue
#         Added a tag "has_no_corpse" to hide an entity's corpse
#         Added states and equipment animations in battle
#         The tag sprite_name is correctly taken into account into these components: Turn Order, Window Status
#         The selected AoE now blinks
#         Greatly improved targets and cells selection in sequences
#         The AI Core is completed: all behavior are supported
#         The AI correctly use its skills and doesn't stick with just one
#         The AI correctly calculate the closest/farhest path to a given cell (no more stuck by obstacles)
#         The AI uses smartly AoE skills to hit, heal or boost multiple targets
#         The AI can use move skills to escape or reach targets
#         The AI doesn't escape anymore if it's already too far from actors (prevents endless battles)
#         Added a parameter to define how much AI should try to escape (prevents endless battles)
#         The AI now handles confusion states
#         Added a parameter so delay AI calculation rate, in order to prevent freezes
#         Added a configuration tag for AI
#         Fixed a bug where collapse effects are triggered multiple times
#         Projectiles are now summoned for each cell in the AoE
#         The turn order is now correctly determined
#         Command, Skill and Item windows are now correctly positioned
#         Skills can now directly alter move points
#         Move points popup is now added
#         Fixed a bug where triggering tiles and mark effects change the next
#         action damage
#=============================================================================
*/
var Imported = Imported || {};
Imported["LeTBS"] = true;

var Lecode = Lecode || {};
Lecode.S_TBS = {};
/*:
 * @plugindesc A tactical battle system with awesome features
 * @author Lecode
 * @version 0.61
*
*
* @param Actor Color Cell
* @desc Color of actor cells.
* @default #0FC50B
*
* @param Enemy Color Cell
* @desc Color of enemy cells.
* @default #C50B1B
*
* @param Cell Opacity Color
* @desc Opacity of the positioning cells.
* @default 175
*
* @param Placed Animation
* @desc Animation ID when a battler is placed.
* @default 124
*
* @param Instantiate All
* @desc Instantiate all enemies at the same time.
* @default true
*
* @param Display Start Messages
* @desc Show start messages ?
* @default false
*
* @param -- Misc --
* @desc ...
* @default 
*
* @param Exploration Input
* @desc Input to trigger exploration.
* @default shift
*
* @param Opacity Input
* @desc Input to change windows' opacity.
* @default control
*
* @param Min Input Opacity
* @desc Minimum opacity of windows.
* @default 0
*
* @param Opacity Steps
* @desc Value of opacity to reduce when inputed.
* @default 10
*
* @param Battle Start Sprite Delay
* @desc Duration of the battle start sprite.
* @default 50
*
* @param Turn Order Fair Repartition ?
* @desc Allow a fair repartition of the turn order ?
* @default true
*
* @param Destination Duration
* @desc Duration of the destination sprite (when a cell is selected).
* @default 60
*
* @param -- Scopes --
* @desc ...
* @default 
*
* @param Scope Cell Width
* @desc Width of cells.
* @default 46
*
* @param Scope Cell Height
* @desc Height of cells. 
* @default 46
*
* @param Obstacle Region Id
* @desc Region ID for obstacles.
* @default 250
*
* @param Free Obstacle Region Id
* @desc Region ID for non-blocking los obstacles.
* @default 249
*
* @param -- Move Action --
* @desc ...
* @default 
*
* @param Default Move Scope
* @desc Default move scope data.
* @default circle(_mp_)
*
* @param Default Move Points
* @desc Default amount of move points.
* @default 3
*
* @param Move Scope Color
* @desc Color of the move scope.
* @default #0A5C85
*
* @param Move Scope Opacity
* @desc Opacity of the move scope.
* @default 175
*
* @param Invalid Move Scope Opacity
* @desc Opacity of the move scope when cells are invalid.
* @default 60
*
* @param Selected Move Scope Opacity
* @desc Opacity of the move scope when cells are selected.
* @default 255
*
* @param Selected Move Scope Color
* @desc Color of the selected move scope.
* @default #81F7F3
*
* @param Enable Directional Facing
* @desc Battlers will be allowed to change their direction.
* @default true
*
* @param -- Attack Action --
* @desc ...
* @default 
*
* @param Default Attack Animation
* @desc Default attack animation.
* @default 1
*
* @param Default Attack Sequence
* @desc Default attack sequence.
* @default atk
*
* @param Default Attack Scope
* @desc Default attack scope data.
* @default circle(1)
*
* @param Default Attack Ao E
* @desc Default attack aoe data.
* @default circle(0)
*
* @param Attack Scope Color
* @desc Color of the attack scope.
* @default #E20F2B
*
* @param Attack Scope Opacity
* @desc Opacity of the attack scope.
* @default 175
*
* @param Invalid Attack Scope Opacity
* @desc Opacity of the attack scope when cells are invalid.
* @default 60
*
* @param Selected Attack Scope Color
* @desc Color of the attack scope.
* @default #FB3B54
*
* @param Selected Attack Scope Opacity
* @desc Opacity of the attack scope when cells are selected.
* @default 255
*
* @param -- Skill Action --
* @desc ...
* @default 
*
* @param Default Skill Sequence
* @desc Default skill sequence.
* @default skill
*
* @param Default Skill Scope
* @desc Default skill scope data.
* @default circle(3)
*
* @param Default Skill Ao E
* @desc Default skill aoe data.
* @default circle(0)
*
* @param Skill Scope Color
* @desc Color of the skill scope.
* @default #E20F2B
*
* @param Skill Scope Opacity
* @desc Opacity of the skill scope.
* @default 175
*
* @param Invalid Skill Scope Opacity
* @desc Opacity of the skill scope when cells are invalid.
* @default 60
*
* @param Selected Skill Scope Color
* @desc Color of the selected skill scope.
* @default #FB3B54
*
* @param Selected Skill Scope Opacity
* @desc Opacity of the skill scope when cells are selected.
* @default 255
*
* @param -- Item Action --
* @desc ...
* @default 
*
* @param Default Item Sequence
* @desc Default item sequence.
* @default item
*
* @param Default Item Scope
* @desc Default item scope data.
* @default circle(3)
*
* @param Default Item Ao E
* @desc Default item aoe data.
* @default circle(0)
*
* @param Item Scope Color
* @desc Color of the item scope.
* @default #DF01D7
*
* @param Item Scope Opacity
* @desc Opacity of the item scope.
* @default 175
*
* @param Invalid Item Scope Opacity
* @desc Opacity of the item scope when cells are invalid.
* @default 60
*
* @param Selected Item Scope Color
* @desc Color of selected the item scope.
* @default #F969F4
*
* @param Selected Item Scope Opacity
* @desc Opacity of the item scope when cells are selected.
* @default 255
*
* @param -- Directional Damage --
* @desc ...
* @default 
*
* @param Back Directional Damage Effects
* @desc Damage % when a battler is hit on the back.
* @default 15
*
* @param Side Directional Damage Effects
* @desc Damage % when a battler is hit on the sides.
* @default 0
*
* @param Face Directional Damage Effects
* @desc Damage % when a battler is hit on the face.
* @default -10
*
* @param -- Collision Damage --
* @desc ...
* @default 
*
* @param Default Collision Formula
* @desc Formula to evaluate collision damage.
* @default b.mhp * 0.05 * (distance-covered)
*
* @param Collission Damage Chain Rate
* @desc Collision damage chain rate.
* @default 0.3
*
* @param -- Motions --
* @desc ...
* @default 
*
* @param Battlers Move Speed
* @desc Default move speed.
* @default 4
*
* @param Battlers Frame Delay
* @desc Default delay value between sprites frames.
* @default 10
*
* @param -- AI --
* @desc ...
* @default 
*
* @param Default Ai Pattern
* @desc Default AI pattern.
* @default melee_fighter
*
* @param Ai Wait Time
* @desc AI wait time.
* @default 5
*
* @param Show Scopes
* @desc ...
* @default false
*
* @param Escape Cooldown
* @desc ...
* @default 2
*
* @param Support Cooldown
* @desc ...
* @default 1
*
* @param Ai Process Delay
* @desc ...
* @default 5
*
* @param -- Actions Restrictions --
* @desc ...
* @default 
*
* @param One Time Move
* @desc Enable the one time move feature. (See doc)
* @default false
*
* @param One Time Offense
* @desc Enable the one time offense feature. (See doc)
* @default true
*
* @param Auto Pass
* @desc Enable the auto pass feature. (See doc)
* @default true
*
* @param -- Battle End --
* @desc ...
* @default 
*
* @param Escape Sound
* @desc Sound when the party try to escape.
* @default Buzzer2
*
* @param End Of Battle Wait
* @desc Wait amount before the end of the battle.
* @default 60
*
* @param Collapse Animation
* @desc Default collapse animation.
* @default 136
*
*
 * @help
 * See the documentation
 */
//#=============================================================================


/*-------------------------------------------------------------------------
* Get Parameters
-------------------------------------------------------------------------*/
var parameters = PluginManager.parameters('LeTBS');

Lecode.S_TBS.actorColorCell = String(parameters["Actor Color Cell"] || "#0FC50B")	;	//	(): Color of actor cells.
Lecode.S_TBS.enemyColorCell = String(parameters["Enemy Color Cell"] || "#C50B1B")	;	//	(): Color of enemy cells.
Lecode.S_TBS.positioningCellOpacity = Number(parameters["Cell Opacity Color"] || 175)	;	//	(Cell Opacity Color): Opacity of the positioning cells.
Lecode.S_TBS.placedBattlerAnim = Number(parameters["Placed Animation"] || 124)	;	//	(Placed Animation): Animation ID when a battler is placed.
Lecode.S_TBS.instantiateAll = String(parameters["Instantiate All"] || 'true') === 'true'	;	//	(): Instantiate all enemies at the same time.
Lecode.S_TBS.displayStartMessages = String(parameters["Display Start Messages"] || 'false') === 'true'	;	//	(): Show start messages ?
// Divider: -- Misc --
Lecode.S_TBS.explorationInput = String(parameters["Exploration Input"] || "shift")	;	//	(): Input to trigger exploration.
Lecode.S_TBS.opacityInput = String(parameters["Opacity Input"] || "control")	;	//	(): Input to change windows' opacity.
Lecode.S_TBS.minInputOpacity = Number(parameters["Min Input Opacity"] || 0)	;	//	(): Minimum opacity of windows.
Lecode.S_TBS.inputOpacityDecreaseSteps = Number(parameters["Opacity Steps"] || 10)	;	//	(Opacity Steps): Value of opacity to reduce when inputed.
Lecode.S_TBS.battleStartSpriteDelay = Number(parameters["Battle Start Sprite Delay"] || 50)	;	//	(): Duration of the battle start sprite.
Lecode.S_TBS.turnOrderFairRepartition = String(parameters["Turn Order Fair Repartition ?"] || 'true') === 'true'	;	//	(Turn Order Fair Repartition ?): Allow a fair repartition of the turn order ?
Lecode.S_TBS.destinationDuration = Number(parameters["Destination Duration"] || 60)	;	//	(): Duration of the destination sprite (when a cell is selected).
// Divider: -- Scopes --
Lecode.S_TBS.scopeCellWidth = Number(parameters["Scope Cell Width"] || 46)	;	//	(): Width of cells.
Lecode.S_TBS.scopeCellHeight = Number(parameters["Scope Cell Height"] || 46)	;	//	(): Height of cells. 
Lecode.S_TBS.obstacleRegionId = Number(parameters["Obstacle Region Id"] || 250)	;	//	(): Region ID for obstacles.
Lecode.S_TBS.freeObstacleRegionId = Number(parameters["Free Obstacle Region Id"] || 249)	;	//	(): Region ID for non-blocking los obstacles.
// Divider: -- Move Action --
Lecode.S_TBS.defaultMoveScope = String(parameters["Default Move Scope"] || "circle(_mp_)")	;	//	(): Default move scope data.
Lecode.S_TBS.defaultMovePoints = Number(parameters["Default Move Points"] || 3)	;	//	(): Default amount of move points.
Lecode.S_TBS.moveColorCell = String(parameters["Move Scope Color"] || "#0A5C85")	;	//	(Move Scope Color): Color of the move scope.
Lecode.S_TBS.moveCellOpacity = Number(parameters["Move Scope Opacity"] || 175)	;	//	(Move Scope Opacity): Opacity of the move scope.
Lecode.S_TBS.moveInvalidCellOpacity = Number(parameters["Invalid Move Scope Opacity"] || 60)	;	//	(Invalid Move Scope Opacity): Opacity of the move scope when cells are invalid.
Lecode.S_TBS.moveSelectedCellOpacity = Number(parameters["Selected Move Scope Opacity"] || 255)	;	//	(Selected Move Scope Opacity): Opacity of the move scope when cells are selected.
Lecode.S_TBS.selectedMoveColorCell = String(parameters["Selected Move Scope Color"] || "#81F7F3")	;	//	(Selected Move Scope Color): Color of the selected move scope.
Lecode.S_TBS.enableDirectionalFacing = String(parameters["Enable Directional Facing"] || 'true') === 'true'	;	//	(): Battlers will be allowed to change their direction.
// Divider: -- Attack Action --
Lecode.S_TBS.defaultAttackAnimation = Number(parameters["Default Attack Animation"] || 1)	;	//	(): Default attack animation.
Lecode.S_TBS.defaultAttackSequence = String(parameters["Default Attack Sequence"] || "atk")	;	//	(): Default attack sequence.
Lecode.S_TBS.defaultAttackScope = String(parameters["Default Attack Scope"] || "circle(1)")	;	//	(): Default attack scope data.
Lecode.S_TBS.defaultAttackAoE = String(parameters["Default Attack Ao E"] || "circle(0)")	;	//	(): Default attack aoe data.
Lecode.S_TBS.attackColorCell = String(parameters["Attack Scope Color"] || "#E20F2B")	;	//	(Attack Scope Color): Color of the attack scope.
Lecode.S_TBS.attackCellOpacity = Number(parameters["Attack Scope Opacity"] || 175)	;	//	(Attack Scope Opacity): Opacity of the attack scope.
Lecode.S_TBS.attackInvalidCellOpacity = Number(parameters["Invalid Attack Scope Opacity"] || 60)	;	//	(Invalid Attack Scope Opacity): Opacity of the attack scope when cells are invalid.
Lecode.S_TBS.selectedAttackColorCell = String(parameters["Selected Attack Scope Color"] || "#FB3B54")	;	//	(Selected Attack Scope Color): Color of the attack scope.
Lecode.S_TBS.attackSelectedCellOpacity = Number(parameters["Selected Attack Scope Opacity"] || 255)	;	//	(Selected Attack Scope Opacity): Opacity of the attack scope when cells are selected.
// Divider: -- Skill Action --
Lecode.S_TBS.defaultSkillSequence = String(parameters["Default Skill Sequence"] || "skill")	;	//	(): Default skill sequence.
Lecode.S_TBS.defaultSkillScope = String(parameters["Default Skill Scope"] || "circle(3)")	;	//	(): Default skill scope data.
Lecode.S_TBS.defaultSkillAoE = String(parameters["Default Skill Ao E"] || "circle(0)")	;	//	(): Default skill aoe data.
Lecode.S_TBS.skillColorCell = String(parameters["Skill Scope Color"] || "#E20F2B")	;	//	(Skill Scope Color): Color of the skill scope.
Lecode.S_TBS.skillCellOpacity = Number(parameters["Skill Scope Opacity"] || 175)	;	//	(Skill Scope Opacity): Opacity of the skill scope.
Lecode.S_TBS.skillInvalidCellOpacity = Number(parameters["Invalid Skill Scope Opacity"] || 60)	;	//	(Invalid Skill Scope Opacity): Opacity of the skill scope when cells are invalid.
Lecode.S_TBS.selectedSkillColorCell = String(parameters["Selected Skill Scope Color"] || "#FB3B54")	;	//	(Selected Skill Scope Color): Color of the selected skill scope.
Lecode.S_TBS.skillSelectedCellOpacity = Number(parameters["Selected Skill Scope Opacity"] || 255)	;	//	(Selected Skill Scope Opacity): Opacity of the skill scope when cells are selected.
// Divider: -- Item Action --
Lecode.S_TBS.defaultItemSequence = String(parameters["Default Item Sequence"] || "item")	;	//	(): Default item sequence.
Lecode.S_TBS.defaultItemScope = String(parameters["Default Item Scope"] || "circle(3)")	;	//	(): Default item scope data.
Lecode.S_TBS.defaultItemAoE = String(parameters["Default Item Ao E"] || "circle(0)")	;	//	(): Default item aoe data.
Lecode.S_TBS.ItemColorCell = String(parameters["Item Scope Color"] || "#DF01D7")	;	//	(Item Scope Color): Color of the item scope.
Lecode.S_TBS.ItemCellOpacity = Number(parameters["Item Scope Opacity"] || 175)	;	//	(Item Scope Opacity): Opacity of the item scope.
Lecode.S_TBS.ItemInvalidCellOpacity = Number(parameters["Invalid Item Scope Opacity"] || 60)	;	//	(Invalid Item Scope Opacity): Opacity of the item scope when cells are invalid.
Lecode.S_TBS.selectedItemColorCell = String(parameters["Selected Item Scope Color"] || "#F969F4")	;	//	(Selected Item Scope Color): Color of selected the item scope.
Lecode.S_TBS.ItemSelectedCellOpacity = Number(parameters["Selected Item Scope Opacity"] || 255)	;	//	(Selected Item Scope Opacity): Opacity of the item scope when cells are selected.
// Divider: -- Directional Damage --
Lecode.S_TBS.backDirectionalDamageEffects = Number(parameters["Back Directional Damage Effects"] || 15)	;	//	(): Damage % when a battler is hit on the back.
Lecode.S_TBS.sideDirectionalDamageEffects = Number(parameters["Side Directional Damage Effects"] || 0)	;	//	(): Damage % when a battler is hit on the sides.
Lecode.S_TBS.faceDirectionalDamageEffects = Number(parameters["Face Directional Damage Effects"] || -10)	;	//	(): Damage % when a battler is hit on the face.
// Divider: -- Collision Damage --
Lecode.S_TBS.defaultCollisionFormula = String(parameters["Default Collision Formula"] || "b.mhp * 0.05 * (distance-covered)")	;	//	(): Formula to evaluate collision damage.
Lecode.S_TBS.collissionDamageChainRate = Number(parameters["Collission Damage Chain Rate"] || 0.3)	;	//	(): Collision damage chain rate.
// Divider: -- Motions --
Lecode.S_TBS.battlersMoveSpeed = Number(parameters["Battlers Move Speed"] || 4)	;	//	(): Default move speed.
Lecode.S_TBS.battlersFrameDelay = Number(parameters["Battlers Frame Delay"] || 10)	;	//	(): Default delay value between sprites frames.
// Divider: -- AI --
Lecode.S_TBS.defaultAiPattern = String(parameters["Default Ai Pattern"] || "melee_fighter")	;	//	(): Default AI pattern.
Lecode.S_TBS.aiWaitTime = Number(parameters["Ai Wait Time"] || 5)	;	//	(): AI wait time.
Lecode.S_TBS.showScopes = String(parameters["Show Scopes"] || 'false') === 'true';
Lecode.S_TBS.escapeCooldown = Number(parameters["Escape Cooldown"] || 2);
Lecode.S_TBS.supportCooldown = Number(parameters["Support Cooldown"] || 1);
Lecode.S_TBS.aiProcessDelay = Number(parameters["Ai Process Delay"] || 5);
// Divider: -- Actions Restrictions --
Lecode.S_TBS.oneTimeMove = String(parameters["One Time Move"] || 'false') === 'true'	;	//	(): Enable the one time move feature. (See doc)
Lecode.S_TBS.oneTimeOffense = String(parameters["One Time Offense"] || 'true') === 'true'	;	//	(): Enable the one time offense feature. (See doc)
Lecode.S_TBS.autoPass = String(parameters["Auto Pass"] || 'true') === 'true'	;	//	(): Enable the auto pass feature. (See doc)
// Divider: -- Battle End --
Lecode.S_TBS.escapeSound = String(parameters["Escape Sound"] || "Buzzer2")	;	//	(): Sound when the party try to escape.
Lecode.S_TBS.endOfBattleWait = Number(parameters["End Of Battle Wait"] || 60)	;	//	(): Wait amount before the end of the battle.
Lecode.S_TBS.collapseAnimation = Number(parameters["Collapse Animation"] || 136)	;	//	(): Default collapse animation.


/*-------------------------------------------------------------------------
* Spriteset_BattleTBS
-------------------------------------------------------------------------*/
function Spriteset_BattleTBS() {
    this.initialize.apply(this, arguments);
}

Spriteset_BattleTBS.prototype = Object.create(Spriteset_Map.prototype);
Spriteset_BattleTBS.prototype.constructor = Spriteset_BattleTBS;

Spriteset_BattleTBS.prototype.initialize = function () {
    Spriteset_Map.prototype.initialize.call(this);
    this.createTBSLayer();
    this.createBattleLayers();
};

Spriteset_BattleTBS.prototype.createCharacters = function () {
    this._characterSprites = [];
    $gameMap.events().forEach(function (event) {
        if (event.event().note.match(/<TBS Event>/i) || event.event().note.match(/<TBS Neutral (.+)>/i))
            this._characterSprites.push(new Sprite_Character(event));
    }, this);

    for (var i = 0; i < this._characterSprites.length; i++) {
        this._tilemap.addChild(this._characterSprites[i]);
    }
};

Spriteset_BattleTBS.prototype.createTBSLayer = function () {
    this._tbsLayer = new Sprite();
    this._tbsLayer.x = this._tilemap.x;
    this._tbsLayer.y = this._tilemap.y;
    this._tbsLayer.width = this._tilemap.width;
    this._tbsLayer.height = this._tilemap.height;
    this._baseSprite.addChild(this._tbsLayer);
};

Spriteset_BattleTBS.prototype.createBattleLayers = function () {
    //-Scopes
    this._scopesLayer = new TBSScopeLayer();
    this._scopesLayer.z = 1;
    this._tbsLayer.addChild(this._scopesLayer);
    this._scopesLayer.createSelectionLayer();
    //-Ground entities
    this._groundEntitiesLayer = new Sprite();
    this._groundEntitiesLayer.z = 1;
    this._tbsLayer.addChild(this._groundEntitiesLayer);
    //-Ground
    this._groundLayer = new Sprite();
    this._groundLayer.z = 2;
    this._tbsLayer.addChild(this._groundLayer);
    //-Battlers
    this._battlersLayer = new Sprite();
    this._battlersLayer.z = 3;
    this._tbsLayer.addChild(this._battlersLayer);
    //-Animations
    this._animationsLayer = new TBSMapAnimation();
    this._animationsLayer.z = 4;
    this._tbsLayer.addChild(this._animationsLayer);
    //-Movable Info
    this._movableInfoLayer = new Sprite();
    this._movableInfoLayer.z = 6;
    this._tbsLayer.addChild(this._movableInfoLayer);
    //-Fixed Info
    this._fixedInfoLayer = new Sprite();
    this._fixedInfoLayer.z = 6;
    this._baseSprite.addChild(this._fixedInfoLayer);
    //-Debug
    var bitmap = new Bitmap(Graphics.width, Graphics.height);
    this._debugLayer = new Sprite(bitmap);
    this._debugLayer.z = 7;
    this._tbsLayer.addChild(this._debugLayer);
};

Spriteset_BattleTBS.prototype.update = function () {
    Spriteset_Map.prototype.update.call(this);
    this.updateEntitiesZ();
};

Spriteset_BattleTBS.prototype.updateTilemap = function () {
    Spriteset_Map.prototype.updateTilemap.call(this);
    if (!this._tbsLayer) return;
    this._tbsLayer.x = -$gameMap.displayX() * $gameMap.tileWidth();
    this._tbsLayer.y = -$gameMap.displayY() * $gameMap.tileHeight();
};

Spriteset_BattleTBS.prototype.updateEntitiesZ = function () {
    if (this._battlersLayer)
        this._battlersLayer.children.sort(this.compareEntitiesOrder);
};

Spriteset_BattleTBS.prototype.compareEntitiesOrder = function (a, b) {
    if (a.y < b.y) return -1;
    if (a.y > b.y) return 1;
    return 0;
};


/*-------------------------------------------------------------------------
* TBSScopeLayer
-------------------------------------------------------------------------*/
function TBSScopeLayer() {
    this.initialize.apply(this, arguments);
}
TBSScopeLayer.prototype = Object.create(Sprite.prototype);
TBSScopeLayer.prototype.constructor = TBSScopeLayer;

TBSScopeLayer.prototype.initialize = function () {
    var w = $gameMap.width() * $gameMap.tileWidth();
    var h = $gameMap.height() * $gameMap.tileHeight();
    var bitmap = new Bitmap(w, h);
    Sprite.prototype.initialize.call(this, bitmap);
    this._selectionLayer = null;
    this._selectionCells = [];
};

TBSScopeLayer.prototype.createSelectionLayer = function () {
    this._selectionLayer = new TBSScopeLayer();
    this._selectionLayer.z = 2;
    this.parent.addChild(this._selectionLayer);
};

TBSScopeLayer.prototype.update = function () {
    Sprite.prototype.update.call(this);
    if (this._selectionLayer) {
        //this._selectionLayer.x = this.x;
        //this._selectionLayer.y = this.y;
    }
};

TBSScopeLayer.prototype.clear = function () {
    this.bitmap.clear();
};

TBSScopeLayer.prototype.clearSelection = function () {
    this._selectionLayer.clear();
    this._selectionLayer.leU_endLoopFlash();
};

TBSScopeLayer.prototype.drawCell = function (x, y, opacity, color) {
    var w = Lecode.S_TBS.scopeCellWidth;
    var h = Lecode.S_TBS.scopeCellHeight;
    var sx = $gameMap.tileWidth() - w;
    var sy = $gameMap.tileHeight() - h;
    w -= sx;
    h -= sy;
    sx += x * $gameMap.tileWidth();
    sy += y * $gameMap.tileHeight();
    this.bitmap.paintOpacity = opacity;
    this.bitmap.fillRect(sx, sy, w, h, color);
};

TBSScopeLayer.prototype.drawSelectionCells = function (scope, opacity, color, scolor) {
    var boundaries = BattleManagerTBS.getScopeBoundaries(scope);
    var w = (Math.abs(boundaries.right - boundaries.left) + 1) * $gameMap.tileWidth();
    var h = (Math.abs(boundaries.top - boundaries.bottom) + 1) * $gameMap.tileHeight();
    var x = boundaries.left * $gameMap.tileWidth();
    var y = boundaries.top * $gameMap.tileHeight();
    this._selectionLayer.bitmap = new Bitmap(w, h);
    this._selectionLayer.paintOpacity = opacity;
    this._selectionLayer.x = x;
    this._selectionLayer.y = y;
    scope.forEach(function (cell) {
        w = Lecode.S_TBS.scopeCellWidth;
        h = Lecode.S_TBS.scopeCellHeight;
        var sx = $gameMap.tileWidth() - w;
        var sy = $gameMap.tileHeight() - h;
        w -= sx;
        h -= sy;
        var cx = cell.x - boundaries.left;
        var cy = cell.y - boundaries.top;
        sx += cx * $gameMap.tileWidth();
        sy += cy * $gameMap.tileHeight();
        this._selectionLayer.bitmap.fillRect(sx, sy, w, h, scolor);
    }.bind(this));
    this._selectionLayer.leU_startLoopFlash([0, 0, 0, 255], 25);
    this._selectionLayer.leU_setFlashMode("opacity");
};

TBSScopeLayer.prototype.drawSelectionCell = function (x, y, opacity, color) {
    this._selectionLayer.drawCell(x, y, opacity, color);
    //this._selectionCells.push({ x: x, y: y, op: opacity, color: color });
};


/*-------------------------------------------------------------------------
* TBSMapAnimation
-------------------------------------------------------------------------*/
function TBSMapAnimation() {
    this.initialize.apply(this, arguments);
}

TBSMapAnimation.prototype = Object.create(Sprite_Base.prototype);
TBSMapAnimation.prototype.constructor = TBSMapAnimation;

TBSMapAnimation.prototype.initialize = function (battler) {
    Sprite_Base.prototype.initialize.call(this);
    this._cell = null;
    this._target = null;
};

TBSMapAnimation.prototype.update = function () {
    Sprite_Base.prototype.update.call(this);
};

TBSMapAnimation.prototype.newAnimation = function (id, mirror, delay, cell, target) {
    this._cell = cell;
    this._target = target;
    this.startAnimation($dataAnimations[id], mirror, delay);
};

TBSMapAnimation.prototype.startAnimation = function (animation, mirror, delay) {
    var sprite = new Sprite_TBSAnimation();
    sprite.setup(this._target || this._effectTarget, animation, mirror, delay, this._cell);
    this.addChild(sprite);
    this._animationSprites.push(sprite);
};


/*-------------------------------------------------------------------------
* Sprite_TBSAnimation
-------------------------------------------------------------------------*/
function Sprite_TBSAnimation() {
    this.initialize.apply(this, arguments);
}

Sprite_TBSAnimation.prototype = Object.create(Sprite_Animation.prototype);
Sprite_TBSAnimation.prototype.constructor = Sprite_TBSAnimation;

Sprite_TBSAnimation.prototype.initialize = function () {
    Sprite_Animation.prototype.initialize.call(this);
    this._cell = null;
};

Sprite_TBSAnimation.prototype.update = function () {
    Sprite_Animation.prototype.update.call(this);
};

Sprite_TBSAnimation.prototype.setup = function (target, animation, mirror, delay, cell) {
    this._cell = cell;
    this._target = target;
    this._animation = animation;
    this._mirror = mirror;
    this._delay = delay;
    if (this._animation) {
        this.remove();
        this.setupRate();
        this.setupDuration();
        this.loadBitmaps();
        this.createSprites();
    }
};

Sprite_TBSAnimation.prototype.updatePosition = function () {
    if (this._animation.position === 3) {
        this.x = this.parent.width / 2;
        this.y = this.parent.height / 2;
    } else {
        var w = $gameMap.tileWidth();
        var h = $gameMap.tileHeight();
        this.x = this._cell.x * $gameMap.tileWidth() + w / 2;
        this.y = this._cell.y * $gameMap.tileHeight() + h / 2;
        if (this._animation.position === 2)
            this.y += h / 2;
        else if (this._animation.position === 0)
            this.y -= h / 2;
    }
};


/*-------------------------------------------------------------------------
* Sprite_TBSEntityAnimation
-------------------------------------------------------------------------*/
function Sprite_TBSEntityAnimation() {
    this.initialize.apply(this, arguments);
}

Sprite_TBSEntityAnimation.prototype = Object.create(Sprite_TBSAnimation.prototype);
Sprite_TBSEntityAnimation.prototype.constructor = Sprite_TBSEntityAnimation;

Sprite_TBSEntityAnimation.prototype.initialize = function () {
    Sprite_TBSAnimation.prototype.initialize.call(this);
};

Sprite_TBSEntityAnimation.prototype.setup = function (target, animation, mirror, delay, cell) {
    Sprite_TBSAnimation.prototype.setup.call(this, target, animation, mirror, delay, cell);
    this.updatePosition();
};

Sprite_TBSEntityAnimation.prototype.updatePosition = function () {
    if (this._animation.position === 3) {
        this.x = this.parent.width / 2;
        this.y = this.parent.height / 2;
    } else {
        var bounds = this._target.getBounds();
        var w = bounds.width;
        var h = bounds.height;
        this.x = this._target.x + w / 2;
        this.y = this._target.y + h / 2;
        if (this._animation.position === 2)
            this.y += h / 2;
        else if (this._animation.position === 0)
            this.y -= h / 2;
    }
};


/*-------------------------------------------------------------------------
* Scene_Battle
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldSB_create = Scene_Battle.prototype.create;
Scene_Battle.prototype.create = function () {
    if (Lecode.S_TBS.commandOn) {
        Scene_Base.prototype.create.call(this);
        this.createDisplayObjects();
    } else {
        Lecode.S_TBS.oldSB_create.call(this);
    }
};

Lecode.S_TBS.oldSB_createDisplayObjects = Scene_Battle.prototype.createDisplayObjects;
Scene_Battle.prototype.createDisplayObjects = function () {
    if (Lecode.S_TBS.commandOn) {
        this.createSpriteset();
        this.createWindowLayer();
        this.createAllWindows();
    } else {
        Lecode.S_TBS.oldSB_createDisplayObjects.call(this);
    }
};

Lecode.S_TBS.oldSB_start = Scene_Battle.prototype.start;
Scene_Battle.prototype.start = function () {
    if (Lecode.S_TBS.commandOn) {
        Scene_Base.prototype.start.call(this);
        this.startFadeIn(this.fadeSpeed(), false);

        BattleManager.playBattleBgm();
        BattleManagerTBS._spriteset = this._spriteset;
        BattleManagerTBS._logWindow = this._logWindow;
        this._logWindow.setSpriteset(this._spriteset);
        InputHandlerTBS.setup();
        this.setMovableWindows();

        InputHandlerTBS.addWindowBlockingTouch(this._windowConfirm)
            .addWindowBlockingTouch(this._windowCommand)
            .addWindowBlockingTouch(this._windowSkill)
            .addWindowBlockingTouch(this._windowItem)
            .addWindowBlockingTouch(this._windowStatus)
            .addWindowBlockingTouch(this._helpWindow)
            .addWindowBlockingTouch(this._windowEndCommand)
            .addWindowBlockingTouch(this._windowPositioning)
            .addWindowBlockingTouch(this._windowPositioningConfirm);

        LeUtilities.getScene().showPositioningWindow();

        BattleManagerTBS.startBattle();
    } else {
        Lecode.S_TBS.oldSB_start.call(this);
    }
};

Lecode.S_TBS.oldSB_update = Scene_Battle.prototype.update;
Scene_Battle.prototype.update = function () {
    if (Lecode.S_TBS.commandOn) {
        $gameMap.update(true);
        $gameTimer.update(true);
        $gameScreen.update();
        InputHandlerTBS.update();
        BattleManagerTBS.update();
        Scene_Base.prototype.update.call(this);
    } else {
        Lecode.S_TBS.oldSB_update.call(this);
    }
};

Lecode.S_TBS.oldSB_createSpriteset = Scene_Battle.prototype.createSpriteset;
Scene_Battle.prototype.createSpriteset = function () {
    if (Lecode.S_TBS.commandOn) {
        this._spriteset = new Spriteset_BattleTBS();
        this.addChild(this._spriteset);
    } else {
        Lecode.S_TBS.oldSB_createSpriteset.call(this);
    }
};

Lecode.S_TBS.oldSB_createAllWindows = Scene_Battle.prototype.createAllWindows;
Scene_Battle.prototype.createAllWindows = function () {
    if (Lecode.S_TBS.commandOn) {
        this.createLogWindow();
        this.createPositioningWindow();
        this.createPositioningConfirmWindow();
        this.createPositioningInfoWindow();
        this.createConfirmationWindow();
        this.createStatusWindow();
        this.createCommandWindow();
        this.createHelpWindow();
        this.createSkillWindow();
        this.createItemWindow();
        this.createEndCommandWindow();
        this.createMessageWindow();
    } else {
        Lecode.S_TBS.oldSB_createAllWindows.call(this);
    }
};

Scene_Battle.prototype.setMovableWindows = function () {
    BattleManagerTBS.getLayer("movableInfo").addChild(this._windowCommand);
    BattleManagerTBS.getLayer("movableInfo").addChild(this._windowSkill);
    BattleManagerTBS.getLayer("movableInfo").addChild(this._windowItem);
};

Scene_Battle.prototype.createPositioningWindow = function () {
    this._windowPositioning = new Window_TBSPositioning();
    this._windowPositioning.setHandler('ok', this.onPositioningOk.bind(this));
    this._windowPositioning.setHandler('cancel', this.onPositioningCancel.bind(this));
    this._windowPositioning.setHandler('exit_up', this.onPositioningExitUp.bind(this));
    this._windowPositioning.hide();
    this._windowPositioning.close();
    this._windowPositioning.deactivate();
    this._windowPositioning.x = 0;
    this._windowPositioning.y = Graphics.height / 2 - this._windowPositioning.height / 2;
    this.addWindow(this._windowPositioning);
};

Scene_Battle.prototype.createPositioningConfirmWindow = function () {
    this._windowPositioningConfirm = new Window_TBSPositioningConfirm(this._windowPositioning.width);
    this._windowPositioningConfirm.setHandler('ok', this.onPositioningConfirmOk.bind(this));
    this._windowPositioningConfirm.setHandler('cancel', this.onPositioningConfirmCancel.bind(this));
    this._windowPositioningConfirm.setHandler('cursor_down', this.onPositioningConfirmCursorDown.bind(this));
    this._windowPositioningConfirm.hide();
    this._windowPositioningConfirm.close();
    this._windowPositioningConfirm.deactivate();
    this._windowPositioningConfirm.x = this._windowPositioning.x;
    this._windowPositioningConfirm.y = this._windowPositioning.y - this._windowPositioningConfirm.height;
    this.addWindow(this._windowPositioningConfirm);
};

Scene_Battle.prototype.createPositioningInfoWindow = function () {
    this._windowPositioningInfo = new Window_TBSPositioningInfo();
    this._windowPositioningInfo.hide();
    this._windowPositioningInfo.deactivate();
    this.addWindow(this._windowPositioningInfo);
};

Scene_Battle.prototype.createConfirmationWindow = function () {
    this._windowConfirm = new Window_TBSConfirm();
    this._windowConfirm.setHandler('ok', this.onConfirmationOK.bind(this));
    this._windowConfirm.setHandler('cancel', this.onConfirmationCancel.bind(this));
    this._windowConfirm.hide();
    this._windowConfirm.deactivate();
    this.addWindow(this._windowConfirm);
};

Lecode.S_TBS.oldSB_createStatusWindow = Scene_Battle.prototype.createStatusWindow;
Scene_Battle.prototype.createStatusWindow = function () {
    if (Lecode.S_TBS.commandOn) {
        this._windowStatus = new Window_TBSStatus();
        this._windowStatus.hide();
        this.addWindow(this._windowStatus);
    } else {
        Lecode.S_TBS.oldSB_createStatusWindow.call(this);
    }
};

Lecode.S_TBS.oldSB_createCommandWindow = Scene_Battle.prototype.createCommandWindow;
Scene_Battle.prototype.createCommandWindow = function () {
    if (Lecode.S_TBS.commandOn) {
        this._windowCommand = new Window_TBSCommand();
        this._windowCommand.setHandler('move', this.onCommandInput.bind(this, "move"));
        this._windowCommand.setHandler('attack', this.onCommandInput.bind(this, "attack"));
        this._windowCommand.setHandler('skill', this.onCommandInput.bind(this, "skill"));
        this._windowCommand.setHandler('item', this.onCommandInput.bind(this, "item"));
        this._windowCommand.setHandler('pass', this.onCommandInput.bind(this, "pass"));
        this._windowCommand.setHandler('cancel', this.onCommandInput.bind(this, "cancel"));
        this._windowCommand.hide();
        this._windowCommand.deactivate();
    } else {
        Lecode.S_TBS.oldSB_createCommandWindow.call(this);
    }
};

Lecode.S_TBS.oldSB_createSkillWindow = Scene_Battle.prototype.createSkillWindow;
Scene_Battle.prototype.createSkillWindow = function () {
    if (Lecode.S_TBS.commandOn) {
        this._windowSkill = new Window_TBSSkillList();
        this._windowSkill.setHandler('ok', this.onSkillInput.bind(this, "ok"));
        this._windowSkill.setHandler('cancel', this.onSkillInput.bind(this, "cancel"));
        this._windowSkill._helpWindow = this._helpWindow;
        this._windowSkill.hide();
        this._windowSkill.deactivate();
    } else {
        Lecode.S_TBS.oldSB_createSkillWindow.call(this);
    }
};

Lecode.S_TBS.oldSB_createItemWindow = Scene_Battle.prototype.createItemWindow;
Scene_Battle.prototype.createItemWindow = function () {
    if (Lecode.S_TBS.commandOn) {
        this._windowItem = new Window_TBSItemList();
        this._windowItem.setHandler('ok', this.onItemInput.bind(this, "ok"));
        this._windowItem.setHandler('cancel', this.onItemInput.bind(this, "cancel"));
        this._windowItem._helpWindow = this._helpWindow;
        this._windowItem.hide();
        this._windowItem.deactivate();
    } else {
        Lecode.S_TBS.oldSB_createItemWindow.call(this);
    }
};

Scene_Battle.prototype.createEndCommandWindow = function () {
    this._windowEndCommand = new Window_TBSEndCommand();
    this._windowEndCommand.setHandler('options', this.onEndCommandInput.bind(this, "options"));
    this._windowEndCommand.setHandler('escape', this.onEndCommandInput.bind(this, "escape"));
    this._windowEndCommand.setHandler('cancel', this.onEndCommandInput.bind(this, "cancel"));
    this._windowEndCommand.hide();
    this._windowEndCommand.deactivate();
    this.addWindow(this._windowEndCommand);
};

Scene_Battle.prototype.activatePositioningWindow = function () {
    this._windowPositioning.open();
    this._windowPositioningConfirm.open();
    this._windowPositioning.selectLast();
    this._windowPositioning.activate();
    for (var i = 0; i < $gameParty.battleMembers().length; i++) {
        this._windowPositioning.select(i);
        if (!this._windowPositioning._disabled[i])
            break;
    }
};

Scene_Battle.prototype.onPositioningOk = function () {
    var actor = this._windowPositioning.actor();
    this._windowPositioning.disableSelection();
    this._windowPositioning.refresh();
    this._windowPositioning.close();
    this._windowPositioningConfirm.close();
    BattleManagerTBS.processActorPositioning(actor);
};

Scene_Base.prototype.onPositioningCancel = function () {
    var actor = this._windowPositioning.actor();
    var currentEntity = BattleManagerTBS.getEntityWithActorId(actor.actorId());
    if (currentEntity) {
        BattleManagerTBS.processActorPositioning(actor);
        BattleManagerTBS.positioningPhaseCancel();
    }
    this._windowPositioning.activate();
};

Scene_Battle.prototype.onActorPrePositioning = function (actor) {
    this._windowPositioning.setFixedActor(actor);
    this._windowPositioning.refresh();
};

Scene_Battle.prototype.onPositioningExitUp = function () {
    this._windowPositioning.deactivate();
    this._windowPositioning.deselect();
    this._windowPositioningConfirm.activate();
};

Scene_Battle.prototype.onPositioningConfirmOk = function () {
    BattleManagerTBS.positioningPhaseEnd();
};

Scene_Battle.prototype.onPositioningConfirmCancel = function () {
    this.onPositioningConfirmCursorDown();
};

Scene_Battle.prototype.onPositioningConfirmCursorDown = function () {
    this._windowPositioning.activate();
    this._windowPositioning.selectLast();
    this._windowPositioningConfirm.deactivate();
    this._windowPositioningConfirm.deselect();
};

Scene_Battle.prototype.onTBSBattleBeginning = function () {
    this.hideConfirmationWindow();
    this._windowPositioning.deactivate();
    this._windowPositioning.close();
    this._windowPositioningConfirm.deactivate();
    this._windowPositioningConfirm.close();
};

Scene_Battle.prototype.showPositioningWindow = function (cell, battler) {
    this._windowPositioning.open();
    this._windowPositioning.show();
    this._windowPositioningConfirm.open();
    this._windowPositioningConfirm.show();
    this._windowPositioning.refresh();
    this._windowPositioningConfirm.refresh();
    this._windowPositioning.activate();
};

Scene_Battle.prototype.showStatusWindow = function (entity, slide) {
    if (entity.battler().rpgObject().leTbs_hideStatusWindow) return;
    var window = this._windowStatus;
    this._windowStatus._entity = entity;
    this._windowStatus.show();
    this._windowStatus.open();
    this._windowStatus.refresh();
    if (slide)
        this._windowStatus.slide();
};

Scene_Battle.prototype.showCommandWindow = function () {
    var entity = BattleManagerTBS.activeEntity();
    var cell = entity.getCell();
    var battler = BattleManagerTBS.activeBattler();
    this._windowCommand.setup(battler, entity);
};

Scene_Battle.prototype.showSkillWindow = function () {
    var entity = BattleManagerTBS.activeEntity();
    var cell = entity.getCell();
    var battler = BattleManagerTBS.activeBattler();
    this._windowSkill._entity = entity;
    this._windowSkill.setActor(battler);
    this._windowSkill.show();
    this._windowSkill.open();
    this._windowSkill.refresh();
    this._windowSkill.activate();
    this.showHelpWindow();
};

Scene_Battle.prototype.showItemWindow = function () {
    var entity = BattleManagerTBS.activeEntity();
    var cell = entity.getCell();
    var battler = BattleManagerTBS.activeBattler();
    this._windowItem._entity = entity;
    this._windowItem.show();
    this._windowItem.open();
    this._windowItem.refresh();
    this._windowItem.activate();
    this.showHelpWindow();
};

Scene_Battle.prototype.showHelpWindow = function () {
    var status = this._windowStatus;
    var help = this._helpWindow;
    help.x = 0;
    help.y = Graphics.height - help.height;
    while ((status.y + status.height) > help.y)
        status.y--;
    status.y++;
    help.visible = true;
};

Scene_Battle.prototype.showEndCommandWindow = function () {
    this._windowEndCommand.show();
    this._windowEndCommand.open();
    this._windowEndCommand.activate();
};

Scene_Battle.prototype.hidePositioningWindow = function (cell, battler) {
    this._windowPositioningInfo.close();
};

Scene_Battle.prototype.hideHelpWindow = function () {
    var status = this._windowStatus;
    var help = this._helpWindow;
    if ((status.y + status.height) == (help.y + 1))
        status.y += help.height;
    help.y += help.height;
    help.visible = false;
};

Scene_Battle.prototype.showConfirmationWindow = function () {
    this._windowConfirm.show();
    this._windowConfirm.open();
    this._windowConfirm.activate();
};

Scene_Battle.prototype.hideConfirmationWindow = function () {
    this._windowConfirm.close();
    this._windowConfirm.deactivate();
};

Scene_Battle.prototype.onConfirmationOK = function () {
    if (this._windowConfirm.openness == 255);
    BattleManagerTBS.onConfirmationWindowOK();
};

Scene_Battle.prototype.onConfirmationCancel = function () {
    if (this._windowConfirm.openness == 255);
    BattleManagerTBS.onConfirmationWindowCancel();
};

Scene_Battle.prototype.onCommandInput = function (command) {
    this._windowCommand.close();
    this._windowCommand.deactivate();
    BattleManagerTBS.onCommandInput(command);
};

Scene_Battle.prototype.onSkillInput = function (command) {
    this._windowSkill.close();
    this._windowSkill.deactivate();
    this.hideHelpWindow();
    BattleManagerTBS.onSkillInput(command);
};

Scene_Battle.prototype.onItemInput = function (command) {
    this._windowItem.close();
    this._windowItem.deactivate();
    this.hideHelpWindow();
    BattleManagerTBS.onItemInput(command);
};

Scene_Battle.prototype.onEndCommandInput = function (command) {
    this._windowEndCommand.close();
    this._windowEndCommand.deactivate();
    BattleManagerTBS.onEndCommandInput(command);
};

Scene_Battle.prototype.getWindowsWChangeableOpa = function () {
    return [this._windowConfirm, this._windowPositioningInfo, this._windowCommand, this._windowStatus,
    this._windowSkill, this._helpWindow
    ];
};

Scene_Battle.prototype.stop = function () {
    Scene_Base.prototype.stop.call(this);
    if (this.needsSlowFadeOut()) {
        this.startFadeOut(this.slowFadeSpeed(), false);
    } else {
        this.startFadeOut(this.fadeSpeed(), false);
    }
    if (Lecode.S_TBS.commandOn) {
        this.getWindowsWChangeableOpa().forEach(function (window) {
            window.close();
        }.bind(this));
    } else {
        this._statusWindow.close();
        this._partyCommandWindow.close();
        this._actorCommandWindow.close();
    }
};


/*-------------------------------------------------------------------------
* InputHandlerTBS
-------------------------------------------------------------------------*/
function InputHandlerTBS() {
    throw new Error('This is a static class');
}

InputHandlerTBS.setup = function () {
    this._active = true;
    this._lastSelectedCell = null;
    this._windowsBlocking = [];
    this._oldMousePos = {};
};

InputHandlerTBS.isActive = function () {
    return this._active;
};

InputHandlerTBS.lastSelectedCell = function () {
    return this._lastSelectedCell || BattleManagerTBS._activeCell;
};

InputHandlerTBS.setActive = function (active) {
    this._active = active;
};

InputHandlerTBS.addWindowBlockingTouch = function (window) {
    this._windowsBlocking.push(window);
    return this;
};

InputHandlerTBS.setOnTouchCallback = function (callback) {
    this._onTouchCallback = callback;
    return this;
};

InputHandlerTBS.setOnTouchCancelCallback = function (callback) {
    this._onTouchCancelCallback = callback;
    return this;
};

InputHandlerTBS.setOnUpCallback = function (callback) {
    this._onUpCallback = callback;
    return this;
};

InputHandlerTBS.setOnRightCallback = function (callback) {
    this._onRightCallback = callback;
    return this;
};

InputHandlerTBS.setOnDownCallback = function (callback) {
    this._onDownCallback = callback;
    return this;
};

InputHandlerTBS.setOnLeftCallback = function (callback) {
    this._onLeftCallback = callback;
    return this;
};

InputHandlerTBS.setOnOkCallback = function (callback) {
    this._onOkCallback = callback;
    return this;
};

InputHandlerTBS.setOnCancelCallback = function (callback) {
    this._onCancelCallback = callback;
    return this;
};

InputHandlerTBS.setOnMoveCallback = function (callback) {
    this._onMoveCallback = callback;
    return this;
};

InputHandlerTBS.update = function () {
    if (!this.isActive()) return;
    if (BattleManagerTBS.isWaiting()) return;

    if (Input.isPressed(Lecode.S_TBS.explorationInput) && !BattleManagerTBS.isExploring()) {
        BattleManagerTBS.startMapExploration();
        return;
    }
    if (!Input.isPressed(Lecode.S_TBS.explorationInput) && BattleManagerTBS.isExploring()) {
        BattleManagerTBS.endMapExploration();
        return;
    }
    if (BattleManagerTBS.isExploring()) {
        this.updateExplorationInput();
        return;
    }

    if (Input.isPressed(Lecode.S_TBS.opacityInput))
        BattleManagerTBS.setInputOpacity();
    else
        BattleManagerTBS._opacityInputed = false;

    if (TouchInput.isTriggered()) {
        var x = $gameMap.canvasToMapX(TouchInput.x);
        var y = $gameMap.canvasToMapY(TouchInput.y);
        var cell = BattleManagerTBS.getCellAt(x, y);
        this.processCallback("Touch", cell);
        this._lastSelectedCell = cell;
        if (!this.isTouchBlocked()) {
            $gameTemp.setDestination(x, y);
            BattleManagerTBS.resetDestinationCount();
        }
        return;
    }

    if (TouchInput.isCancelled()) {
        this.processCallback("TouchCancel");
        return;
    }

    if (Input.isTriggered("right"))
        this.processCallback("Right");
    if (Input.isTriggered("down"))
        this.processCallback("Down");
    if (Input.isTriggered("left"))
        this.processCallback("Left");
    if (Input.isTriggered("up"))
        this.processCallback("Up");
    if (Input.isTriggered("ok"))
        this.processCallback("Ok");
    if (Input.isTriggered("cancel"))
        this.processCallback("Cancel");

    if (TouchInput._leTBSMoveData.x != this._oldMousePos.x ||
        TouchInput._leTBSMoveData.y != this._oldMousePos.y) {
        this.processCallback("Move");
        this._oldMousePos.x = TouchInput._leTBSMoveData.x;
        this._oldMousePos.y = TouchInput._leTBSMoveData.y;
    }
};

InputHandlerTBS.processCallback = function (key, arg) {
    var func = eval("this._on" + key + "Callback");
    if (func)
        func(arg);
};

InputHandlerTBS.updateExplorationInput = function () {
    if (Input.isPressed("right"))
        BattleManagerTBS.scrollRight(1);
    if (Input.isPressed("down"))
        BattleManagerTBS.scrollDown(1);
    if (Input.isPressed("up"))
        BattleManagerTBS.scrollUp(1);
    if (Input.isPressed("left"))
        BattleManagerTBS.scrollLeft(1);
};

InputHandlerTBS.isTouchBlocked = function () {
    var x = TouchInput.x;
    var y = TouchInput.y;
    for (var i = 0; i < this._windowsBlocking.length; i++) {
        var w = this._windowsBlocking[i];
        if (!w.visible || w.opacity === 0 || w.openness === 0) continue;
        if (x >= w.x && x <= (w.x + w.width)) {
            if (y >= w.y && y <= (w.y + w.height))
                return true;
        }
    }
    return false;
};


/*-------------------------------------------------------------------------
* BattleManager
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldBM_setup = BattleManager.setup;
BattleManager.setup = function (troopId, canEscape, canLose) {
    Lecode.S_TBS.oldBM_setup.call(this, troopId, canEscape, canLose);
    BattleManagerTBS.setup();
};

Lecode.S_TBS.oldBM_isTurnEnd = BattleManager.isTurnEnd;
BattleManager.isTurnEnd = function () {
    return Lecode.S_TBS.oldBM_isTurnEnd.call(this) || BattleManagerTBS._subPhase == "turn_end";
};

Lecode.S_TBS.oldBM_canEscape = BattleManager.canEscape;
BattleManager.canEscape = function () {
    var entity = BattleManagerTBS.activeEntity();
    if (entity) {
        var bool = entity._movePerformed || entity._actionPerformed;
        return Lecode.S_TBS.oldBM_canEscape.call(this) && !bool;
    } else {
        return Lecode.S_TBS.oldBM_canEscape.call(this);
    }
};

Lecode.S_TBS.oldBattleManager_displayStartMessages = BattleManager.displayStartMessages;
BattleManager.displayStartMessages = function () {
    if (Lecode.S_TBS.displayStartMessages)
        Lecode.S_TBS.oldBattleManager_displayStartMessages.call(this);
};


/*-------------------------------------------------------------------------
* BattleManagerTBS
-------------------------------------------------------------------------*/
function BattleManagerTBS() {
    throw new Error('This is a static class');
}

BattleManagerTBS.setup = function () {
    this.initMembers();
};

BattleManagerTBS.initMembers = function () {
    this._phase = "init";
    this._subPhase = "";
    this._startCells = [];
    this._positioningEntityToSwap = null;
    this._currentPositioningEntity = null;
    this._groundCells = {};
    this._cursor = null;
    this._activeCell = null;
    this._spriteset = null;
    this._battlerEntities = [];
    this._neutralEntities = [];
    this._tbsEvents = [];
    this._lastTriggeredEventEntity = null;
    this._lastTriggeredEventBattler = null;
    this._startupFlags = {};
    this._explorationIniCell = null;
    this._exploring = false;
    this._inputOpacity = 0;
    this._opacityInputed = false;
    this._waitTime = 0;
    this._turnOrder = [];
    this._activeIndex = 0;
    this._activeAction = null;
    this._dummyChara = new Game_Character();
    this._moveScope = null;
    this._movePath = null;
    this._actionScope = null;
    this._destinationCount = 0;
};

BattleManagerTBS.cursor = function () {
    return this._cursor;
};

BattleManagerTBS.allEntities = function () {
    return this._battlerEntities.concat(this._neutralEntities);
};

BattleManagerTBS.allPlayableEntities = function () {
    return this._battlerEntities;
};

BattleManagerTBS.dummyCharacter = function () {
    return this._dummyChara;
};

BattleManagerTBS.moveScope = function () {
    return this._moveScope;
};

BattleManagerTBS.movePath = function () {
    return this._movePath;
};

BattleManagerTBS.actionScope = function () {
    return this._actionScope;
};

BattleManagerTBS.isExploring = function () {
    return this._exploring;
};

BattleManagerTBS.activeAction = function () {
    return this._activeAction;
};

BattleManagerTBS.getLayer = function (id) {
    var layer = eval("this._spriteset._" + id + "Layer");
    return layer;
};

BattleManagerTBS.wait = function (time) {
    this._waitTime += time;
};

BattleManagerTBS.isWaiting = function () {
    return this._waitTime > 0;
};

BattleManagerTBS.startBattle = function () {
    this.prepare();
    this.processPositioningPhase();
};

BattleManagerTBS.prepare = function () {
    this.createStartCells();
    this.createGroundCells();
    this.createTBSObjects();
    this.createTBSEvents();
    this.createNeutralEntities();
    this.prepareEntityFlags();
};

BattleManagerTBS.createTBSObjects = function () {
    this.createDirectionSelector();
    this.createCursor();
    this.createBattleStartSprite();
    this.createTurnOrderVisual();
    this.createProjectilesManager();
    this.createAiManager();
    this._easystar = new EasyStar.js();
};

BattleManagerTBS.createDirectionSelector = function () {
    var layer = this.getLayer("movableInfo");
    this._directionSelector = new TBSDirectionSelector(layer);
};

BattleManagerTBS.createCursor = function () {
    var bitmap = ImageManager.loadLeTBS("MapCursor");
    this._cursor = new SpriteCursorTBS(bitmap);
    this.getLayer("ground").addChild(this.cursor());
};

BattleManagerTBS.createBattleStartSprite = function () {
    var bitmap = ImageManager.loadLeTBS("Battle_Start");
    this._startSprite = new Sprite(bitmap);
    this._startSprite.visible = false;
    this.getLayer("fixedInfo").addChild(this._startSprite);
};

BattleManagerTBS.createProjectilesManager = function () {
    var layer = this.getLayer("animations");
    this._projectilesManager = new TBSProjectilesManager(layer);
};

BattleManagerTBS.createAiManager = function () {
    this._aiManager = new TBSAiManager();
};
BattleManagerTBS.createTurnOrderVisual = function () {
    var layer = this.getLayer("fixedInfo");
    this._turnOrderVisual = new TBSTurnOrderVisual(layer);
};

BattleManagerTBS.createStartCells = function () {
    this.getLayer("scopes").clear();
    this._startCells = [];
    $gameMap.events().forEach(function (eventObj) {
        var x = eventObj.event().x;
        var y = eventObj.event().y;
        var note = eventObj.event().note;
        var data = {};
        if (note.match(/<Enemy Cell>/i)) {
            data.type = "enemy";
        } else if (note.match(/<Enemy Cell\s?:\s?(.+)>/i)) {
            data.type = "enemy";
            data.fixed = Number(RegExp.$1);
        } else if (note.match(/<Actor Cell>/i)) {
            data.type = "actor";
        } else if (note.match(/<Actor Cell\s?:\s?(.+)>/i)) {
            data.type = "actor";
            data.fixed = Number(RegExp.$1);
        }
        if (data.type) {
            var cell = new TBSCell(x, y);
            cell._event = eventObj.event();
            cell._positioningData = data;
            this.createPositioningCell(data.type, x, y, cell);
            this._startCells.push(cell);
        }
    }.bind(this));
};

BattleManagerTBS.createGroundCells = function () {
    for (var i = 0; i < $gameMap.width(); i++) {
        this._groundCells[i] = {};
        for (var j = 0; j < $gameMap.height(); j++) {
            var cell = new TBSCell(i, j);
            cell._regionId = $gameMap.regionId(i, j);
            this._groundCells[i][j] = cell;
        }
    }
};

BattleManagerTBS.createTBSEvents = function () {
    $gameMap.events().forEach(function (event) {
        if (event.event().note.match(/<TBS Event>/i)) {
            this._tbsEvents.push(new TBSEvent(event));
        }
    }.bind(this));
};

BattleManagerTBS.getTBSEventAt = function (x, y) {
    for (var i = 0; i < this._tbsEvents.length; i++) {
        var event = this._tbsEvents[i];
        if (event.x() === x && event.y() === y)
            return event;
    }
    return null;
};

BattleManagerTBS.onEventPageSetup = function (event) {
    for (var i = 0; i < this._tbsEvents.length; i++) {
        var tbsEvent = this._tbsEvents[i];
        if (tbsEvent._event === event)
            tbsEvent.onEventPageSetup();
    }
};

BattleManagerTBS.onEventForceMoveRoute = function (event) {
    for (var i = 0; i < this._tbsEvents.length; i++) {
        var tbsEvent = this._tbsEvents[i];
        if (tbsEvent._event === event)
            tbsEvent.onEventForceMoveRoute();
    }
};

BattleManagerTBS.createNeutralEntities = function () {
    var layer = this.getLayer("battlers");
    $gameMap.events().forEach(function (event) {
        if (event.event().note.match(/<TBS Neutral (.+)>/i)) {
            var enemyId = Number(RegExp.$1);
            var tbsEvent = new TBSEvent(event);
            this._tbsEvents.push(tbsEvent);
            var entity = new TBSNeutralEntity(layer, tbsEvent, enemyId);
            entity.setCell(this.getCellAt(event.x, event.y));
            this._neutralEntities.push(entity);
        }
    }.bind(this));
};

BattleManagerTBS.prepareEntityFlags = function () {
    $gameMap.events().forEach(function (event) {
        for (var i = 0; i < event.list().length; i++) {
            var command = event.list()[i];
            if (command && command.code == 108) {
                var comments = command.parameters;
                for (var j = 0; j < comments.length; j++) {
                    var comment = comments[j];
                    if (comment.match(/<LeTBS>\s?Flag\s?:\s?(.+)/i)) {
                        this._startupFlags[event.x] = {};
                        this._startupFlags[event.x][event.y] = RegExp.$1;
                    }
                }
            }
        }
    }.bind(this));
};

BattleManagerTBS.update = function () {
    this.updateWait();
    this.waitForMessages();
    this.waitForEvents();
    this.updateWindowsInputOpacity();
    this.updateTBSObjects();
    this.updatePhase();
    this.updateBattlers();
    this.updateTBSEvents();
    this.updateDestination();
};

BattleManagerTBS.updateDestination = function () {
    this._destinationCount++;
    if (this._destinationCount >= Lecode.S_TBS.destinationDuration) {
        this._destinationCount = 0;
        $gameTemp.clearDestination();
    }
};

BattleManagerTBS.resetDestinationCount = function () {
    this._destinationCount = 0;
};

BattleManagerTBS.waitForMessages = function () {
    if ($gameMessage.isBusy()) {
        this.wait(1);
        var window = LeUtilities.getScene()._windowCommand;
        if (window.active) {
            window.close();
            window.deactivate();
            this._windowToResume = window;
        }
    } else {
        if (this._windowToResume) {
            this._windowToResume.open();
            this._windowToResume.activate();
            this._windowToResume = null;
        }
    }
};

BattleManagerTBS.waitForEvents = function () {
    if ($gameMap.isEventRunning()) {
        var window = LeUtilities.getScene()._windowCommand;
        if (window.active) {
            window.close();
            window.deactivate();
            this._windowToResume = window;
        }
    } else {
        if (this._windowToResume) {
            this._windowToResume.open();
            this._windowToResume.activate();
            this._windowToResume = null;
        }
    }
};

BattleManagerTBS.updateWait = function () {
    if (this.isWaiting())
        this._waitTime--;
};

BattleManagerTBS.updateWindowsInputOpacity = function () {
    if (this._inputOpacity === 0)
        return;

    var windows = LeUtilities.getScene().getWindowsWChangeableOpa();
    windows.forEach(function (window) {
        window.opacity = 255 - this._inputOpacity;
        window.backOpacity = 255 - this._inputOpacity;
        window.contentsOpacity = 255 - this._inputOpacity;
    }.bind(this));

    if (!this._opacityInputed) {
        var steps = Lecode.S_TBS.inputOpacityDecreaseSteps;
        var max = 255 - Lecode.S_TBS.minInputOpacity;
        this._inputOpacity -= steps;
        this._inputOpacity = this._inputOpacity.clamp(0, max);
    }
};

BattleManagerTBS.updateTBSObjects = function () {
    this.updateCursor();
    this._turnOrderVisual.update();
    this._projectilesManager.update();
};

BattleManagerTBS.updateCursor = function () {
    if (!this._activeCell || !this.cursor()) return;
    var x = this._activeCell.x;
    var y = this._activeCell.y;
    this.cursor().cellX = x;
    this.cursor().cellY = y;
    x *= $gameMap.tileWidth();
    y *= $gameMap.tileHeight();
    this.cursor().x = x;
    this.cursor().y = y;
    this.cursor().update();
};

BattleManagerTBS.startMapExploration = function () {
    this._exploring = true;
    this._explorationIniCell = this._activeCell;
};

BattleManagerTBS.endMapExploration = function () {
    this._exploring = false;
    this.centerCell(this._explorationIniCell);
};

BattleManagerTBS.setInputOpacity = function () {
    this._opacityInputed = true;
    var steps = Lecode.S_TBS.inputOpacityDecreaseSteps;
    var max = 255 - Lecode.S_TBS.minInputOpacity;
    this._inputOpacity += steps;
    this._inputOpacity = this._inputOpacity.clamp(0, max);
};

BattleManagerTBS.updatePhase = function () {
    if ($gameMessage.isBusy()) return;
    switch (this._phase) {
        case "positioning":
            this.updatePositioningPhase();
            break;
        case "battle_beginning":
            this.updateBeginningPhase();
            break;
        case "battle_processing":
            this.updateBattleProcessing();
            break;
        case "battle_stopping":
            this.updateBattleStopping();
            break;
        case "battle_end":
            this.updateBattleEnd();
            break;
    }
};

BattleManagerTBS.updateBattlers = function () {
    this.allEntities().forEach(function (entity) {
        entity.update();
    }.bind(this));
};

BattleManagerTBS.updateTBSEvents = function () {
    for (var i = 0; i < this._tbsEvents.length; i++) {
        this._tbsEvents[i].update();
    }
};

BattleManagerTBS.createPositioningCell = function (type, x, y, cell) {
    var opacity = Lecode.S_TBS.positioningCellOpacity;
    var color = (type === "actor") ? Lecode.S_TBS.actorColorCell : Lecode.S_TBS.enemyColorCell;
    this.getLayer("scopes").drawCell(x, y, opacity, color);
    cell._type = type;
};

BattleManagerTBS.processPositioningPhase = function () {
    this._phase = "positioning";
    this._subPhase = "";
    this._actorsToPositionate = [];
    this._enemiesToPositionate = [];
    $gameTroop.members().forEach(function (mem) {
        this._enemiesToPositionate.push(mem);
    }.bind(this));
    this.allyStartCells().forEach(function (cell) {
        if (cell._positioningData.type === "actor") {
            var id = cell._positioningData.fixed;
            if (id)
                this._actorsToPositionate.push($gameActors.actor(id));
        }
    }.bind(this));
    this.processActorsPrePositioning();
    this.processEnemyPositioning();

    InputHandlerTBS.setOnTouchCallback(this.positioningPhaseOnTouchInput.bind(this))
        .setOnTouchCancelCallback(this.positioningPhaseOnInputCancel.bind(this))
        .setOnOkCallback(this.positioningPhaseOnInputOk.bind(this))
        .setOnCancelCallback(this.positioningPhaseOnInputCancel.bind(this))
        .setOnRightCallback(this.positioningPhaseOnInputRight.bind(this))
        .setOnLeftCallback(this.positioningPhaseOnInputLeft.bind(this))
        .setOnDownCallback(this.positioningPhaseOnInputDown.bind(this))
        .setOnUpCallback(this.positioningPhaseOnInputUp.bind(this))
        .setOnMoveCallback(this.positioningPhaseOnMouseMove.bind(this));
};

BattleManagerTBS.positioningPhaseOnMouseMove = function () {
    if (this._subPhase === "directionSelector_input") {
        var x = $gameMap.canvasToMapX(TouchInput._leTBSMoveData.x);
        var y = $gameMap.canvasToMapY(TouchInput._leTBSMoveData.y);
        var cell = BattleManagerTBS.getCellAt(x, y);
        if (cell) {
            var entity = this._directionSelector._battlerEntity;
            var oldDir = entity.getDir();
            entity.lookAt(cell);
            if (oldDir != entity.getDir())
                this._directionSelector.setDir(entity.getDir());
        }
    }
};

BattleManagerTBS.positioningPhaseOnTouchInput = function (selectedCell) {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByTouch(selectedCell);
            break;
        case "directionSelector_input":
            this.setDirectionSelectionDirByTouch(selectedCell);
            break;
    }
    this.checkStartWindowInput();
};

BattleManagerTBS.checkStartWindowInput = function () {
    var window = LeUtilities.getScene()._windowPositioningConfirm;
    if (window.visible && window.isMouseInsideFrame()) {
        LeUtilities.getScene().onPositioningExitUp();
    }
    window = LeUtilities.getScene()._windowPositioning;
    if (window.visible && !window.active && window.isMouseInsideFrame()) {
        LeUtilities.getScene().onPositioningConfirmCursorDown();
    }
};

BattleManagerTBS.positioningPhaseOnInputOk = function () {
    switch (this._subPhase) {
        case "input":
            this.positioningPhaseOk();
            break;
        case "directionSelector_input":
            this.directionSelectorValidatePositioning();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputCancel = function () {
    switch (this._subPhase) {
        case "input":
            this.positioningPhaseCancel();
            break;
        case "directionSelector_input":
            this.directionSelectorCancelPositioning();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputLeft = function () {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByDir("left");
            break;
        case "directionSelector_input":
            this.setDirectionSelectorLeft();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputRight = function () {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByDir("right");
            break;
        case "directionSelector_input":
            this.setDirectionSelectorRight();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputDown = function () {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByDir("down");
            break;
        case "directionSelector_input":
            this.setDirectionSelectorDown();
            break;
    }
};

BattleManagerTBS.positioningPhaseOnInputUp = function () {
    switch (this._subPhase) {
        case "input":
            this.selectStartCellByDir("up");
            break;
        case "directionSelector_input":
            this.setDirectionSelectorUp();
            break;
    }
};

BattleManagerTBS.updatePositioningPhase = function () {
    if (this._subPhase === "troop") {
        if (!this.getLayer("animations").isAnimationPlaying()) {
            if (this._enemiesToPositionate.length === 0)
                this.waitForPositioningInput();
            else
                this.placeNextEnemy();
        }
    }
};

BattleManagerTBS.processActorsPrePositioning = function () {
    if (this._actorsToPositionate.length === 0) return;
    do {
        var actor = this._actorsToPositionate.shift();
        var cell = this.allyStartCells().filter(function (cell) {
            return cell._positioningData.fixed === actor.actorId();
        })[0];
        var entity = new TBSEntity(actor, this.getLayer("battlers"));
        entity.setCell(cell);
        this._battlerEntities.push(entity);
        LeUtilities.getScene().onActorPrePositioning(actor);
    } while (this._actorsToPositionate.length > 0);
};

BattleManagerTBS.processEnemyPositioning = function () {
    this._subPhase = "troop";
    if (Lecode.S_TBS.instantiateAll) {
        while (this._enemiesToPositionate.length > 0)
            this.placeNextEnemy();
    } else {
        this.placeNextEnemy();
    }
};

BattleManagerTBS.placeNextEnemy = function () {
    var enemy = this._enemiesToPositionate.shift();
    var cells = this.enemyStartCells().filter(function (c) {
        return c._positioningData.fixed === enemy.index() + 1 && this.isCellFree(c);
    }.bind(this));
    if (cells.length === 0) {
        cells = this.enemyStartCells().filter(function (c) {
            return this.isCellFree(c);
        }.bind(this));
    }
    var cell = LeUtilities.getRandomValueInArray(cells);
    if (cell) {
        cell.select();
        this.centerActiveCell();
        this.updateCursor();
        var entity = new TBSEntity(enemy, this.getLayer("battlers"));
        entity.setCell(cell);
        entity.newAnimation(Lecode.S_TBS.placedBattlerAnim, false, 0);
        this._battlerEntities.push(entity);
    }
};

BattleManagerTBS.waitForPositioningInput = function () {
    this._subPhase = "wait";
    this.selectNextStartCell();
    this.cursor().hide();
    LeUtilities.getScene().activatePositioningWindow();
};

BattleManagerTBS.processActorPositioning = function (actor) {
    this.cursor().show();
    InputHandlerTBS.setActive(true);
    this._subPhase = "input";
    var currentEntity = this.getEntityWithActorId(actor.actorId());
    if (currentEntity) {
        this._currentPositioningEntity = currentEntity;
        this.positioningSelect(currentEntity.getCell());
        currentEntity.setOpacity(255);
        currentEntity.startFlash([255, 255, 255, 255], 20, true);
        return;
    }
    var entity = new TBSEntity(actor, this.getLayer("battlers"));
    var cell = this.getNextActorPositioningCell();
    entity.setOpacity(255);
    entity.startFlash([255, 255, 255, 255], 20, true);
    this._currentPositioningEntity = entity;
    this.positioningSelect(cell);
    entity.newAnimation(Lecode.S_TBS.placedBattlerAnim, false, 0);
};

BattleManagerTBS.positioningSelect = function (cell) {
    cell.select();
    this.centerCell(cell);
    this.updateCursor();
    if (this._currentPositioningEntity) {
        var actorId = this._currentPositioningEntity.battler().actorId();
        if (this._positioningEntityToSwap) {
            this._positioningEntityToSwap.stopFLash();
        }
        var entity = cell.getEntity();
        if (entity && entity.battler().actorId() != actorId) {
            this._positioningEntityToSwap = entity;
            this._currentPositioningEntity.stopFLash();
            this._currentPositioningEntity.startFlash([255, 255, 255, 255], 20, true);
            entity.startFlash([255, 255, 255, 255], 20, true);
        } else {
            this._currentPositioningEntity.setCell(cell);
            this.updateEnemiesDirectionForPositioning();
            this._positioningEntityToSwap = null;
        }
    }
};

BattleManagerTBS.selectStartCellByDir = function (dir) {
    var cell = this._activeCell;
    var cells = this.allyStartCells().filter(function (c) {
        return c != cell;
    });
    var found = null;
    switch (dir) {
        case "up":
            cells = cells.filter(function (c) {
                return c.y < cell.y;
            });
            found = LeUtilities.closestByDistance(cell, cells);
            break;
        case "down":
            cells = cells.filter(function (c) {
                return c.y > cell.y;
            });
            found = LeUtilities.closestByDistance(cell, cells);
            break;
        case "right":
            cells = cells.filter(function (c) {
                return c.x > cell.x;
            });
            found = LeUtilities.closestByDistance(cell, cells);
            break;
        case "left":
            cells = cells.filter(function (c) {
                return c.x < cell.x;
            });
            found = LeUtilities.closestByDistance(cell, cells);
            break;
    }
    if (found && found != cell) {
        this.positioningSelect(found);
        SoundManager.playCursor();
    }
};

BattleManagerTBS.selectStartCellByTouch = function (cell) {
    if (cell) {
        var scope = this.allyStartCells();
        var currentCell = this._activeCell;
        if (this.isCellInScope(cell, scope)) {
            if (currentCell.isSame(cell)) {
                this.positioningPhaseOk();
            } else {
                this.positioningSelect(cell);
            }
        } else {
            this.positioningPhaseOk();
        }
    }
};

BattleManagerTBS.getNextActorPositioningCell = function () {
    if (this.allyEntities().length >= this.allyStartCells().length)
        return this.allyStartCells()[0];
    var currentIndex = this.allyStartCells().indexOf(this._activeCell);
    if (currentIndex === -1) {
        return this.allyStartCells()[0];
    }
    var cell = this._activeCell;
    var currentEntity = cell.getEntity();
    if (!currentEntity)
        return cell;
    var index = currentIndex;
    do {
        if (index === this.allyStartCells().length - 1)
            index = 0;
        else
            index++;
        cell = this.allyStartCells()[index];
        currentEntity = cell.getEntity();
    } while (currentEntity);
    return cell;
};

BattleManagerTBS.selectNextStartCell = function () {
    var cell = this.getNextActorPositioningCell();
    this.positioningSelect(cell);
    SoundManager.playCursor();
};

BattleManagerTBS.positioningPhaseOk = function () {
    SoundManager.playOk();
    var cell = this._activeCell;
    var entity = this._positioningEntityToSwap;
    if (entity) {
        entity.setCell(this._currentPositioningEntity.getCell());
        entity.stopFLash();
        this._currentPositioningEntity.setCell(cell);
        this._positioningEntityToSwap = null;
        return;
    }
    var actorId = this._currentPositioningEntity.battler().actorId();
    var currentEntity = this.getEntityWithActorId(actorId);
    if (!currentEntity)
        this._battlerEntities.push(this._currentPositioningEntity);
    this.callDirectionSelector(this._currentPositioningEntity, cell);
    LeUtilities.getScene()._windowPositioningConfirm.setEnabled(true);
    LeUtilities.getScene()._windowPositioningConfirm.refresh();
};

BattleManagerTBS.positioningPhaseCancel = function () {
    var entity = this._currentPositioningEntity;
    if (!entity) {
        SoundManager.playBuzzer();
        return;
    }
    InputHandlerTBS.setActive(false);
    var actor = LeUtilities.getScene()._windowPositioning.actor();
    LeUtilities.getScene()._windowPositioning.enableSelection();
    LeUtilities.getScene()._windowPositioning.refresh();
    LeUtilities.getScene().activatePositioningWindow();
    this.cursor().hide();
    SoundManager.playCancel();
    this.destroyEntity(entity);
    this._currentPositioningEntity = null;
    if (this.allyEntities().length === 0) {
        LeUtilities.getScene()._windowPositioningConfirm.setEnabled(false);
        LeUtilities.getScene()._windowPositioningConfirm.refresh();
    }
};

BattleManagerTBS.updateEnemiesDirectionForPositioning = function () {
    var actors = this.allyEntities().concat([this._currentPositioningEntity]);
    this.enemyEntities().forEach(function (ent) {
        ent.lookClosestBattler(actors);
    }.bind(this));
};

BattleManagerTBS.callDirectionSelector = function (battler, cell) {
    this._subPhase = "directionSelector_input";
    this._directionSelector.set(cell, battler);
    LeUtilities.getScene().hidePositioningWindow(cell, battler);
};

BattleManagerTBS.setDirectionSelectorUp = function () {
    this._directionSelector.setDir(8);
};

BattleManagerTBS.setDirectionSelectorDown = function () {
    this._directionSelector.setDir(2);
};

BattleManagerTBS.setDirectionSelectorLeft = function () {
    this._directionSelector.setDir(4);
};

BattleManagerTBS.setDirectionSelectorRight = function () {
    this._directionSelector.setDir(6);
};

BattleManagerTBS.directionSelectorValidatePositioning = function () {
    SoundManager.playOk();
    Input.clear();
    this._currentPositioningEntity.stopFLash();
    this._currentPositioningEntity.setOpacity(255);
    this._directionSelector.hide();
    this._subPhase = "";
    this._currentPositioningEntity = null;
    LeUtilities.getScene().activatePositioningWindow();
    this.cursor().hide();
    if (this.allyEntities().length === $gameParty.battleMembers().length) {
        LeUtilities.getScene()._windowPositioning.deactivate();
        LeUtilities.getScene()._windowPositioning.deselect();
        this.positioningPhaseEnd();
    }
};

BattleManagerTBS.setDirectionSelectionDirByTouch = function (selectedCell) {
    var entity = this._directionSelector._battlerEntity;
    entity.lookAt(selectedCell);
    this.directionSelectorValidatePositioning();
};

BattleManagerTBS.directionSelectorCancelPositioning = function () {
    this._directionSelector.hide();
    this._subPhase = "input";
    this.positioningPhaseCancel();
};

BattleManagerTBS.positioningPhaseEnd = function () {
    this._subPhase = "confirm";
    Input.clear();
    LeUtilities.getScene().showConfirmationWindow();
};

BattleManagerTBS.resumePositioningPhase = function () {
    LeUtilities.getScene().hideConfirmationWindow();
    LeUtilities.getScene().activatePositioningWindow();
    LeUtilities.getScene()._windowPositioningConfirm.deselect();
    this._subPhase = "";
};

BattleManagerTBS.onConfirmationWindowOK = function () {
    switch (this._phase) {
        case "positioning":
            this.battleBeginning();
            break;
    }
};

BattleManagerTBS.onConfirmationWindowCancel = function () {
    switch (this._phase) {
        case "positioning":
            this.resumePositioningPhase();
            break;
    }
};

BattleManagerTBS.battleBeginning = function () {
    this._phase = "battle_beginning";
    LeUtilities.getScene().onTBSBattleBeginning();

    this._startSprite.visible = true;
    this._startSprite.x = Graphics.width / 2 - this._startSprite.width / 2;
    this._startSprite.y = Graphics.height / 2 - this._startSprite.height / 2;
    this._startSprite.opacity = 0;
    this._subPhase = "in";
};

BattleManagerTBS.updateBeginningPhase = function () {
    var opa;
    if (this._subPhase === "in") {
        opa = this._startSprite.opacity;
        this._startSprite.opacity = (opa + 6).clamp(0, 255);
        if (this._startSprite.opacity === 255) {
            this._subPhase = "wait";
            this.wait(Lecode.S_TBS.battleStartSpriteDelay);
        }
    } else if (this._subPhase === "wait") {
        if (!this.isWaiting())
            this._subPhase = "out";
    } else if (this._subPhase === "out") {
        opa = this._startSprite.opacity;
        this._startSprite.opacity = (opa - 6).clamp(0, 255);
        if (this._startSprite.opacity === 0) {
            this.beginningPhaseEnd();
        }
    }
};

BattleManagerTBS.beginningPhaseEnd = function () {
    this._startSprite.visible = false;
    this.cursor().show();
    this.processBattle();
};

BattleManagerTBS.processBattle = function () {
    InputHandlerTBS.setActive(true);
    this._phase = "battle_processing";
    this._subPhase = "";

    BattleManager.startBattle();
    this.allEntities().forEach(function (entity) {
        entity.onBattleStart();
    }.bind(this));
    this.hidePositioningCells();
    this.determineTurnOrder();
    //$gameTroop.increaseTurn();
    this.setEntitiesFlag();
    this.executeEventsAtBattleStart();
    this.startTurn();

    InputHandlerTBS.setOnTouchCallback(this.battlePhaseOnTouchInput.bind(this))
        .setOnTouchCancelCallback(this.battlePhaseOnInputCancel.bind(this))
        .setOnOkCallback(this.battlePhaseOnInputOk.bind(this))
        .setOnCancelCallback(this.battlePhaseOnInputCancel.bind(this))
        .setOnUpCallback(this.battlePhaseOnInputUp.bind(this))
        .setOnRightCallback(this.battlePhaseOnInputRight.bind(this))
        .setOnDownCallback(this.battlePhaseOnInputDown.bind(this))
        .setOnLeftCallback(this.battlePhaseOnInputLeft.bind(this));
};

BattleManagerTBS.battlePhaseOnTouchInput = function (selectedCell) {
    switch (this._subPhase) {
        case "move":
            this.touchMoveSelection(selectedCell);
            break;
        case "directionSelector_input":
            this.passByTouch(selectedCell);
            break;
        case "attack":
        case "skill":
        case "item":
            this.touchActionSelection(selectedCell);
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputOk = function () {
    switch (this._subPhase) {
        case "move":
            this.validateMoveSelection();
            break;
        case "directionSelector_input":
            this.validatePass();
            break;
        case "attack":
        case "skill":
        case "item":
            this.validateActionSelection();
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputCancel = function () {
    switch (this._subPhase) {
        case "move":
            this.onMoveCancel();
            break;
        case "directionSelector_input":
            this.cancelPass();
            break;
        case "attack":
        case "skill":
        case "item":
            this.onActionCancel();
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputLeft = function () {
    switch (this._subPhase) {
        case "directionSelector_input":
            this.setDirectionSelectorLeft();
            break;
        case "move":
        case "attack":
        case "skill":
        case "item":
        case "examine":
            this.moveCursor("left");
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputRight = function () {
    switch (this._subPhase) {
        case "directionSelector_input":
            this.setDirectionSelectorRight();
            break;
        case "move":
        case "attack":
        case "skill":
        case "item":
        case "examine":
            this.moveCursor("right");
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputDown = function () {
    switch (this._subPhase) {
        case "directionSelector_input":
            this.setDirectionSelectorDown();
            break;
        case "move":
        case "attack":
        case "skill":
        case "item":
        case "examine":
            this.moveCursor("down");
            break;
    }
};

BattleManagerTBS.battlePhaseOnInputUp = function () {
    switch (this._subPhase) {
        case "directionSelector_input":
            this.setDirectionSelectorUp();
            break;
        case "move":
        case "attack":
        case "skill":
        case "item":
        case "examine":
            this.moveCursor("up");
            break;
    }
};

BattleManagerTBS.updateBattleProcessing = function () {
    this.updateSequences();
    if (this._subPhase === "moving") {
        if (!this.activeEntity().isMoving() && !this.isWaiting())
            this.onActiveEntityMoveEnd();
    } else if (this._subPhase === "obj_invokation") {
        if (!this.anySequenceRunning())
            this.onActionEnd();
    } else if (this._subPhase === "ai") {
        this._aiManager.update();
    } else if (this._subPhase === "turn_end")
        this.updateEndOfTurnEvents();
    else if (this._subPhase === "next_turn")
        this.updateStartOfTurnEvents();
    else if (this._subPhase === "turn_starting")
        this.startTurn();
};

BattleManagerTBS.hidePositioningCells = function () {
    this.getLayer("scopes").clear();
};

BattleManagerTBS.determineTurnOrder = function () {
    if (Lecode.S_TBS.turnOrderFairRepartition)
        this.determineTurnOrderFair();
    else
        this.determineTurnOrderSimple();
};

BattleManagerTBS.determineTurnOrderSimple = function () {
    var array = [];
    this._turnOrder = [];
    this._activeIndex = 0;

    this.allPlayableEntities().forEach(function (entity) {
        array.push(entity);
    });
    array = array.sort(function (a, b) {
        return b._battler.agi - a._battler.agi;
    });

    this._turnOrder = array;
    this._turnOrderVisual.set(this._turnOrder);
};

BattleManagerTBS.determineTurnOrderFair = function () {
    var array = [];
    var actors = [];
    var enemies = [];
    this._turnOrder = [];
    this._activeIndex = 0;

    this.allyEntities().forEach(function (entity) {
        actors.push(entity);
    });
    actors = actors.sort(function (a, b) {
        return b._battler.agi - a._battler.agi;
    });

    this.enemyEntities().forEach(function (entity) {
        enemies.push(entity);
    });
    enemies = enemies.sort(function (a, b) {
        return b._battler.agi - a._battler.agi;
    });

    var partySet = actors[0]._battler.agi >= enemies[0]._battler.agi ? actors : enemies;
    var partyLeft = actors[0]._battler.agi >= enemies[0]._battler.agi ? enemies : actors;
    while (partySet.length > 0)
        array.push(partySet.shift());
    var index = 0;
    while (partyLeft.length > 0) {
        array.splice(index + 1, 0, partyLeft.shift());
        index += 2;
    }

    this._turnOrder = array;
    this._turnOrderVisual.set(this._turnOrder);
};

BattleManagerTBS.setEntitiesFlag = function () {
    this.allEntities().forEach(function (entity) {
        var cell = entity.getCell();
        if (this._startupFlags[cell.x]) {
            entity._flag = this._startupFlags[cell.x][cell.y];
        }
    }.bind(this));
};

BattleManagerTBS.activeEntity = function () {
    return this._turnOrder[this._activeIndex];
};

BattleManagerTBS.activeBattler = function () {
    return this.activeEntity()._battler;
};

BattleManagerTBS.startTurn = function () {
    if (this.turnOrderShouldWait()) {
        this._subPhase = "turn_starting";
        return;
    }
    this._actionScope = {};
    this.getLayer("scopes").clear();
    this.getLayer("scopes").clearSelection();
    this._subPhase = "";
    var entity = this.activeEntity();
    entity.onTurnStart();

    var battler = this.activeBattler();
    this.newAction(battler, true);
    LeUtilities.getScene().showStatusWindow(entity, true);

    var cell = entity.getCell();
    this.setCursorCell(cell);
    this.cursor().show();

    if (!entity.playableByAI()) {
        LeUtilities.getScene().showCommandWindow();
    } else {
        this.startAiTurn(entity, battler);
    }
};

BattleManagerTBS.startAiTurn = function (entity, battler) {
    this._subPhase = "ai";
    if (battler.isDead())
        this.processCommandPass();
    else
        this._aiManager.process(entity);
    if (!Lecode.S_TBS.showScopes)
        this.cursor().hide();
};

BattleManagerTBS.updateSequences = function () {
    this.allEntities().forEach(function (entity) {
        entity._sequenceManager.update();
    });
};

BattleManagerTBS.anySequenceRunning = function () {
    return this.allEntities().some(function (entity) {
        return entity._sequenceManager.isRunning();
    });
};

BattleManagerTBS.newAction = function (battler, isFloating) {
    this._activeAction = isFloating ? new TBS_FloatingAction(battler, false) : new Game_Action(battler, false);
};

BattleManagerTBS.moveCursor = function (dir) {
    var x = this._activeCell.x,
        y = this._activeCell.y;
    switch (dir) {
        case "up":
            y--;
            break;
        case "down":
            y++;
            break;
        case "right":
            x++;
            break;
        case "left":
            x--;
            break;
    }
    var cell = this.getCellAt(x, y);
    this.setCursorCell(cell);
    SoundManager.playCursor();
};

BattleManagerTBS.setCursorCell = function (cell) {
    if (!cell) return;
    cell.select();
    this.centerCell(cell);
    this.updateCursor();
    this.updateScopeSelection();
    this.updateTargetStatus();
};

BattleManagerTBS.updateScopeSelection = function () {
    if (this.cursorOnMoveScope())
        this.updateMoveSelection();
    else if (this.cursorOnActionScope()) {
        this.updateActionSelection();
    } else {
        this.clearActionSelection();
        this.clearMoveSelection();
    }
};

BattleManagerTBS.updateTargetStatus = function () {
    var cell = this._activeCell;
    var entity = cell.getEntity();
    var scene = LeUtilities.getScene();
    if (entity) {
        scene.showStatusWindow(entity);
    } else {
        scene.showStatusWindow(this.activeEntity());
    }
};

BattleManagerTBS.onCommandInput = function (command) {
    switch (command) {
        case "move":
            this.processCommandMove();
            break;
        case "attack":
            this.processCommandAttack();
            break;
        case "skill":
            this.processCommandSkill();
            break;
        case "item":
            this.processCommandItem();
            break;
        case "pass":
            this.processCommandPass();
            break;
        case "cancel":
            this.processCommandCancel();
            break;
    }
};

BattleManagerTBS.processCommandMove = function () {
    this._subPhase = "move";
    this.drawMoveScope(this.activeEntity());
};

BattleManagerTBS.makeMoveScope = function (entity, isFloating) {
    var center = entity.getCell().toCoords();
    var points = entity.getMovePoints();
    var param = this.makeMoveScopeParam(entity);
    var data = entity.getMoveScopeData();
    var scope = this.getScopeFromData(data, center, param, points);
    if (isFloating) {
        return {
            cells: scope,
            center: center
        };
    }
    this._moveScope = {};
    this._moveScope.cells = scope;
    this._moveScope.center = center;
};

BattleManagerTBS.drawMoveScope = function (entity) {
    this.makeMoveScope(entity);
    var scope = this._moveScope.cells;
    var color = Lecode.S_TBS.moveColorCell;
    var opa = Lecode.S_TBS.moveCellOpacity;
    var invalidOpa = Lecode.S_TBS.moveInvalidCellOpacity;
    var invalidCondition = "!cell._walkable";
    this.getLayer("scopes").clear();
    this.drawScope(scope, color, opa, invalidOpa, invalidCondition);
};

BattleManagerTBS.makeMoveScopeParam = function (entity) {
    var param = {
        user: entity,
        dir: entity.getDir(),
        exclude_center: true,
        can_select_obstacles: false,
        cells_reachable: true,
    };
    var data = entity.getMoveScopeParamData();
    data = LeUtilities.stringSplit(data, ",");
    data.forEach(function (arg) {
        if (arg.match(/through_obstacles/i))
            param.cells_reachable = false;
    }.bind(this));
    return param;
};

BattleManagerTBS.cursorOnMoveScope = function () {
    if (!this.isMoveScopeAvailable()) return false;
    for (var i = 0; i < this.moveScope().cells.length; i++) {
        var cell = this.moveScope().cells[i];
        if (cell._walkable) // && !cell.isObstacle())
            if (cell.x == this.cursor().cellX && cell.y == this.cursor().cellY)
                return true;
    }
    return false;
};

BattleManagerTBS.updateMoveSelection = function () {
    var sx = this.moveScope().center.x,
        sy = this.moveScope().center.y,
        dx = this.cursor().cellX,
        dy = this.cursor().cellY;
    this._movePath = this.getPathFromAToB(sx, sy, dx, dy, "walkable");
    if (!(this._subPhase === "ai" && !Lecode.S_TBS.showScopes))
        this.drawMoveSelection();
};

BattleManagerTBS.drawMoveSelection = function () {
    this.clearMoveSelection();
    var color = Lecode.S_TBS.moveColorCell;
    var scolor = Lecode.S_TBS.selectedMoveColorCell;
    var opacity = Lecode.S_TBS.moveSelectedCellOpacity;
    this.getLayer("scopes").drawSelectionCells(this.movePath(), opacity, color, scolor);
};

BattleManagerTBS.clearMoveSelection = function () {
    this.getLayer("scopes").clearSelection();
};

BattleManagerTBS.validateMoveSelection = function () {
    if (!this.cursorOnMoveScope()) {
        SoundManager.playBuzzer();
        return;
    }
    SoundManager.playOk();
    this.activeEntity().processMovement(this.movePath());
    this._subPhase = "moving";
};

BattleManagerTBS.touchMoveSelection = function (selectedCell) {
    var oldActiveCell = this._activeCell;
    this.setCursorCell(selectedCell);
    if (this.cursorOnMoveScope() && InputHandlerTBS.lastSelectedCell().isSame(selectedCell)) {
        this.validateMoveSelection();
    }
};

BattleManagerTBS.onActiveEntityMoveEnd = function () {
    this._subPhase = "";
    this.getLayer("scopes").clear();
    this.clearMoveSelection();
    this._moveScope = {};

    this.activeEntity()._movePerformed = true;
    if (!this.activeEntity().playableByAI()) {
        if (Lecode.S_TBS.autoPass && !this.activeEntity().canMoveCommand() && this.activeEntity()._actionPerformed)
            this.processCommandPass();
        else
            LeUtilities.getScene().showCommandWindow();
    }
    LeUtilities.getScene().showStatusWindow(this.activeEntity());
    var cell = this.activeEntity().getCell();
    this.setCursorCell(cell);

    this.updateEndOfActionEvents();
};

BattleManagerTBS.onMoveCancel = function () {
    this._subPhase = "";
    this.getLayer("scopes").clear();
    this.clearMoveSelection();
    this._moveScope = {};

    LeUtilities.getScene().showCommandWindow();
    var cell = this.activeEntity().getCell();
    this.setCursorCell(cell);
    Input.clear();

    SoundManager.playCancel();
};

BattleManagerTBS.isMoveScopeAvailable = function () {
    return this.moveScope() && this.moveScope().cells && this.moveScope().center;
};

BattleManagerTBS.processCommandAttack = function () {
    this._subPhase = "attack";
    this.activeAction().setAttack();
    this.drawAttackScope(this.activeEntity());
};

BattleManagerTBS.makeAttackScope = function (entity) {
    var data = entity.getAttackScopeData();
    this.makeActionScope(entity, data);
};

BattleManagerTBS.drawAttackScope = function (entity) {
    this.makeAttackScope(entity);
    this._actionScopeParam = {
        color: Lecode.S_TBS.attackColorCell,
        scolor: Lecode.S_TBS.selectedAttackColorCell,
        opacity: Lecode.S_TBS.attackCellOpacity,
        invalidOpa: Lecode.S_TBS.attackInvalidCellOpacity
    };
    this.drawActionScope(entity);
    this.updateScopeSelection();
};

BattleManagerTBS.updateAttackSelection = function () {
    this._actionAoE = this.getAttackAoE();
    if (!(this._subPhase === "ai" && !Lecode.S_TBS.showScopes))
        this.drawActionSelection();
};

BattleManagerTBS.getAttackAoE = function () {
    var data = this.activeEntity().getAttackAoEData();
    var center = this._activeCell.toCoords();
    var param = this.makeObjAoEParam(null, this.activeEntity(), center);
    return this.getScopeFromData(data, center, param);
};

BattleManagerTBS.processCommandSkill = function () {
    LeUtilities.getScene().showSkillWindow();
};

BattleManagerTBS.onSkillInput = function (command) {
    switch (command) {
        case "ok":
            this.onSkillSelected();
            break;
        case "cancel":
            this.onActionCancel();
            break;
    }
};

BattleManagerTBS.onSkillSelected = function () {
    var skill = LeUtilities.getScene()._windowSkill.item();
    if (skill) {
        this._subPhase = "skill";
        this.activeAction().setItemObject(skill);
        this.drawSkillScope(this.activeEntity());
    }
};

BattleManagerTBS.makeSkillScope = function (entity, obj) {
    obj = obj || this.activeAction().item();
    var data = entity.getObjectScopeData(obj);
    this.makeActionScope(entity, data);
};

BattleManagerTBS.drawSkillScope = function (entity) {
    this.makeSkillScope(entity);
    this._actionScopeParam = {
        color: Lecode.S_TBS.skillColorCell,
        scolor: Lecode.S_TBS.selectedSkillColorCell,
        opacity: Lecode.S_TBS.skillCellOpacity,
        invalidOpa: Lecode.S_TBS.skillInvalidCellOpacity,
        selectedOpacity: Lecode.S_TBS.skillSelectedCellOpacity
    };
    this.drawActionScope(entity);
    this.updateScopeSelection();
};

BattleManagerTBS.processCommandItem = function () {
    LeUtilities.getScene().showItemWindow();
};

BattleManagerTBS.onItemInput = function (command) {
    switch (command) {
        case "ok":
            this.onItemSelected();
            break;
        case "cancel":
            this.onActionCancel();
            break;
    }
};

BattleManagerTBS.onItemSelected = function () {
    var item = LeUtilities.getScene()._windowItem.item();
    if (item) {
        this._subPhase = "item";
        this.activeAction().setItemObject(item);
        this.drawItemScope(this.activeEntity());
    }
};

BattleManagerTBS.makeItemScope = function (entity, obj) {
    obj = obj || this.activeAction().item();
    var data = entity.getObjectScopeData(obj);
    this.makeActionScope(entity, data);
};

BattleManagerTBS.drawItemScope = function (entity) {
    this.makeItemScope(entity);
    this._actionScopeParam = {
        color: Lecode.S_TBS.ItemColorCell,
        scolor: Lecode.S_TBS.selectedItemColorCell,
        opacity: Lecode.S_TBS.ItemCellOpacity,
        invalidOpa: Lecode.S_TBS.ItemInvalidCellOpacity,
        selectedOpacity: Lecode.S_TBS.ItemSelectedCellOpacity
    };
    this.drawActionScope(entity);
    this.updateScopeSelection();
};

BattleManagerTBS.updateActionSelection = function () {
    this._actionAoE = this.getActionAoE();
    if (!(this._subPhase === "ai" && !Lecode.S_TBS.showScopes))
        this.drawActionSelection();
};

BattleManagerTBS.getActionAoE = function () {
    var obj = this.activeAction().item();
    var data = this.activeEntity().getObjectAoEData(obj);
    var center = this._activeCell.toCoords();
    var param = this.makeObjAoEParam(obj, this.activeEntity(), center);
    return this.getScopeFromData(data, center, param);
};

BattleManagerTBS.validateActionSelection = function () {
    if (!this.cursorOnActionScope()) {
        SoundManager.playBuzzer();
        return;
    }
    SoundManager.playOk();

    this.getLayer("scopes").clear();
    this.clearActionSelection();

    var cell = this.getCellAt(this.cursor().cellX, this.cursor().cellY);
    this.activeEntity().lookAt(cell);
    this.processAction();
};

BattleManagerTBS.touchActionSelection = function (selectedCell) {
    var oldActiveCell = this._activeCell;
    this.setCursorCell(selectedCell);
    if (this.cursorOnActionScope() && InputHandlerTBS.lastSelectedCell().isSame(selectedCell)) {
        this.validateActionSelection();
    }
};

BattleManagerTBS.onActionCancel = function () {
    this._subPhase = "";
    this.getLayer("scopes").clear();
    this.clearActionSelection();
    this._actionScope = {};

    LeUtilities.getScene().showCommandWindow();
    var cell = this.activeEntity().getCell();
    this.setCursorCell(cell);

    Input.clear();
    SoundManager.playCancel();
};

BattleManagerTBS.isActionScopeAvailable = function () {
    return this.actionScope() && this.actionScope().cells && this.actionScope().center;
};

BattleManagerTBS.processAction = function () {
    this._subPhase = "obj_invokation";
    var action = this.activeAction();
    var item = action.item();
    var entity = this.activeEntity();
    var id = action.isAttack() ? entity.getWeaponSequenceData() : entity.getObjectSequenceData(item);
    var fastSequence = action.isAttack() ? entity.getWeaponFastSequence() : entity.getObjectFastSequence(item);
    this.activeBattler().useItem(item);
    action.applyGlobal();
    entity.onActionStart(id, fastSequence, action);
    if (fastSequence.length > 0)
        entity.startSequence(fastSequence, action);
    else
        entity.startSequence(id, action);
};

BattleManagerTBS.processCounterAttack = function (targets, subject, action) {
    if (!action) return;
    this.setCursorCell(subject.getCell());
    targets.forEach(function (entity) {
        var dist = LeUtilities.distanceBetweenCells(subject.getCell(), entity.getCell());
        if (dist <= 1 && Math.random() < action.itemCnt(entity.battler())) {
            var skill = $dataSkills[entity.battler().attackSkillId()];
            entity.lookAt(subject.getCell());
            entity.startSequence("counter");
            entity.executeAction(skill);
        }
    }.bind(this));
};

BattleManagerTBS.invokeObjEffects = function (user, item, targets, hitAnim, animDelay) {
    this.activeAction().setItemObject(item);
    this.prepareDirectionalDamageBonus(user, targets, item);
    this.applyObjEffects(user, targets, hitAnim, animDelay);
    this.resetDirectionalDamageBonus(targets);
    this.refreshBattlersStatus();
};

BattleManagerTBS.applyObjEffects = function (user, targets, hitAnim, animDelay) {
    targets.forEach(function (target) {
        target.prepareExtraPopups();
        if (Math.random() < this.activeAction().itemMrf(target.battler()))
            this.processMagicReflection(user, target, hitAnim, animDelay);
        else {
            this.activeAction().apply(target.battler());
            if (target.battler().result().isHit()) {
                if (hitAnim)
                    target.newAnimation(hitAnim, false, animDelay);
                if (target.battler().result().hpDamage > 0)
                    target.callSequence("damaged");
            } else {
                target.callSequence("evaded");
            }
            target.applyObjChangeMovePoints(this.activeAction().item());
            target.onDamage();
        }
    }.bind(this));
};

BattleManagerTBS.processMagicReflection = function (user, target, hitAnim, animDelay) {
    var cell = target.getCell();
    user.prepareExtraPopups();
    target.newAnimation(178, false, 0);
    this.activeAction().apply(user.battler());
    if (user.battler().result().isHit()) {
        if (hitAnim)
            user.newAnimation(hitAnim, false, animDelay);
        if (user.battler().result().hpDamage > 0)
            user.callSequence("damaged");
    } else {
        user.callSequence("evaded");
    }
    user.applyObjChangeMovePoints(this.activeAction().item());
    user.onDamage();
};

BattleManagerTBS.invokeObjEffectsOnMap = function (user, item, cellTargets, hitAnim, animDelay) {
    this.applyObjEffectsOnMap(user, item, cellTargets, hitAnim, animDelay);
    this.refreshBattlersStatus();
};

BattleManagerTBS.applyObjEffectsOnMap = function (user, item, cellTargets, hitAnim, animDelay) {
    cellTargets.forEach(function (cell) {
        var target = cell.getEntity();
        var sprite;
        if (target) {
            if (Math.random() < this.activeAction().itemMrf(target.battler()))
                this.processMagicReflectionOnMap(user, target, hitAnim, animDelay);
            else {
                this.prepareDirectionalDamageBonus(user, [target], item);
                this.activeAction().apply(target.battler());
                if (target.battler().result().isHit()) {
                    sprite = target._sprite;
                    if (target.battler().result().hpDamage > 0)
                        target.callSequence("damaged");
                } else {
                    target.callSequence("evaded");
                }
                target.applyObjChangeMovePoints(this.activeAction().item());
                target.onDamage();
                this.resetDirectionalDamageBonus([target]);
            }
        }
        if (hitAnim)
            this.getLayer("animations").newAnimation(hitAnim, false, animDelay, cell, sprite);
    }.bind(this));
};

BattleManagerTBS.processMagicReflectionOnMap = function (user, target, hitAnim, animDelay) {
    var sprite;
    var cell = user.getCell();
    user.prepareExtraPopups();
    this.prepareDirectionalDamageBonus(target, [user], item);
    this.activeAction().apply(user.battler());
    if (user.battler().result().isHit()) {
        sprite = user._sprite;
        if (user.battler().result().hpDamage > 0)
            user.callSequence("damaged");
    } else {
        user.callSequence("evaded");
    }
    user.applyObjChangeMovePoints(this.activeAction().item());
    user.onDamage();
    this.resetDirectionalDamageBonus([target]);
    if (hitAnim)
        this.getLayer("animations").newAnimation(hitAnim, false, animDelay, cell, sprite);
};

BattleManagerTBS.applyFloatingDamage = function (amount, target) {
    target.battler().gainHp(-amount);
    target.addPopup();
    target.callSequence("damaged");
    target.checkDeath();
};

BattleManagerTBS.refreshBattlersStatus = function () {
    LeUtilities.getScene()._windowStatus.refresh();
};

BattleManagerTBS.onActionEnd = function () {
    this._subPhase = "";
    this._actionScope = {};
    var cell = this.activeEntity().getCell();
    this.setCursorCell(cell);
    Input.clear();
    this.activeEntity()._actionPerformed = true;
    LeUtilities.getScene().showStatusWindow(this.activeEntity());

    var obj = this.activeAction().item();
    if (this.activeEntity().passAfterObjUse(obj))
        this.processCommandPass();
    else if (!this.activeEntity().playableByAI()) {
        if (Lecode.S_TBS.autoPass && !this.activeEntity().canMoveCommand())
            this.processCommandPass();
        else
            LeUtilities.getScene().showCommandWindow();
    }

    this.getLayer("scopes").clear();
    this.getLayer("scopes").clearSelection();

    this.updateEndOfActionEvents();
};

BattleManagerTBS.processCommandPass = function () {
    var entity = this.activeEntity();
    var cell = entity.getCell();
    if (!this.activeEntity().playableByAI() && Lecode.S_TBS.enableDirectionalFacing) {
        this._subPhase = "directionSelector_input";
        this._beforePassDir = entity.getDir();
        this._directionSelector.set(cell, entity);
    } else {
        this.validatePass();
    }
};

BattleManagerTBS.cancelPass = function () {
    this._subPhase = "";
    this._directionSelector.hide();
    LeUtilities.getScene().showCommandWindow();
    Input.clear();
    SoundManager.playCancel();
    this.activeEntity().setDir(this._beforePassDir);
};

BattleManagerTBS.validatePass = function () {
    this._directionSelector.hide();
    this.turnEnd();
};

BattleManagerTBS.passByTouch = function (selectedCell) {
    var entity = this._directionSelector._battlerEntity;
    entity.lookAt(selectedCell);
    this.validatePass();
};

BattleManagerTBS.turnEnd = function () {
    this._subPhase = "turn_end";
    this.activeEntity().onTurnEnd();
};

BattleManagerTBS.updateEndOfActionEvents = function () {
    this.checkDefeatAndVictory();
};

BattleManagerTBS.turnOrderShouldWait = function () {
    var canContinue = !this.updateEvents() && this.checkDefeatAndVictory() && !this.isWaiting() && !this.anySequenceRunning();
    return !canContinue;
};

BattleManagerTBS.updateStartOfTurnEvents = function () {
    if (!this.turnOrderShouldWait()) {
        this.nextTurn();
    }
};

BattleManagerTBS.updateEndOfTurnEvents = function () {
    if (!this.turnOrderShouldWait()) {
        this._subPhase = "next_turn";
    }
};

BattleManagerTBS.updateEvents = function () {
    $gameTroop.updateInterpreter();
    $gameParty.requestMotionRefresh();
    if ($gameTroop.isEventRunning() || $gameMap.isEventRunning()) {
        return true;
    }
    $gameTroop.setupBattleEvent();
    if ($gameTroop.isEventRunning() || SceneManager.isSceneChanging()) {
        return true;
    }
    return false;
};

BattleManagerTBS.nextTurn = function () {
    do {
        this._activeIndex++;
        if (this._activeIndex >= this._turnOrder.length) {
            this._activeIndex = 0;
            this.onTurnOrderEnd();
        }
    } while (this.activeEntity()._dead);
    this._turnOrderVisual.updateOnNextTurn(this._turnOrder, this._activeIndex);
    this.startTurn();
};

BattleManagerTBS.onTurnOrderEnd = function () {
    $gameTroop.increaseTurn();
    this.executeEventsAtTurnOrderEnd();
};

BattleManagerTBS.processCommandCancel = function () {
    LeUtilities.getScene().showEndCommandWindow();
};

BattleManagerTBS.onEndCommandInput = function (command) {
    switch (command) {
        case "options":
            break;
        case "escape":
            this.processEscape();
            break;
        case "cancel":
            this.resumeBattle();
            break;
    }
};

BattleManagerTBS.resumeBattle = function () {
    LeUtilities.getScene().showCommandWindow();
    Input.clear();
};

BattleManagerTBS.processEscape = function () {
    $gameParty.performEscape();
    var success = BattleManager._preemptive ? true : (Math.random() < BattleManager._escapeRatio);
    if (success) {
        BattleManager._escaped = true;
        SoundManager.playEscape();
        this.prepareAbort();
    } else {
        var audio = {};
        audio.name = Lecode.S_TBS.escapeSound;
        audio.pitch = 100;
        audio.volume = 90;
        audio.pan = 0;
        AudioManager.playSe(audio);
        BattleManager._escapeRatio += 0.1;
        this.resumeBattle();
        this.nextTurn();
    }
};

BattleManagerTBS.checkDefeatAndVictory = function () {
    if (this.canPrepareDefeat()) {
        this.prepareDefeat();
        return false;
    } else if (this.canPrepareVictory()) {
        this.prepareVictory();
        return false;
    }
    return true;
};

BattleManagerTBS.canPrepareDefeat = function () {
    return this.allyEntities().every(function (entity) {
        return entity.battler().isDead();
    });
};

BattleManagerTBS.canPrepareVictory = function () {
    return $gameTroop.isAllDead();
};

BattleManagerTBS.prepareAbort = function () {
    this._battleStopStatus = "abort";
    this.stopBattle();
};

BattleManagerTBS.prepareDefeat = function () {
    this._battleStopStatus = "defeat";
    this.stopBattle();
};

BattleManagerTBS.prepareVictory = function () {
    this._battleStopStatus = "victory";
    this.stopBattle();
    this.allyEntities().forEach(function (entity) {
        entity.startSequence("victory");
    });
};

BattleManagerTBS.processDefeat = function () {
    BattleManager.processDefeat();
    this._phase = "battle_end";
    this.enemyEntities().forEach(function (entity) {
        entity.startSequence("victory");
    });
};

BattleManagerTBS.processAbort = function () {
    BattleManager.processAbort();
    this._phase = "battle_end";
};

BattleManagerTBS.processVictory = function () {
    BattleManager.processVictory();
    this._phase = "battle_end";
};

BattleManagerTBS.stopBattle = function () {
    InputHandlerTBS.setActive(false);
    this._phase = "battle_stopping";
    this.wait(Lecode.S_TBS.endOfBattleWait);
    this.executeEventsAtBattleEnd();
};

BattleManagerTBS.updateBattleStopping = function () {
    LeUtilities.getScene()._windowCommand.close();
    this._directionSelector.hide();
    this.updateSequences();
    if (this.updateEvents() || this.anySequenceRunning()) return;
    var waiting = this.isWaiting();
    switch (this._battleStopStatus) {
        case "abort":
            waiting = waiting || this.isWaitingForAbortEvents();
            break;
        case "victory":
            waiting = waiting || this.isWaitingForVictoryEvents();
            break;
        case "defeat":
            waiting = waiting || this.isWaitingForDefeatEvents();
            break;
    }
    if (!waiting) {
        switch (this._battleStopStatus) {
            case "abort":
                this.processAbort();
                break;
            case "victory":
                this.processVictory();
                break;
            case "defeat":
                this.processDefeat();
                break;
        }
    }
};

BattleManagerTBS.isWaitingForAbortEvents = function () {
    return false;
};

BattleManagerTBS.isWaitingForVictoryEvents = function () {
    return false;
};

BattleManagerTBS.isWaitingForDefeatEvents = function () {
    return false;
};

BattleManagerTBS.updateBattleEnd = function () {
    BattleManager.updateBattleEnd();
    this._phase = null;
};

BattleManagerTBS.onEntityDeath = function (entity) {
    if (this.activeEntity() === entity) {
        this.getLayer("scopes").clear();
        this.getLayer("scopes").clearSelection();
        this.turnEnd();
    }
    this._turnOrderVisual.updateOnEntityDeath(this._turnOrder, this._activeIndex);
};

BattleManagerTBS.onEntityRevive = function (entity) {
    this._turnOrderVisual.updateOnEntityRevive(this._turnOrder, this._activeIndex);
};

BattleManagerTBS.destroyEntity = function (entity) {
    entity.destroy();
    LeUtilities.removeInArray(this._battlerEntities, entity);
    LeUtilities.removeInArray(this._neutralEntities, entity);
};

BattleManagerTBS.makeActionScope = function (entity, data, obj, isFloating) {
    var center = entity.getCell().toCoords();
    var param = this.makeObjScopeParam(obj, entity, center);
    var scope = this.getScopeFromData(data, center, param);
    if (isFloating) {
        return {
            cells: scope,
            center: center
        };
    }
    this._actionScope = {};
    this._actionScope.cells = scope;
    this._actionScope.center = center;
};

BattleManagerTBS.drawActionScope = function (entity) {
    var color = this._actionScopeParam.color;
    var opacity = this._actionScopeParam.opacity;
    var invalidOpa = this._actionScopeParam.invalidOpa;
    var scope = this._actionScope.cells;
    var invalidCondition = "!cell._scopeVisible || (cell.isObstacleForLOS() && !cell.isThereEntity())";
    this.getLayer("scopes").clear();
    this.drawScope(scope, color, opacity, invalidOpa, invalidCondition);
};

BattleManagerTBS.makeObjScopeParam = function (obj, entity, center) {
    obj = obj || this.activeAction().item();
    var param = {
        user: entity,
        dir: entity.getDirectionTo(center),
        need_check_los: true,
        exclude_center: true,
        line_of_sight: true,
        remove_nonvisibleCells: false
    };
    if (!obj) return param;
    var data = obj.leTbs_scopeParam;
    data = LeUtilities.stringSplit(data, ",");
    data.forEach(function (arg) {
        if (arg.match(/include_center/i))
            param.exclude_center = false;
        else if (arg.match(/through_obstacles/i))
            param.line_of_sight = false;
        else if (arg.match(/need_free_cell/i))
            param.need_free_cell = true;
    }.bind(this));
    return param;
};

BattleManagerTBS.makeObjAoEParam = function (obj, entity, center) {
    obj = obj || this.activeAction().item();
    var param = {
        user: entity,
        dir: entity.getDirectionTo(center)
    };
    this._requestSpecialSelection = null;
    if (!obj) return param;
    var data = obj.leTbs_aoeParam;
    data = LeUtilities.stringSplit(data, ",");
    data.forEach(function (arg) {
        if (arg.match(/line_of_sight/i)) {
            this._requestSpecialSelection = {};
            param.need_check_los = true;
            param.line_of_sight = true;
            param.remove_nonvisibleCells = true;
        } else if (arg.match(/exclude_center/i)) {
            param.exclude_center = true;
        } else if (arg.match(/need_free_cell/i)) {
            param.need_free_cell = true;
        }
    }.bind(this));
    return param;
};

BattleManagerTBS.cursorOnActionScope = function () {
    if (!this.isActionScopeAvailable()) return false;
    for (var i = 0; i < this.actionScope().cells.length; i++) {
        var cell = this.actionScope().cells[i];
        if (cell._scopeVisible && !(cell.isObstacle() && !cell.isThereEntity())) {
            if (cell.x == this.cursor().cellX && cell.y == this.cursor().cellY) {
                return true;
            }
        }
    }
    return false;
};

BattleManagerTBS.drawActionSelection = function () {
    this.clearActionSelection();
    var color = this._actionScopeParam.color;
    var scolor = this._actionScopeParam.scolor;
    var opacity;
    var invalidOpa = this._actionScopeParam.invalidOpa;
    if (this._requestSpecialSelection) {
        var aoe = this._requestSpecialSelection.aoe;
        opacity = invalidOpa;
        this.getLayer("scopes").drawSelectionCells(aoe, opacity, color, scolor);
    }
    opacity = this._actionScopeParam.selectedOpacity;
    this.getLayer("scopes").drawSelectionCells(this._actionAoE, opacity, color, scolor);
};

BattleManagerTBS.clearActionSelection = function () {
    this.getLayer("scopes").clearSelection();
};

BattleManagerTBS.getScopeFromData = function (data, center, param, points) {
    var scope = [];
    var str, min, size;

    var e = param.user;
    if (e)
        var a = e.battler();

    if (data.match(/(circle|line|square|cross)\((.+)\)/i)) {
        if (RegExp.$2.includes(",")) {
            str = RegExp.$2.split(",");
            size = Math.floor(Number(eval(str[0])));
            min = Math.floor(Number(eval(str[1])));
        } else {
            size = Math.floor(Number(eval(RegExp.$2)));
        }
    }

    if (data.match(/custom\((.+)\)/i)) {
        var scopeData = Lecode.S_TBS.Config.Custom_Scopes[String(RegExp.$1)];
        scope = this.getScopeFromRawData(scopeData, center, param);
    } else if (data.match(/circle\((.+)\)/i)) {
        scope = this.makeCircleScope(center, size, min, param);
    } else if (data.match(/line\((.+)\)/i)) {
        scope = this.makeLineScope(center, size, min, param);
    } else if (data.match(/square\((.+)\)/i)) {
        scope = this.makeSquareScope(center, size, min, param);
    } else if (data.match(/cross\((.+)\)/i)) {
        scope = this.makeCrossScope(center, size, min, param);
    } else if (data.match(/path/i)) {
        scope = this.makePathScope(param);
    } else {
        var cx = center.x;
        var cy = center.y;
        var aoe = eval("[" + data + "]");
        for (var i = 0; i < aoe.length; i++) {
            var cell = this.getCellAt(aoe[i][0], aoe[i][1]);
            if (cell)
                scope.push(cell);
        }
    }
    scope = LeUtilities.uniqArray(scope);

    if (this._requestSpecialSelection) {
        this._requestSpecialSelection.aoe = scope;
    }

    scope = this.applyParamToScope(scope, center, points, param);
    return scope;
};

BattleManagerTBS.getScopeFromRawData = function (scopeData, center, param) {
    var scope = [];
    var cx = center.x;
    var cy = center.y;
    var ux = this.activeEntity()._cellX;
    var uy = this.activeEntity()._cellY;
    var dir = param.dir;
    var dirData = eval("scopeData.data_" + LeUtilities.directionCodeToText(dir));
    var data = dirData ? dirData : scopeData.data;
    var array = eval("[" + data + "]");
    array.forEach(function (arr) {
        var cell = this.getCellAt(arr[0], arr[1]);
        if (cell)
            scope.push(cell);
    }.bind(this));
    return LeUtilities.uniqArray(scope);
};

BattleManagerTBS.makeCircleScope = function (center, range, min, param) {
    var cells = [];
    var start = param.exclude_center ? 1 : 0;
    var x = center.x,
        y = center.y;
    for (var i = start; i <= range; i++) {
        cells.push(this.getCellAt(x + i, y));
        cells.push(this.getCellAt(x - i, y));
        cells.push(this.getCellAt(x, y + i));
        cells.push(this.getCellAt(x, y - i));
        for (var a = start; a <= range - i; a++) {
            cells.push(this.getCellAt(x - i, y - a));
            cells.push(this.getCellAt(x - i, y + a));
            cells.push(this.getCellAt(x + i, y - a));
            cells.push(this.getCellAt(x + i, y + a));
        }
    }
    if (min) {
        var minCells = this.makeCircleScope(center, min, null, param);
        cells = cells.filter(function (cell) {
            return !this.isCellInScope(cell, minCells);
        }.bind(this));
    }
    return cells;
};

BattleManagerTBS.makeSquareScope = function (center, range, min, param) {
    var cells = [];
    var x = center.x,
        y = center.y;
    for (var i = -range; i <= range; i++) {
        for (var j = -range; j <= range; j++) {
            if (param.exclude_center && i === 0 && j === 0)
                continue;
            cells.push(this.getCellAt(x + i, y + j));
        }
    }
    if (min) {
        var minCells = this.makeSquareScope(center, min, null, param);
        cells = cells.filter(function (cell) {
            return !this.isCellInScope(cell, minCells);
        }.bind(this));
    }
    return cells;
};

BattleManagerTBS.makeLineScope = function (center, range, min, param) {
    var cells = [];
    var start = param.exclude_center ? 1 : 0;
    start = min || start;
    var x = center.x,
        y = center.y;
    for (var i = start; i <= range; i++) {
        cells.push(this.getCellAt(x + i, y));
        cells.push(this.getCellAt(x - i, y));
        cells.push(this.getCellAt(x, y + i));
        cells.push(this.getCellAt(x, y - i));
    }
    if (min) {
        var minCells = this.makeLineScope(center, min, null, param);
        cells = cells.filter(function (cell) {
            return !this.isCellInScope(cell, minCells);
        }.bind(this));
    }
    return cells;
};

BattleManagerTBS.makeCrossScope = function (center, range, param) {
    var cells = [];
    var start = param.exclude_center ? 1 : 0;
    var x = center.x,
        y = center.y;
    for (var i = start; i <= range; i++) {
        cells.push(this.getCellAt(x + i, y + i));
        cells.push(this.getCellAt(x + i, y - i));
        cells.push(this.getCellAt(x - i, y + i));
        cells.push(this.getCellAt(x - i, y - i));
    }
    if (min) {
        var minCells = this.makeCrossScope(center, min, null, param);
        cells = cells.filter(function (cell) {
            return !this.isCellInScope(cell, minCells);
        }.bind(this));
    }
    return cells;
};

BattleManagerTBS.makePathScope = function (param) {
    var sx = param.user.getCell().x;
    var sy = param.user.getCell().y;
    var dx = this._activeCell.x;
    var dy = this._activeCell.y;
    return this.getPathFromAToB(sx, sy, dx, dy, "free");
};

BattleManagerTBS.applyParamToScope = function (cells, center, points, param) {
    cells = this.removeInvalidCells(cells);
    if (!param.can_select_obstacles) {
        if (param.remove_obstacles)
            cells = this.removeObstaclesFromScope(cells);
    }
    if (param.cells_reachable) {
        this.checkScopeWalkable(cells, points, center);
        if (param.remove_unreachableCells)
            cells = this.makeScopeReachable(cells, points, center);
    }
    if (param.need_check_los) {
        cells.forEach(function (cell) {
            cell._scopeVisible = true;
        }.bind(this));
        if (param.line_of_sight) {
            this.checkScopeVisibility(cells, center);
            if (param.remove_nonvisibleCells)
                cells = this.makeScopeVisible(cells, center);
        }
    }
    if (param.need_free_cell) {
        cells = this.removeObstaclesFromScope(cells);
        cells = this.removeEntitiesFromScope(cells);
    }
    return cells;
};

BattleManagerTBS.removeInvalidCells = function (cells) {
    return cells.filter(function (cell) {
        return cell;
    });
};

BattleManagerTBS.removeObstaclesFromScope = function (cells) {
    return cells.filter(function (cell) {
        return !cell.isObstacle();
    });
};

BattleManagerTBS.removeEntitiesFromScope = function (cells) {
    return cells.filter(function (cell) {
        return !cell.isThereEntity();
    });
};

BattleManagerTBS.checkScopeWalkable = function (cells, range, center) {
    for (var i = 0; i < cells.length; i++) {
        cells[i]._walkable = false;
    }

    var grid = this.getWalkableGridForEasyStar();
    this._easystar.setGrid(grid);
    this._easystar.setAcceptableTiles([0]);
    this._easystar.enableSync();

    var scope = cells.sort(function (cella, cellb) {
        var cellaDist = LeUtilities.distanceBetween(cella, center);
        var cellbDist = LeUtilities.distanceBetween(cellb, center);
        return (cellaDist > cellbDist) ? 1 : ((cellaDist < cellbDist) ? -1 : 0);
    });
    scope.reverse();
    var reachables = [];
    for (i = 0; i < scope.length; i++) {
        var cell = scope[i];
        var isReachable = false;
        for (var j = 0; j < reachables.length; j++) {
            var coord = reachables[j];
            if (coord[0] == cell.x && coord[1] == cell.y) {
                isReachable = true;
                break;
            }
        }
        if (isReachable)
            cell._walkable = true;
        else
            cell._walkable = this.isCellReachable(cell, range, center, reachables);
        reachables = LeUtilities.uniqArray(reachables);
    }
};

BattleManagerTBS.makeScopeReachable = function (cells, range, center) {
    return cells.filter(function (cell) {
        return cell._walkable;
    }.bind(this));
};

BattleManagerTBS.isCellReachable = function (cell, range, center, reachables) {
    if (cell.getEntity()) {
        if (!cell.getEntity().entitiesCanLayOnMe())
            return false;
    } else if (cell.isObstacle())
        return false;
    var path = [];
    var pathResult = null;
    var sx = center.x;
    var sy = center.y;
    var dx = cell.x;
    var dy = cell.y;
    this._easystar.findPath(sx, sy, dx, dy, function (result) {
        pathResult = result;
    });
    this._easystar.calculate();
    if (!pathResult)
        return false;
    pathResult.shift();
    if (pathResult.length > range)
        return false;
    return true;
};

BattleManagerTBS.checkScopeVisibility = function (cells, center) {
    var w = $gameMap.tileWidth();
    var h = $gameMap.tileHeight();
    var cx = center.x * w + w / 2;
    var cy = center.y * h + h / 2;
    var obstacles = [];
    var boundaries = this.getScopeBoundaries(cells);
    for (var x = boundaries.left; x <= boundaries.right; x++) {
        for (var y = boundaries.top; y <= boundaries.bottom; y++) {
            var cell = this.getCellAt(x, y);
            if (cell.isObstacleForLOS())
                obstacles.push(cell);
        }
    }
    /*for (var k = 0; k < cells.length; k++) {
    	if (cells[k].isObstacle())
    		obstacles.push(cells[k]);
    }*/
    var nonVisible = [];

    for (var i = 0; i < cells.length; i++) {
        cells[i]._scopeVisible = true;
    }

    for (i = 0; i < obstacles.length; i++) {
        var cellsToCheck = this.cellsToCheckNearObstacle(obstacles[i], cells, center);
        for (var j = 0; j < cellsToCheck.length; j++) {
            var cellToCheck = cellsToCheck[j];
            if (obstacles[i].x == cellToCheck.x && obstacles[i].y == cellToCheck.y)
                continue;
            var dx = cellToCheck.x * w + w / 2;
            var dy = cellToCheck.y * h + h / 2;
            //- var sprite = SceneManager._scene._spriteset._debugLayer;
            var pixels = LeUtilities.getPixelsOfLine(cx, cy, dx, dy);
            for (var k = 0; k < obstacles.length; k++) {
                var obstacle = obstacles[k];
                if (obstacle.x == center.x && obstacle.y == center.y)
                    continue;
                if (obstacle.isSame(cellToCheck))
                    continue;
                var x = obstacle.x * w;
                var y = obstacle.y * h;
                for (var m = 0; m < pixels.length; m++) {
                    if (LeUtilities.doesRectIncludeCoord(x, y, w, h, pixels[m])) {
                        nonVisible.push([cellToCheck.x, cellToCheck.y]);
                        m = pixels.length;
                    }
                }
            }
        }
    }

    for (i = 0; i < nonVisible.length; i++) {
        for (var j = 0; j < cells.length; j++) {
            if (cells[j].x === nonVisible[i][0] && cells[j].y === nonVisible[i][1]) {
                cells[j]._scopeVisible = false;
            }
        }
    }
};

BattleManagerTBS.checkSingleCellVisibility = function (cell, center) {
    var w = $gameMap.tileWidth();
    var h = $gameMap.tileHeight();
    var cx = center.x * w + w / 2;
    var cy = center.y * h + h / 2;

    var obstacles = [];
    var cells = this.getAllCells();
    for (var i = 0; i < cells.length; i++) {
        if (cells[i].isObstacleForLOS())
            obstacles.push(cells[i]);
    }
    cell._scopeVisible = true;

    var dx = cell.x * w + w / 2;
    var dy = cell.y * h + h / 2;
    var pixels = LeUtilities.getPixelsOfLine(cx, cy, dx, dy);
    for (var k = 0; k < obstacles.length; k++) {
        var obstacle = obstacles[k];
        if (obstacle.x === center.x && obstacle.y === center.y)
            continue;
        if (obstacle.isSame(cell))
            continue;
        var x = obstacle.x * w;
        var y = obstacle.y * h;
        for (var m = 0; m < pixels.length; m++) {
            if (LeUtilities.doesRectIncludeCoord(x, y, w, h, pixels[m])) {
                cell._scopeVisible = false;
                return;
            }
        }
    }
};

BattleManagerTBS.cellsToCheckNearObstacle = function (obstacle, cells, center) {
    var cx = center.x,
        cy = center.y;
    var result = [];
    var condition;
    if (obstacle.y > cy && obstacle.x > cx)
        condition = "cell.x >= obstacle.x && cell.y >= obstacle.y";
    else if (obstacle.y > cy && obstacle.x < cx)
        condition = "cell.x <= obstacle.x && cell.y >= obstacle.y";
    else if (obstacle.y < cy && obstacle.x > cx)
        condition = "cell.x >= obstacle.x && cell.y <= obstacle.y";
    else if (obstacle.y < cy && obstacle.x < cx)
        condition = "cell.x <= obstacle.x && cell.y <= obstacle.y";
    else if (obstacle.y == cy && obstacle.x < cx)
        condition = "cell.x <= obstacle.x";
    else if (obstacle.y == cy && obstacle.x > cx)
        condition = "cell.x >= obstacle.x";
    else if (obstacle.x == cx && obstacle.y < cy)
        condition = "cell.y <= obstacle.y";
    else if (obstacle.x == cx && obstacle.y > cy)
        condition = "cell.y >= obstacle.y";
    for (var i = 0; i < cells.length; i++) {
        var cell = cells[i];
        if (eval(condition))
            result.push(cell);
    }
    return result;
};

BattleManagerTBS.makeScopeVisible = function (cells, center) {
    return cells.filter(function (cell) {
        return !!cell._scopeVisible;
    }.bind(this));
};

BattleManagerTBS.getScopeBoundaries = function (cells) {
    var copy = cells.filter(function (cell) {
        return true;
    });
    var cellsByX = copy.sort(function (cellA, cellB) {
        return (cellA.x > cellB.x) ? 1 : ((cellA.x < cellB.x) ? -1 : 0);
    });
    var rightCell = cellsByX.leU_last();
    var leftCell = cellsByX[0];
    var cellsByY = copy.sort(function (cellA, cellB) {
        return (cellA.y > cellB.y) ? 1 : ((cellA.y < cellB.y) ? -1 : 0);
    });
    var bottomCell = cellsByY.leU_last();
    var topCell = cellsByY[0];
    return {
        left: leftCell.x,
        right: rightCell.x,
        top: topCell.y,
        bottom: bottomCell.y
    };
};

BattleManagerTBS.getPathFromAToB = function (sx, sy, dx, dy, gridType, cellsToIgnore) {
    var path = [];
    var pathResult = null;
    var grid;
    if (gridType === "walkable")
        grid = this.getWalkableGridForEasyStar(cellsToIgnore);
    else if (gridType === "free")
        grid = this.getFreeGridForEasyStar();
    else
        grid = this.getGridForEasyStar();
    this._easystar.setGrid(grid);
    this._easystar.setAcceptableTiles([0]);
    this._easystar.enableSync();
    this._easystar.findPath(sx, sy, dx, dy, function (result) {
        pathResult = result;
    });
    this._easystar.calculate();
    if (!pathResult) return [];
    pathResult.shift();
    for (var i = 0; i < pathResult.length; i++) {
        var cellArr = pathResult[i];
        var cell = this.getCellAt(cellArr.x, cellArr.y);
        path.push(cell);
    }
    return path;
};

BattleManagerTBS.getGridForEasyStar = function () {
    var grid = [];
    for (var y = 0; y < $gameMap.height(); y++) {
        var arr = [];
        for (var x = 0; x < $gameMap.width(); x++) {
            var cell = this.getCellAt(x, y);
            if (!cell || cell.isObstacle())
                arr.push(1);
            else
                arr.push(0);
        }
        grid.push(arr);
    }
    return grid;
};

BattleManagerTBS.getFreeGridForEasyStar = function () {
    var grid = [];
    for (var y = 0; y < $gameMap.height(); y++) {
        var arr = [];
        for (var x = 0; x < $gameMap.width(); x++) {
            var cell = this.getCellAt(x, y);
            if (!cell)
                arr.push(1);
            else
                arr.push(0);
        }
        grid.push(arr);
    }
    return grid;
};

BattleManagerTBS.getWalkableGridForEasyStar = function (cellsToIgnore) {
    cellsToIgnore = cellsToIgnore || [];
    var grid = [];
    for (var y = 0; y < $gameMap.height(); y++) {
        var arr = [];
        for (var x = 0; x < $gameMap.width(); x++) {
            var cell = this.getCellAt(x, y);
                var entity = cell.getEntity();
                if (entity) {
                    arr.push(entity.isPassable() ? 0 : 1);
                } else {
                    arr.push(cell.isObstacle() ? 1 : 0);
                }
            } else
                arr.push(1);
        }
        grid.push(arr);
    }
    return grid;
};

BattleManagerTBS.drawScope = function (cells, color, opa, invalidOpa, invalidCondition) {
    for (var i = 0; i < cells.length; i++) {
        var cell = cells[i];
        var opacity;
        if (eval(invalidCondition))
            opacity = invalidOpa;
        else
            opacity = opa;
        this.getLayer("scopes").drawCell(cell.x, cell.y, opacity, color);
    }
};

BattleManagerTBS.isCellInScope = function (cell, scope) {
    for (var i = 0; i < scope.length; i++) {
        if (scope[i].isSame(cell))
            return true;
    }
    return false;
};

BattleManagerTBS.getEntitiesInScope = function (scope) {
    var entities = [];
    for (var i = 0; i < scope.length; i++) {
        var cell = scope[i];
        var entity = cell.getEntity();
        if (entity)
            entities.push(entity);
    }
    return entities;
};

BattleManagerTBS.closestWalkableCellTo = function (cellTarget, scope) {
    return scope.sort(function (a, b) {
        var obj_aPath = this.getPathFromAToB(a.x, a.y, cellTarget.x, cellTarget.y, "walkable", [cellTarget]);
        var obj_bPath = this.getPathFromAToB(b.x, b.y, cellTarget.x, cellTarget.y, "walkable", [cellTarget]);
        var obj_aDist = obj_aPath.length === 0 ? 999 : obj_aPath.length;
        var obj_bDist = obj_bPath.length === 0 ? 999 : obj_bPath.length;
        return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
    }.bind(this))[0];
};

BattleManagerTBS.farthestWalkableCellTo = function (cellTarget, scope) {
    return scope.sort(function (a, b) {
        var obj_aPath = this.getPathFromAToB(a.x, a.y, cellTarget.x, cellTarget.y, "walkable", [cellTarget]);
        var obj_bPath = this.getPathFromAToB(b.x, b.y, cellTarget.x, cellTarget.y, "walkable", [cellTarget]);
        var obj_aDist = obj_aPath.length === 0 ? 999 : obj_aPath.length;
        var obj_bDist = obj_bPath.length === 0 ? 999 : obj_bPath.length;
        return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
    }.bind(this)).pop();
};

BattleManagerTBS.processCollisionEffects = function (entity) {
    var collisionData = entity._collisionData;
    if (!collisionData.endCell) return;

    var distance = collisionData.distance;
    var covered = collisionData.covered;
    var user = collisionData.user;
    var obj = collisionData.obj;
    var a = user.battler();
    var b = entity.battler();
    var formula = Lecode.S_TBS.defaultCollisionFormula;
    if (obj && obj.leTbs_collisionFormula) {
        formula = obj.leTbs_collisionFormula;
    }
    var damage = Math.floor(eval(formula));
    var dmgBonus = user.getCollisionDamageBonus(damage);
    var dmgMinus = entity.getCollisionDamageReduction(damage);
    damage += dmgBonus - dmgMinus;
    if (damage < 0) damage = 0;
    this.applyFloatingDamage(Math.floor(damage), entity);

    var endCell = collisionData.endCell;
    var next = endCell.getEntity();
    while (next) {
        damage -= damage * Lecode.S_TBS.collissionDamageChainRate;
        this.applyFloatingDamage(Math.floor(damage), next);
        var oldDir = next.getDir();
        next.setDir(collisionData.dir);
        endCell = next.getForwardCell();
        next.setDir(oldDir);
        next = endCell.getEntity();
    }
    entity._collisionData = null;
};

BattleManagerTBS.prepareDirectionalDamageBonus = function (user, targets, item) {
    var oldUserDir = user.getDir();
    for (var i = 0; i < targets.length; i++) {
        var entity = targets[i];
        if (entity === user) continue;
        var dir = entity.getDir();
        var effects = 0;
        user.lookAt(entity.getCell());
        if (user.getDir() === dir) {
            effects = Lecode.S_TBS.backDirectionalDamageEffects;
            effects += item.leTbs_directionalDmgBonus.back;
            effects += user.getDirectionalDmgBonus("back");
            effects -= entity.getDirectionalDmgReduction("back");
        } else if (user.getDir() === 2 && dir === 8 || user.getDir() === 8 && dir === 2 ||
            user.getDir() === 4 && dir === 6 || user.getDir() === 6 && dir === 4) {
            effects = Lecode.S_TBS.faceDirectionalDamageEffects;
            effects += item.leTbs_directionalDmgBonus.face;
            effects += user.getDirectionalDmgBonus("face");
            effects -= entity.getDirectionalDmgReduction("face");
        } else {
            effects = Lecode.S_TBS.sideDirectionalDamageEffects;
            effects += item.leTbs_directionalDmgBonus.side;
            effects += user.getDirectionalDmgBonus("side");
            effects -= entity.getDirectionalDmgReduction("side");
        }
        entity.battler().leTBS_setDirectionalDmgEffects(effects * 0.01);
    }
    user.setDir(oldUserDir);
};

BattleManagerTBS.resetDirectionalDamageBonus = function (targets) {
    for (var i = 0; i < targets.length; i++) {
        targets[i].battler().leTBS_setDirectionalDmgEffects(0);
    }
};

BattleManagerTBS.executeEventsByTouch = function (entity) {
    var cell = entity.getForwardCell();
    if (cell) {
        var event = this.getTBSEventAt(cell.x, cell.y);
        if (event && event.canTriggerByTouch()) {
            event.start();
            this._lastTriggeredEventEntity = entity;
            this._lastTriggeredEventBattler = entity.battler();
        }
    }
};

BattleManagerTBS.executeEventsByStep = function (entity) {
    var cell = entity.getCell();
    var event = this.getTBSEventAt(cell.x, cell.y);
    if (event && event.canTriggerByStep()) {
        event.start();
        this._lastTriggeredEventEntity = entity;
        this._lastTriggeredEventBattler = entity.battler();
        return event._stopWhenStepped;
    }
    return false;
};

BattleManagerTBS.executeEventsAtTurnOrderEnd = function () {
    var tbsEvents = this._tbsEvents;
    for (var i = 0; i < tbsEvents.length; i++) {
        var tbsEvent = tbsEvents[i];
        if (tbsEvent.canTriggerAtTurnOrderEnd())
            tbsEvent.start();
    }
};

BattleManagerTBS.executeEventsAtBattleStart = function () {
    var tbsEvents = this._tbsEvents;
    for (var i = 0; i < tbsEvents.length; i++) {
        var tbsEvent = tbsEvents[i];
        if (tbsEvent.canTriggerAtBattleStart())
            tbsEvent.start();
    }
};

BattleManagerTBS.executeEventsAtBattleEnd = function () {
    var tbsEvents = this._tbsEvents;
    for (var i = 0; i < tbsEvents.length; i++) {
        var tbsEvent = tbsEvents[i];
        if (tbsEvent.canTriggerAtBattleEnd())
            tbsEvent.start();
    }
};

BattleManagerTBS.executeEventsByForce = function (id) {
    var tbsEvents = this._tbsEvents;
    for (var i = 0; i < tbsEvents.length; i++) {
        var tbsEvent = tbsEvents[i];
        if (tbsEvent._event.eventId() === id)
            tbsEvent.start();
    }
};


BattleManagerTBS.allyStartCells = function () {
    return this._startCells.filter(function (cell) {
        return cell._positioningData.type === "actor";
    });
};

BattleManagerTBS.enemyStartCells = function () {
    return this._startCells.filter(function (cell) {
        return cell._positioningData.type === "enemy";
    });
};

BattleManagerTBS.allyEntities = function () {
    return this.allPlayableEntities().filter(function (ent) {
        return ent._battler.isActor();
    });
};

BattleManagerTBS.enemyEntities = function () {
    return this.allPlayableEntities().filter(function (ent) {
        return !ent._battler.isActor();
    });
};

BattleManagerTBS.isCellFree = function (cell) {
    if (cell == null) return true;
    return cell.getEntity() == null;
};

BattleManagerTBS.getCellAt = function (x, y) {
    if (this._groundCells[x])
        return this._groundCells[x][y];
    return null;
};

BattleManagerTBS.getAllCells = function () {
    var cells = [];
    for (var i = 0; i < $gameMap.width(); i++) {
        for (var j = 0; j < $gameMap.height(); j++) {
            cells.push(this._groundCells[i][j]);
        }
    }
    return cells;
};

BattleManagerTBS.getEntityAt = function (x, y) {
    var cell = this.getCellAt(x, y);
    if (cell)
        return cell.getEntity();
    return null;
};

BattleManagerTBS.getEntitiesXY = function (excludeActive) {
    var arr = [];
    if (!this.allEntities()) return arr;
    for (var i = 0; i < this.allEntities().length; i++) {
        var entity = this.allEntities()[i];
        if (!(excludeActive && entity == this.activeEntity()))
            arr.push([entity._cellX, entity._cellY]);
    }
    return arr;
};

BattleManagerTBS.battlerEntities = function () {
    return this.allEntities();
};

BattleManagerTBS.getEntityByBattler = function (battler) {
    var entities = this.allEntities();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity.battler() === battler)
            return entity;
    }
};

BattleManagerTBS.getEntitiesWithEnemyId = function (enemyId) {
    var result = [];
    var entities = this.enemyEntities();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity.battler().enemyId() === enemyId)
            result.push(entity);
    }
    return result;
};

BattleManagerTBS.getEntityWithActorId = function (actorId) {
    var entities = this.allyEntities();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity.battler().actorId() === actorId)
            return entity;
    }
    return null;
};

BattleManagerTBS.getFlaggedEntity = function (flagId) {
    var entities = this.allEntities();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity._flag === flagId)
            return entity;
    }
    return null;
};

BattleManagerTBS.getCellAwayParty = function (scope, party) {
    var results = [];
    for (var j = 0; j < scope.length; j++) {
        var cell = scope[j];
        var data = {
            dist: 0,
            cell: cell
        };
        for (var i = 0; i < party.length; i++) {
            var entity = party[i];
            var dist = LeUtilities.distanceBetweenCells(cell, entity.getCell());
            data.dist += dist;
        }
        results.push(data);
    }
    return LeUtilities.getMaxInArrayBy(results, "dist").cell;
};

BattleManagerTBS.getCellTowardParty = function (scope, party) {
    var results = [];
    for (var j = 0; j < scope.length; j++) {
        var cell = scope[j];
        var data = {
            dist: 0,
            cell: cell
        };
        for (var i = 0; i < party.length; i++) {
            var entity = party[i];
            var dist = LeUtilities.distanceBetweenCells(cell, entity.getCell());
            data.dist += dist;
        }
        results.push(data);
    }
    return LeUtilities.getMinInArrayBy(results, "dist").cell;
};

BattleManagerTBS.centerActiveCell = function () {
    this.centerCell(this._activeCell);
};

BattleManagerTBS.centerCell = function (cell) {
    $gamePlayer.center(cell.x, cell.y);
};

BattleManagerTBS.scrollRight = function (distance) {
    var oldX = $gameMap._displayX;
    var oldY = $gameMap._displayY;
    var oldPX = $gameMap._parallaxX;
    var oldPY = $gameMap._parallaxY;
    $gameMap.setDisplayPos(oldX + distance, oldY);
};

BattleManagerTBS.scrollDown = function (distance) {
    var oldX = $gameMap._displayX;
    var oldY = $gameMap._displayY;
    var oldPX = $gameMap._parallaxX;
    var oldPY = $gameMap._parallaxY;
    $gameMap.setDisplayPos(oldX, oldY + distance);
};

BattleManagerTBS.scrollLeft = function (distance) {
    this.scrollRight(-distance);
};

BattleManagerTBS.scrollUp = function (distance) {
    this.scrollDown(-distance);
};
/*
BattleManagerTBS.adaptLayersPos = function () {
    this.movableLayers().forEach(function (layer) {
        layer.x = -$gameMap._displayX * $gameMap.tileWidth();
        layer.y = -$gameMap._displayY * $gameMap.tileHeight();
    });
};

BattleManagerTBS.adaptMapVisuals = function (oldX, oldY, oldPX, oldPY) {
    var diffX = oldX - $gameMap._displayX;
    var diffY = oldY - $gameMap._displayY;
    this.mapVisuals().forEach(function (visual) {
        visual.x += diffX * $gameMap.tileWidth();
        visual.y += diffY * $gameMap.tileHeight();
    });
    $gameMap._parallaxX = oldPX;
    $gameMap._parallaxY = oldPY;
};
*/
BattleManagerTBS.movableLayers = function () {
    return [this.getLayer("scopes"), this.getLayer("ground"), this.getLayer("groundEntities"),
    this.getLayer("battlers"), this.getLayer("animations"), this.getLayer("movableInfo")
    ];
};

BattleManagerTBS.mapVisuals = function () {
    var scene = LeUtilities.getScene();
    return [scene._windowPositioningInfo, scene._windowCommand, scene._windowSkill, scene._windowItem];
};


/*-------------------------------------------------------------------------
* AI Manager
-------------------------------------------------------------------------*/
function TBSAiManager() {
    this.initialize.call(this, arguments);
}

TBSAiManager.prototype.initialize = function () {
    this._entity = null;
    this._battler = null;
    this._commandRunning = null;
    this._ifArray = [];
    this._targetData = null;
    this._cellTarget = null;
    this._failureCode = "";
    this._constructionDelay = 0;
};

TBSAiManager.prototype.process = function (entity) {
    this._entity = entity;
    this._battler = entity._battler;
    this._phase = 0;
    this._commands = this.getBehavior().slice();
    this._commandRunning = null;
    this._commandNextPhaseCallBack = null;
    this._commandExtraData = {};
    this._actionBuilding = {};
    this._actionData = null;
    this._actionDataType = null;
    this._builtData = {};
    this._isBuilding = true;
    this._builtData["offense"] = null;
    this._builtData["healing"] = null;
    this._builtData["support"] = null;
    this._builtData["move"] = null;
    this._builtData["summon"] = null;
    this._commandPhase = "init";
    this.makeOffenseData();
    this.makeHealingData();
    this.makeSupportData();
    this.makeMoveData();
    this.makeSummonData();
    this.updateEscapeCooldown();
    this.updateSupportCooldown();
};

TBSAiManager.prototype.updateEscapeCooldown = function () {
    if (!this._entity._aiEscapeCount)
        this._entity._aiEscapeCount = 0;
    if (this._entity._aiEscapeCount > 0)
        this._entity._aiEscapeCount--;
};

TBSAiManager.prototype.updateSupportCooldown = function () {
    if (!this._entity._aiSupportCount)
        this._entity._aiSupportCount = 0;
    if (this._entity._aiSupportCount > 0)
        this._entity._aiSupportCount--;
};

TBSAiManager.prototype.makeOffenseData = function () {
    var party = this.getEnemiesOf(this._battler, true);
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (!this._entity.rpgObject().leTbs_aiNoAttack && skill.id === this._battler.attackSkillId() || skill.leTbs_aiConfig.type.match("offense")) {
            objects.push(skill);
        }
    }
    this.makeActionData("offense", party, objects);
};

TBSAiManager.prototype.makeHealingData = function () {
    var party = this.getAlliesOf(this._battler, false);
    party.push(this._entity);
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (skill.leTbs_aiConfig.type.match("healing")) {
            objects.push(skill);
        }
    }
    this.makeActionData("healing", party, objects);
};

TBSAiManager.prototype.makeSupportData = function () {
    var party = this.getAlliesOf(this._battler, false);
    party.push(this._entity);
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (skill.leTbs_aiConfig.type.match("support")) {
            objects.push(skill);
        }
    }
    this.makeActionData("support", party, objects);
};

TBSAiManager.prototype.makeMoveData = function () {
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (skill.leTbs_aiConfig.type.match("move")) {
            objects.push(skill);
        }
    }
    this.makeActionData("move", [], objects);
};

TBSAiManager.prototype.makeSummonData = function () {
    var skills = this.getUsableSkills(this._battler);
    var objects = [];
    for (var i = 0; i < skills.length; i++) {
        var skill = skills[i];
        if (skill.leTbs_aiConfig.type.match("summon")) {
            objects.push(skill);
        }
    }
    this.makeActionData("summon", [], objects);
};

TBSAiManager.prototype.updateOffenseActionsBuilding = function () {
    this.updateActionsBuilding("offense", "nbrEnemies");
};

TBSAiManager.prototype.updateHealingActionsBuilding = function () {
    this.updateActionsBuilding("healing", "nbrAllies");
};

TBSAiManager.prototype.updateSupportActionsBuilding = function () {
    this.updateActionsBuilding("support", "nbrAllies");
};

TBSAiManager.prototype.updateMoveActionsBuilding = function () {
    this.updateMoveActionsBuilding();
};

TBSAiManager.prototype.updateSummonActionsBuilding = function () {
    this.updateSummonActionsBuilding();
};

TBSAiManager.prototype.makeActionData = function (type, party, skills) {
    this._actionBuilding[type] = {};
    this._actionBuilding[type].objects = skills;
    this._actionBuilding[type].data = [];
    var entity = this._entity;

    this._actionBuilding[type].party = party.sort(function (enta, entb) {
        var cellaDist = LeUtilities.distanceBetween(enta, entity);
        var cellbDist = LeUtilities.distanceBetween(entb, entity);
        return (cellaDist > cellbDist) ? 1 : ((cellaDist < cellbDist) ? -1 : 0);
    });
};

TBSAiManager.prototype.updateMoveActionsBuilding = function () {
    var object = this._actionBuilding["move"].objects.shift();
    var user = this._battler;
    var enemies = this.getEnemiesOf(user, false);
    var allies = this.getEnemiesOf(user, false);
    var entity = this._entity;
    var center = entity.getCell().toCoords();
    var a = entity.battler();

    if (!object) {
        this._builtData["move"] = this._actionBuilding["move"].data;
        return;
    }

    var data = object.id === user.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(object);
    var param = this.BM().makeObjScopeParam(object, entity, center);
    var scope = this.BM().getScopeFromData(data, center, param).filter(function (cell) {
        return cell._scopeVisible;
    });
    var closestCellToEnemy = BattleManagerTBS.getCellTowardParty(scope, this.getEnemiesOf(this._battler, true));
    var farthestCellToEnemy = BattleManagerTBS.getCellAwayParty(scope, this.getEnemiesOf(this._battler, true));

    var action = {};
    action.type = "move";
    action.cellToMoveTo = entity.getCell();
    action.userCell = entity.getCell();
    action.cellTarget = null;
    action.obj = object;
    action.targets = [];
    action.nbrTargets = 0;
    var a = entity.battler();
    if (eval(object.leTbs_aiConfig.escape_condition)) {
        action.escapeCellTarget = farthestCellToEnemy;
        action.escapeDistance = LeUtilities.distanceBetween(center, farthestCellToEnemy);
    } else {
        action.escapeCellTarget = null;
        action.escapeDistance = 0;
    }
    if (eval(object.leTbs_aiConfig.rush_condition)) {
        action.rushCellTarget = closestCellToEnemy;
        action.rushDistance = LeUtilities.distanceBetween(center, closestCellToEnemy);
    } else {
        action.rushCellTarget = null;
        action.rushDistance = 0;
    }
    this._actionBuilding["move"].data.push(action);
};

TBSAiManager.prototype.updateSummonActionsBuilding = function () {
    var object = this._actionBuilding["summon"].objects.shift();
    var user = this._battler;
    var enemies = this.getEnemiesOf(user, false);
    var allies = this.getEnemiesOf(user, false);
    var entity = this._entity;
    var center = entity.getCell().toCoords();
    var a = entity.battler();

    if (!object) {
        this._builtData["summon"] = this._actionBuilding["summon"].data;
        return;
    }

    var data = object.id === user.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(object);
    var param = this.BM().makeObjScopeParam(object, entity, center);
    var scope = this.BM().getScopeFromData(data, center, param).filter(function (cell) {
        return cell._scopeVisible;
    });
    var closestCellToEnemy = BattleManagerTBS.getCellTowardParty(scope, this.getEnemiesOf(this._battler, true));
    var closestCellToAlly = BattleManagerTBS.getCellTowardParty(scope, this.getAlliesOf(this._battler, true));
    var closestCellToCaster = BattleManagerTBS.getCellTowardParty(scope, [entity]);

    var action = {};
    action.type = "summon";
    action.cellToMoveTo = entity.getCell();
    action.userCell = entity.getCell();
    action.obj = object;
    action.targets = [];
    action.nbrTargets = 0;
    var summonNear = object.leTbs_aiConfig.summon_near;
    switch (summonNear) {
        case "caster":
            action.cellTarget = closestCellToCaster;
            break;
        case "enemies":
            action.cellTarget = closestCellToEnemy;
            break;
        case "allies":
            action.cellTarget = closestCellToAlly;
            break;
    }
    this._actionBuilding["summon"].data.push(action);
};

TBSAiManager.prototype.updateActionsBuilding = function (type, nbrMembers) {
    var object = this._actionBuilding[type].objects.shift();
    var party = this._actionBuilding[type].party;
    var entity = this._entity;
    var center = entity.getCell().toCoords();
    var a = entity.battler();
    var opNbrMembers = nbrMembers === "nbrEnemies" ? "nbrAllies" : "nbrEnemies";

    if (!object) {
        this._builtData[type] = this._actionBuilding[type].data;
        return;
    }

    //- Handle AOEs
    if (object.leTbs_aiConfig.maximise_targets) {
        var possibilities = this.getAoEPossibleMoves(entity, object, center)
            .sort(function (p1, p2) {
                return (p1[nbrMembers] > p2[nbrMembers]) ? -1 : ((p1[nbrMembers] < p2[nbrMembers]) ? 1 : 0);
            });
        if (possibilities.length === 0) return;
        //- If the best move sorted by number of members has only one member,
        //- discard the possibilities where an ally is also targeted (it won't make sens otherwise)
        //- OR simply avoid friendly fire based on the config %
        if (type === "offense" && possibilities[0][nbrMembers] === 1
            || Math.random() < object.leTbs_aiConfig.avoid_friendly_fire) {
            possibilities = possibilities.filter(function (p) {
                return p[opNbrMembers] === 0;
            });
            if (possibilities.length === 0) return;
        }
        //- Keep possibilities with best nbr of members
        var best = possibilities[0][nbrMembers];
        possibilities = possibilities.filter(function (p) {
            return p[nbrMembers] === best;
        });
        //- Sort by average hpRate of the targets in the AOE
        if (possibilities.length > 1) {
            possibilities = possibilities.sort(function (p1, p2) {
                var avgHpRate1 = LeUtilities.avgOfArray(
                    p1.targets.map(function (ent) {
                        return ent.battler().hpRate();
                    }.bind(this))
                );
                var avgHpRate2 = LeUtilities.avgOfArray(
                    p2.targets.map(function (ent) {
                        return ent.battler().hpRate();
                    }.bind(this))
                );
                return avgHpRate1 - avgHpRate2;
            }.bind(this));
        }
        //- Keep possibilities with lowest hpRate
        best = LeUtilities.avgOfArray(
            possibilities[0].targets.map(function (ent) {
                return ent.battler().hpRate();
            }.bind(this))
        );
        possibilities = possibilities.filter(function (p) {
            var avgHpRate = LeUtilities.avgOfArray(
                p.targets.map(function (ent) {
                    return ent.battler().hpRate();
                }.bind(this))
            );
            return avgHpRate === best;
        }.bind(this));
        //- Sort by lowest requiredMp
        possibilities = possibilities.sort(function (p1, p2) {
            var req1 = LeUtilities.distanceBetweenCells(entity.getCell(), p1.moveCell);
            var req2 = LeUtilities.distanceBetweenCells(entity.getCell(), p2.moveCell);
            return req1 - req2;
        }.bind(this));

        //- Keep possibilities where at least one target matches the use condition
        possibilities = possibilities.filter(function (p) {
            for (var i = 0; i < p.targets.length; i++) {
                var target = p.targets[i];
                var b = target.battler();
                if (eval(object.leTbs_aiConfig.use_condition))
                    return true;
            }
        });

        var move = possibilities[0];
        if (!move) return;
        var action = {};
        action.type = type;
        action.requiredMp = LeUtilities.distanceBetweenCells(entity.getCell(), move.moveCell);
        action.cellToMoveTo = move.moveCell;
        action.cellTarget = move.actionCell;
        action.userCell = entity.getCell();
        action.obj = object;
        action.targets = move.targets;
        action.nbrTargets = move[nbrMembers];
        this._actionBuilding[type].data.push(action);
    }
    //- If maximising targets isn't required (faster)
    else {
        for (var i = 0; i < party.length; i++) {
            var member = party[i];
            var b = member.battler();
            if (eval(object.leTbs_aiConfig.use_condition)) {
                var cellToMoveTo = this.getCellToMoveToForAction(entity, member.getCell(), object, center);
                if (cellToMoveTo) {
                    var action = {};
                    action.type = type;
                    action.requiredMp = LeUtilities.distanceBetweenCells(entity.getCell(), cellToMoveTo);
                    action.cellToMoveTo = cellToMoveTo;
                    action.cellTarget = member.getCell();
                    action.userCell = entity.getCell();
                    action.obj = object;
                    action.targets = [member];
                    action.nbrTargets = 1;
                    this._actionBuilding[type].data.push(action);
                }
            }
        }
    }
};

TBSAiManager.prototype.getClosestActionCellToTarget = function (cellTarget, obj, center) {
    var entity = this._entity;
    var data = obj.id === entity._battler.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(obj);
    var param = this.BM().makeObjScopeParam(obj, entity, center);
    var scope = this.BM().getScopeFromData(data, center, param);
    if (this.BM().isCellInScope(cellTarget, scope)) {
        return scope.filter(function (cell) {
            return cell.isSame(cellTarget);
        })[0];
    }
    var closestCell = LeUtilities.closestByDistance(cellTarget, scope);
    var oldActiveCell = BattleManagerTBS._activeCell;
    BattleManagerTBS._activeCell = closestCell; //- Support path scope

    var aoeData = obj.id === entity._battler.attackSkillId() ? entity.getAttackAoEData() : entity.getObjectAoEData(obj);
    var aoeCenter = closestCell.toCoords();
    param = this.BM().makeObjAoEParam(obj, entity, aoeCenter);
    var aoe = this.BM().getScopeFromData(aoeData, aoeCenter, param);
    var closestCellInAoE = LeUtilities.closestByDistance(cellTarget, aoe);
    BattleManagerTBS._activeCell = oldActiveCell;
    return closestCellInAoE;
};

TBSAiManager.prototype.getCellToMoveToForAction = function (entity, targetCell, obj, center) {
    var movePoints = entity.getMovePoints();
    var moveParam = this.BM().makeMoveScopeParam(entity);
    var moveData = entity.getMoveScopeData();
    var scope = this.BM().getScopeFromData(moveData, center, moveParam, movePoints);

    var closestCell = this.getClosestActionCellToTarget(targetCell, obj, entity.getCell());
    var exactDistance = LeUtilities.distanceBetweenCells(closestCell, targetCell);

    scope = scope.filter(function (cell) {
        return cell._walkable && LeUtilities.distanceBetweenCells(cell, entity.getCell()) === exactDistance;
    }.bind(this));

    //- Sort by closest cell to the user
    var cellsToCheck = scope.sort(function (a, b) {
        var obj_aDist = LeUtilities.distanceBetweenCells(a, entity.getCell());
        var obj_bDist = LeUtilities.distanceBetweenCells(b, entity.getCell());
        return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
    }.bind(this));

    //- Add entity's current cell
    cellsToCheck = [entity.getCell()].concat(cellsToCheck);

    var cellToMoveTo = null;
    while (cellsToCheck.length > 0) {
        var cell = cellsToCheck.shift();
        var currentCenter = cell.toCoords();
        var oldCell = entity.getCell();
        entity.setCell(cell);
        //- This call sets the los BTW
        closestCell = this.getClosestActionCellToTarget(targetCell, obj, currentCenter);
        entity.setCell(oldCell);
        if (closestCell.isSame(targetCell) && closestCell._scopeVisible) {
            cellToMoveTo = cell;
            break;
        }
    }
    return cellToMoveTo;
};

TBSAiManager.prototype.getAoEPossibleMoves = function (entity, obj, center) {
    var possibilities = [];
    var scope = this.BM().makeMoveScope(entity, true).cells;
    scope = scope.filter(function (cell) {
        return cell._walkable;
    }.bind(this));
    var moveScope = [entity.getCell()].concat(scope);

    while (moveScope.length > 0) {
        var moveCell = moveScope.shift();
        var currentCenter = moveCell.toCoords();
        var oldCell = entity.getCell();
        entity.setCell(moveCell);

        var data = obj.id === entity._battler.attackSkillId() ? entity.getAttackScopeData() : entity.getObjectScopeData(obj);
        var actionScope = this.BM().makeActionScope(entity, data, obj, true)
            .cells
            .filter(function (cell) {
                return !(!cell._scopeVisible || (cell.isObstacleForLOS() && !cell.isThereEntity()));
            });
        while (actionScope.length > 0) {
            var actionCell = actionScope.shift();
            var aoeData = obj.id === entity._battler.attackSkillId() ? entity.getAttackAoEData() : entity.getObjectAoEData(obj);
            var aoeCenter = actionCell.toCoords();
            var param = this.BM().makeObjAoEParam(obj, entity, aoeCenter);
            var aoe = this.BM().getScopeFromData(aoeData, aoeCenter, param);
            var entities = this.BM().getEntitiesInScope(aoe).filter(function (ent) {
                var b = ent.battler();
                var e = ent;
                return eval(obj.leTbs_aiConfig.use_condition);
            });
            var nbrAllies = entities.filter(function (ent) {
                return this.isAlly(ent.battler());
            }.bind(this)).length;
            var nbrEnemies = entities.filter(function (ent) {
                return this.isEnemy(ent.battler());
            }.bind(this)).length;
            if (nbrAllies > 0 || nbrEnemies > 0) {
                possibilities.push({
                    moveCell: moveCell,
                    actionCell: actionCell,
                    nbrAllies: nbrAllies,
                    nbrEnemies: nbrEnemies,
                    targets: entities
                });
            }
        }
        entity.setCell(oldCell);
    }
    return possibilities;
};

TBSAiManager.prototype.getBehavior = function () {
    return Lecode.S_TBS.Config.AI["default"];
};

TBSAiManager.prototype.currentCommand = function () {
    return this._commands[this._phase];
};

TBSAiManager.prototype.nextCommand = function () {
    this._phase++;
    this._commandRunning = null;
    this._commandPhase = "init";
    this._commandNextPhaseCallBack = null;
    this._commandExtraData = {};
};

TBSAiManager.prototype.areConditionsOkay = function () {
    if (this._ifArray.length === 0) return true;
    for (var i = 0; i < this._ifArray.length; i++) {
        if (!this._ifArray[i]) return false;
    }
    return true;
};

TBSAiManager.prototype.update = function () {
    if (this._isBuilding && this.updateActionConstruction())
        return;
    if (this._commandRunning) {
        this.updateRunningCommand();
        return;
    }
    var command = this.currentCommand();
    if (command) {
        this.runCommand(command);
    } else
        this.forceEnd();
};

TBSAiManager.prototype.updateActionConstruction = function () {
    if (this._constructionDelay < Lecode.S_TBS.aiProcessDelay) {
        this._constructionDelay++;
        return true;
    }
    this._constructionDelay = 0;
    if (!this._builtData["offense"]) {
        this.updateOffenseActionsBuilding();
        return true;
    } else if (!this._builtData["healing"]) {
        this.updateHealingActionsBuilding();
        return true;
    } else if (!this._builtData["support"]) {
        this.updateSupportActionsBuilding();
        return true;
    } else if (!this._builtData["move"]) {
        this.updateMoveActionsBuilding();
        return true;
    } else if (!this._builtData["summon"]) {
        this.updateSummonActionsBuilding();
        return true;
    }
    this._isBuilding = false;
    return false;
};

TBSAiManager.prototype.forceEnd = function () {
    this.BM().processCommandPass();
};

TBSAiManager.prototype.runCommand = function (command) {
    if (command === "else") {
        this.commandElse();
        this.nextCommand();
        return;
    } else if (command === "endif") {
        this.commandEndIf();
        this.nextCommand();
        return;
    } else if (command === "process_behaviors") {
        this.processBehaviors();
        this.nextCommand();
        return;
    }

    if (!command.match(/(.+)\s?:\s?(.+)/i)) {
        this.nextCommand();
        return;
    }

    var main = String(RegExp.$1).trim();
    var paramStr = String(RegExp.$2).trim();
    var param = LeUtilities.stringSplit(paramStr, ",");
    param.forEach(function (p) {
        p = p.trim().replace(" ", "");
    }.bind(this));

    if (main === "if") {
        this.commandIf(paramStr);
        this.nextCommand();
        return;
    }

    if (this.areConditionsOkay()) {
        var functionName = LeUtilities.shrinkTextWithUnderscores(main);
        var func = eval("this.command" + functionName + ".bind(this,param)");
        func();
        this._commandRunning = main;
    } else {
        this.nextCommand();
    }
};

TBSAiManager.prototype.commandIf = function (condition) {
    var user = this._battler;
    var entity = this._entity;
    var canUseOffense = this.func_CanUseOffense.bind(this);
    var canUseHealing = this.func_CanUseHealing.bind(this);
    var canUseSupport = this.func_CanUseSupport.bind(this);
    var canUseEscape = this.func_CanUseEscape.bind(this);
    var canUseRush = this.func_CanUseRush.bind(this);
    var isTargetValid = this.func_IsTargetValid.bind(this);
    var chance = this.func_Chance.bind(this);
    var failureCode = this.func_FailureCode.bind(this);
    var battlerInRange = this.func_BattlerInRange.bind(this);
    var distanceBetween = this.func_DistanceBetween.bind(this);
    var distanceToEnemies = this.func_DistanceToEnemies.bind(this);
    var distanceToAllies = this.func_DistanceToAllies.bind(this);
    var isInMeleeWith = this.func_IsInMeleeWith.bind(this);
    var isInMelee = this.func_IsInMelee.bind(this);
    var pattern = function (str) {
        return this.func_GetPattern() === str;
    }.bind(this);
    var result = eval(condition);
    this._ifArray.push(result);
};

TBSAiManager.prototype.commandElse = function () {
    this._ifArray[this._ifArray.length - 1] = !this._ifArray.leU_last();
};

TBSAiManager.prototype.commandEndIf = function () {
    this._ifArray.pop();
};

TBSAiManager.prototype.processBehaviors = function () {
    if (!this._battler.canMove()) {
        return;
    }

    if (this._battler.isConfused()) {
        if (this.func_CanUseOffense())
            this.commandCallBehavior(["use_offense"]);
        return;
    }

    var order = Lecode.S_TBS.Config.AI.BehaviorsOrder;
    for (var i = 0; i < order.length; i++) {
        var tag = order[i];
        if (tag === "healing" && this.func_CanUseHealing()) {
            this.commandCallBehavior(["use_healing"]);
            break;
        } else if (tag === "escape" && this.func_CanUseEscape()) {
            this._entity._aiEscapeCount = Lecode.S_TBS.escapeCooldown + 1;
            this.commandCallBehavior(["escape"]);
            break;
        } else if (tag === "summon" && this.func_CanUseSummon()) {
            this._entity._aiSupportCount = Lecode.S_TBS.supportCooldown + 1;
            this.commandCallBehavior(["use_summon"]);
            break;
        } else if (tag === "support" && this.func_CanUseSupport()) {
            this.commandCallBehavior(["use_support"]);
            break;
        } else if (tag === "offense") {
            if (this.func_CanUseOffense())
                this.commandCallBehavior(["use_offense"]);
            else
                this.commandCallBehavior(["cant_use_offense"]);
            break;
        }
    }
};

TBSAiManager.prototype.commandWait = function (param) {
    var value = Number(param[0]);
    this.BM().wait(value);
};

TBSAiManager.prototype.commandCallBehavior = function (param) {
    var id = param[0].trim();
    var commands = Lecode.S_TBS.Config.AI[id].slice();
    commands.reverse();
    for (var i = 0; i < commands.length; i++) {
        this._commands.splice(this._phase + 1, 0, commands[i]);
    }
};

TBSAiManager.prototype.commandSetActionData = function (param) {
    var id = param[0].trim();
    this._actionDataType = this._builtData[id];
};

TBSAiManager.prototype.commandSearchTarget = function (param) {
    var search = param[0];
    var maxPm = param[1];
    var dataScope = param[2];
    this.commandSetActionData([dataScope]);

    if (maxPm.match(/(.+)%/i))
        maxPm = Number(RegExp.$1) * 0.01 * this._entity.getMovePoints();
    else
        maxPm = Number(maxPm);
    maxPm = Math.floor(maxPm);
    if (LeUtilities.isNumeric(maxPm)) {
        maxPm = Math.floor(maxPm);
        if (maxPm < 1)
            maxPm = 1;
        if (maxPm > this._entity.getMovePoints())
            maxPm = this._entity.getMovePoints();
    }

    var group = this.getGroupFromActionData(maxPm);

    var focusedEntities = this.getFocusedEntities(group, dataScope);
    if (focusedEntities.length > 0) {
        var entity = focusedEntities[0];
        this._targetData = {};
        this._targetData.entity = entity;
        return;
    }

    if (search.match(/self/i)) {
        group = group.filter(function (entity) {
            return entity === this._entity;
        });
    } else if (search.match(/enemy/i)) {
        group = group.filter(function (entity) {
            return this.isEnemy(entity.battler());
        }.bind(this));
    } else if (search.match(/ally/i)) {
        group = group.filter(function (entity) {
            return this.isAlly(entity.battler());
        }.bind(this));
    }

    if (search.match(/lowest/i)) {
        group = group.sort(function (a, b) {
            a = a._battler;
            b = b._battler;
            return (a.hpRate() > b.hpRate()) ? 1 : ((a.hpRate() < b.hpRate()) ? -1 : 0);
        });
    } else if (search.match(/closest/i)) {
        group = group.sort(function (a, b) {
            var obj_aDist = LeUtilities.distanceBetween(a, this._entity);
            var obj_bDist = LeUtilities.distanceBetween(b, this._entity);
            return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
        }.bind(this));
    }

    this._targetData = null;
    if (!group || group.length === 0)
        return;

    //- Group is sorted so group[0] is the best match
    this._targetData = {};
    this._targetData.entity = group[0];
};

TBSAiManager.prototype.commandDrawMoveScope = function (param) {
    this.BM().drawMoveScope(this._entity);
};

TBSAiManager.prototype.commandMove = function (param) {
    var search = param[0];
    var maxPm = param[1];

    if (!this._entity.canMoveCommand()) return;

    if (maxPm.match(/(.+)%/i))
        maxPm = Number(RegExp.$1) * 0.01 * this._entity.getMovePoints();
    else if (maxPm.match(/minimum/i))
        maxPm = this._actionData.requiredMp; //"minimum";
    else
        maxPm = Number(maxPm);
    if (LeUtilities.isNumeric(maxPm)) {
        maxPm = Math.floor(maxPm);
        if (maxPm < 1)
            maxPm = 1;
        if (maxPm > this._entity.getMovePoints())
            maxPm = this._entity.getMovePoints();
    }

    if (Lecode.S_TBS.showScopes) {
        this.commandDrawMoveScope();
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    } else {
        this.BM().makeMoveScope(this._entity);
    }

    this._commandPhase = "move_scope_wait";
    this._commandNextPhaseCallBack = this.commandMoveP2.bind(this, param, search, maxPm);
};

TBSAiManager.prototype.commandMoveP2 = function (param, search, maxPm) {
    var cellTarget;
    var focusedEntities;
    if (search.match(/toward_target/i))
        cellTarget = this._targetData.cellTarget; //- TODO: WRONG
    else if (search.match(/enemies/i)) {
        focusedEntities = this.getFocusedEntities(this.getEnemiesOf(this._battler, true), "offense");
        if (search.match(/toward/i) && focusedEntities.length > 0)
            cellTarget = focusedEntities[0].getCell();
        else
            cellTarget = LeUtilities.closestByDistance(this._entity, this.getEnemiesOf(this._battler, true)).getCell();
    } else if (search.match(/allies/i)) {
        focusedEntities = this.getFocusedEntities(this.getEnemiesOf(this._battler, true), "healing");
        if (focusedEntities.length === 0)
            focusedEntities = this.getFocusedEntities(this.getEnemiesOf(this._battler, true), "support");
        if (search.match(/toward/i) && focusedEntities.length > 0)
            cellTarget = focusedEntities[0].getCell();
        else
            cellTarget = LeUtilities.closestByDistance(this._entity, this.getAlliesOf(this._battler, true)).getCell();
    }

    /*if (maxPm === "minimum") {
        maxPm = this._actionData.requiredMp;
    }*/

    var scope = this.BM().moveScope().cells;
    scope = scope.filter(function (cell) {
        return cell._walkable && LeUtilities.distanceBetweenCells(cell, this._entity.getCell()) <= maxPm;
    }.bind(this));

    var destCell;
    if (search.match(/toward/i))
        destCell = this.BM().closestWalkableCellTo(cellTarget, scope);
    else
        destCell = this.BM().farthestWalkableCellTo(cellTarget, scope);

    this.BM().setCursorCell(destCell);
    if (!this.BM().movePath() || this.BM().movePath().length === 0) {
        this.nextCommand();
        return;
    }

    if (Lecode.S_TBS.showScopes) {
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    }

    this._commandPhase = "move_selection_wait";
    this._commandNextPhaseCallBack = this.commandMoveP3.bind(this);
    this._commandExtraData.destCell = destCell;
    this._commandExtraData.savedParams = param.slice();
};

TBSAiManager.prototype.commandMoveP3 = function () {
    this._entity.processMovement(this.BM().movePath());
    this._commandPhase = "moving";
};

TBSAiManager.prototype.commandMoveForAction = function (param) {
    var cellToMoveTo = this._actionData.cellToMoveTo;
    if (cellToMoveTo.isSame(this._entity.getCell())) {
        return;
    }

    if (Lecode.S_TBS.showScopes) {
        this.commandDrawMoveScope();
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    } else {
        this.BM().makeMoveScope(this._entity);
    }

    this._commandPhase = "move_scope_wait";
    this._commandNextPhaseCallBack = this.commandMoveForActionP2.bind(this, param);
};

TBSAiManager.prototype.commandMoveForActionP2 = function (param) {
    var cellToMoveTo = this._actionData.cellToMoveTo;

    this.BM().setCursorCell(cellToMoveTo);
    if (Lecode.S_TBS.showScopes) {
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    }

    this._commandPhase = "move_selection_wait";
    this._commandNextPhaseCallBack = this.commandMoveP3.bind(this);
    this._commandExtraData.destCell = cellToMoveTo;
    this._commandExtraData.savedParams = param;
};

TBSAiManager.prototype.commandSetAction = function (param) {
    var type = param[0];
    var priority = param[1];
    var possibilities = [];
    var data;

    //- Special case for move type actions
    if (type.match(/move/i)) {
        data = this._builtData["move"];
        var action, cellType;
        if (priority.match(/toward/i)) {
            action = data.sort(function (data1, data2) {
                var value1 = data1.rushCellDistance;
                var value2 = data2.rushCellDistance;
                return (value1 < value2) ? 1 : ((value1 > value2) ? -1 : 0);
            }.bind(this))[0];
            cellType = action.rushCellTarget;
        } else {
            action = data.sort(function (data1, data2) {
                var value1 = data1.escapeCellDistance;
                var value2 = data2.escapeCellDistance;
                return (value1 < value2) ? 1 : ((value1 > value2) ? -1 : 0);
            }.bind(this))[0];
            cellType = action.escapeCellTarget;
        }
        this._actionData = action;
        this._actionData.cellTarget = cellType;
        return;
    }

    //- Special case for summon type actions
    if (type.match(/summon/i)) {
        data = this._builtData["summon"];
        this._actionData = LeUtilities.getRandomValueInArray(data);
        return;
    }

    var searchedEntity = this._targetData.entity;

    if (type.match(/damage/i)) {
        data = this._builtData["offense"];
    } else if (type.match(/healing/i)) {
        data = this._builtData["healing"];
    } else if (type.match(/support/i)) {
        data = this._builtData["support"];
    }
    for (var i = 0; i < data.length; i++) {
        var action = data[i];
        if (action.targets.indexOf(searchedEntity) >= 0) {
            possibilities.push(action);
        }
    }
    possibilities = possibilities.sort(function (data1, data2) {
        var value1 = data1.nbrTargets;
        var value2 = data2.nbrTargets;
        return (value1 < value2) ? 1 : ((value1 > value2) ? -1 : 0);
    }.bind(this));
    var bestNbrTargets = possibilities[0].nbrTargets;
    //- Only keep possibilities with the best nbr of targets with 80% of chance
    if (Math.random() < 0.8) {
        possibilities = possibilities.filter(function (p) {
            return p.nbrTargets === bestNbrTargets;
        });
    }
    if (type.match(/healing/i))
        possibilities = this.sortActionsByDmg(possibilities).reverse();
    else if (type.match(/damage/i))
        possibilities = this.sortActionsByDmg(possibilities);

    var action = null;
    if (priority.match(/average/i)) {
        var array = [];
        for (var i = 0; i < possibilities.length; i++) {
            var p = possibilities[i];
            var obj = p.obj;
            for (var j = 0; j < (obj._leTbsRating || 1); j++)
                array.push(p);
        }
        action = LeUtilities.getRandomValueInArray(array);
    } else if (priority.match(/best/i)) {
        action = possibilities[0];
    } else {
        action = possibilities.leU_last();
    }

    this._actionData = action;
};

TBSAiManager.prototype.sortActionsByDmg = function (actionsData) {
    return actionsData.sort(function (data1, data2) {
        var obj1 = data1.obj;
        var obj2 = data2.obj;
        var dummyAction1 = new Game_Action(this._battler, false);
        dummyAction1.setItemObject(obj1);
        var dummyAction2 = new Game_Action(this._battler, false);
        dummyAction2.setItemObject(obj2);
        var value1 = dummyAction1.evaluate();
        var value2 = dummyAction2.evaluate();
        return (value1 < value2) ? 1 : ((value1 > value2) ? -1 : 0);
    }.bind(this));
};

TBSAiManager.prototype.commandUse = function (param) {
    var info = param[0];

    if (!this._entity.canObjCommand()) return;

    var obj;
    if (info.match(/defined_action/i))
        obj = this._actionData.obj;

    if (obj) {
        this.BM().activeAction().setItemObject(obj);
        if (this.BM().activeAction().isAttack()) {
            if (Lecode.S_TBS.showScopes)
                this.BM().drawAttackScope(this._entity);
            else
                this.BM().makeAttackScope(this._entity);
        } else {
            if (Lecode.S_TBS.showScopes)
                this.BM().drawSkillScope(this._entity, obj);
            else
                this.BM().makeSkillScope(this._entity, obj);
        }

        if (Lecode.S_TBS.showScopes) {
            var wait = Lecode.S_TBS.aiWaitTime;
            this.BM().wait(wait);
        }

        this._commandPhase = "obj_scope_wait";
        this._commandNextPhaseCallBack = this.commandUseP2.bind(this, obj);
    }
};

TBSAiManager.prototype.commandUseP2 = function (obj) {
    var cellTarget = this._actionData.cellTarget;
    var center = this._entity.getCell().toCoords();
    var cell = this.getClosestActionCellToTarget(cellTarget, obj, center);

    this.BM().setCursorCell(cell);
    //this.BM().updateActionSelection();
    this._entity.lookAt(cell);
    if (Lecode.S_TBS.showScopes) {
        var wait = Lecode.S_TBS.aiWaitTime;
        this.BM().wait(wait);
    }

    this._commandPhase = "obj_selection_wait";
    this._commandNextPhaseCallBack = this.commandUseP3.bind(this, obj);
};

TBSAiManager.prototype.commandUseP3 = function (obj) {
    this.BM().getLayer("scopes").clear();
    this.BM().clearActionSelection();
    this.BM().processAction();
    BattleManagerTBS._subPhase = "ai";
    this._commandPhase = "invoking";
};

TBSAiManager.prototype.commandPass = function (param) {
    var look = param[0];
    switch (look) {
        case "look_closest_enemy":
            this._entity.lookClosestBattler(this.getEnemiesOf(this._battler, true));
            break;
        case "look_closest_ally":
            this._entity.lookClosestBattler(this.getAlliesOf(this._battler, true));
            break;
    }
    this.BM().processCommandPass();
};

TBSAiManager.prototype.commandScript = function (param) {
    var script = param[0];
    eval(script);
};

TBSAiManager.prototype.getFocusedEntities = function (group, type) {
    var focusData = [];
    group.forEach(function (entity) {
        var priority = entity.isFocusedByAI(type);
        if (priority)
            focusData.push({ entity: entity, priority: priority });
    });
    return focusData.sort(function (da, db) {
        return db.priority - da.priority;
    }).map(function (data) {
        return data.entity;
    });
};

TBSAiManager.prototype.updateRunningCommand = function () {
    var functionName = LeUtilities.shrinkTextWithUnderscores(this._commandRunning);
    var func = eval("this.updateCommand" + functionName);
    if (func) {
        func.call(this);
    } else {
        this.nextCommand();
    }
};

TBSAiManager.prototype.updateCommandWait = function () {
    if (!this.BM().isWaiting())
        this.nextCommand();
};

TBSAiManager.prototype.updateCommandMove = function () {
    var phase = this._commandPhase;
    switch (phase) {
        case "move_scope_wait":
        case "move_selection_wait":
            if (!this.BM().isWaiting())
                this._commandNextPhaseCallBack();
            break;
        case "moving":
            if (!this._entity.isMoving()) {
                this.BM().onActiveEntityMoveEnd();
                this.BM()._subPhase = "ai";
                if (this._entity.getCell() === this._commandExtraData.destCell)
                    this.nextCommand();
                else {
                    this.commandMove(this._commandExtraData.savedParams);
                }
            }
            break;
        default:
            this.nextCommand();
            break;
    }
};

TBSAiManager.prototype.updateCommandMoveForAction = function () {
    var phase = this._commandPhase;
    switch (phase) {
        case "move_scope_wait":
        case "move_selection_wait":
            if (!this.BM().isWaiting())
                this._commandNextPhaseCallBack();
            break;
        case "moving":
            if (!this._entity.isMoving()) {
                this.BM().onActiveEntityMoveEnd();
                this.BM()._subPhase = "ai";
                if (this._entity.getCell() === this._commandExtraData.destCell)
                    this.nextCommand();
                else {
                    this.commandMoveForAction();
                }
            }
            break;
        default:
            this.nextCommand();
            break;
    }
};

TBSAiManager.prototype.updateCommandUse = function () {
    var phase = this._commandPhase;
    switch (phase) {
        case "obj_scope_wait":
        case "obj_selection_wait":
            if (!this.BM().isWaiting())
                this._commandNextPhaseCallBack();
            break;
        case "invoking":
            if (!this.BM().anySequenceRunning()) {
                this.BM().onActionEnd();
                this.BM()._subPhase = "ai";
                this.nextCommand();
            }
            break;
        default:
            this.nextCommand();
            break;
    }
};

TBSAiManager.prototype.BM = function () {
    return BattleManagerTBS;
};

TBSAiManager.prototype.func_Chance = function (value) {
    return Math.random() < value * 0.01;
};

TBSAiManager.prototype.func_IsTargetValid = function () {
    return this._targetData != null;
};

TBSAiManager.prototype.func_FailureCode = function () {
    console.log("Code: ", this._failureCode);
    return this._failureCode;
};

TBSAiManager.prototype.func_CanUseOffense = function () {
    //this._failureCode = "";
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["offense"].length <= 0) {
        this._failureCode = "out_of_range";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseHealing = function () {
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["healing"].length <= 0) {
        this._failureCode = "unable_to_heal";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseSupport = function () {
    if (this._entity._aiSupportCount === 0) return false;
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["support"].length <= 0) {
        this._failureCode = "unable_to_use_support";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseSummon = function () {
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["summon"].length <= 0) {
        this._failureCode = "unable_to_use_summon";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseEscape = function () {
    if (this._entity._aiEscapeCount === 0) return false;
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["move"].filter(function (action) {
        return !!action.escapeCellTarget;
    }).length <= 0) {
        this._failureCode = "unable_to_escape_w_skill";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_CanUseRush = function () {
    if (this.getUsableSkills(this._battler).length === 0) {
        this._failureCode = "no_usable_skill";
        return false;
    }
    if (this._builtData["move"].filter(function (action) {
        return !!action.rushCellTarget;
    }).length <= 0) {
        this._failureCode = "unable_to_rush_w_skill";
        return false;
    }
    return true;
};

TBSAiManager.prototype.func_BattlerInRange = function (target, action) {
    var cellTarget, obj;
    if (action.match(/defined_action/i)) {
        if (this._actionData)
            obj = this._actionData.obj;
        else
            return false;
    }
    if (target.match(/defined_target/i)) {
        if (this._actionData)
            cellTarget = this._actionData.cellTarget;
        else
            return false;
    }

    var data = (obj.id === this._battler.attackSkillId()) ? this._entity.getAttackScopeData() : this._entity.getObjectScopeData(obj);
    var center = this._entity.getCell().toCoords();
    var param = this.BM().makeObjScopeParam(obj, this._entity, center);
    var scope = this.BM().getScopeFromData(data, center, param);
    for (var i = 0; i < scope.length; i++) {
        var cell = scope[i];
        if (cellTarget.isSame(cell)) {
            return true;
        }
    }
    return false;
};

TBSAiManager.prototype.func_DistanceBetween = function (target) {
    var cellTarget;
    if (target.match(/defined_target/i)) {
        if (this._actionData)
            cellTarget = this._actionData.cellTarget;
        else
            return false;
    }
    return LeUtilities.distanceBetweenCells(cellTarget, this._entity.getCell());
};

TBSAiManager.prototype.func_DistanceToEnemies = function () {
    var scope = this.BM().makeMoveScope(this._entity, true).cells;
    scope = scope.filter(function (cell) {
        return cell._walkable;
    }.bind(this));
    if (scope.length === 0)
        scope = [this._entity.getCell()];
    var cell = BattleManagerTBS.getCellTowardParty(scope, this.getEnemiesOf(this._battler, true));
    return LeUtilities.distanceBetweenCells(cell, this._entity.getCell());
};

TBSAiManager.prototype.func_DistanceToAllies = function () {
    var scope = this.BM().makeMoveScope(this._entity, true).cells;
    scope = scope.filter(function (cell) {
        return cell._walkable;
    }.bind(this));
    if (scope.length === 0)
        scope = [this._entity.getCell()];
    var cell = BattleManagerTBS.getCellTowardParty(scope, this.getAlliesOf(this._battler, true));
    return LeUtilities.distanceBetweenCells(cell, this._entity.getCell());
};

TBSAiManager.prototype.func_IsInMeleeWith = function (target) {
    return this.func_DistanceBetween(target) <= 1;
};

TBSAiManager.prototype.func_IsInMelee = function () {
    return this.func_DistanceToEnemies() <= 1;
};

TBSAiManager.prototype.func_GetPattern = function () {
    return this._entity.getAiPattern();
};

TBSAiManager.prototype.getEnemiesOf = function (battler, needAlive) {
    if (battler.hasConfusionStateAttackAlly())
        return this.getAlliesOf(battler, needAlive);
    if (battler.hasConfusionStateAttackAnyone() && Math.randomInt(2) === 0)
        return this.getAlliesOf(battler, needAlive);
    var group = battler.isActor() ? this.BM().enemyEntities() : this.BM().allyEntities();
    if (needAlive) {
        return group.filter(function (ent) {
            return !ent.battler().isDead();
        });
    } else {
        return group;
    }
};

TBSAiManager.prototype.getAlliesOf = function (battler, needAlive) {
    if (battler.hasConfusionStateAttackEnemy())
        return this.getEnemiesOf(battler, needAlive);
    if (battler.hasConfusionStateAttackAnyone() && Math.randomInt(2) === 0)
        return this.getEnemiesOf(battler, needAlive);
    var group = battler.isEnemy() ? this.BM().enemyEntities() : this.BM().allyEntities();
    if (needAlive) {
        return group.filter(function (ent) {
            return !ent.battler().isDead();
        });
    } else {
        return group;
    }
};

TBSAiManager.prototype.isAlly = function (battler) {
    return this._battler.isActor() && battler.isActor() || this._battler.isEnemy() && battler.isEnemy();
};

TBSAiManager.prototype.isEnemy = function (battler) {
    return !this.isAlly(battler);
};

TBSAiManager.prototype.getUsableSkills = function (user) {
    if (user.isActor()) {
        return user.usableSkills().concat($dataSkills[user.attackSkillId()]);
    }
    var actionList = user.enemy().actions.filter(function (a) {
        return user.isActionValid(a);
    });
    var skills = [];
    for (var i = 0; i < actionList.length; i++) {
        var action = actionList[i];
        var skill = $dataSkills[action.skillId];
        if (user.canUse(skill)) {
            skill._leTbsRating = action.rating;
            skills.push(skill);
        }
    }
    return skills;
};

TBSAiManager.prototype.getGroupFromActionData = function (maxPm) {
    var group = [];
    var data = this._actionDataType;
    for (var i = 0; i < data.length; i++) {
        if (data[i].requiredMp <= maxPm) {
            for (var j = 0; j < data[i].targets.length; j++) {
                var target = data[i].targets[j];
                if (!target._battler.isDead())
                    group.push(target);
            }
        }
    }
    return group;
};


/*-------------------------------------------------------------------------
* Sequence Manager
-------------------------------------------------------------------------*/
function TBSSequenceManager() {
    this.initialize.call(this, arguments);
}

TBSSequenceManager.prototype.initialize = function () {
    this._sequence = null;
    this._sequenceName = "";
    this._commandRunning = null;
    this._waitRequested = false;
    this._users = [];
    this._lastBattlerTargets = [];
    this._lastCellTargets = [];
    this._savedEntities = {};
    this._savedCells = {};
    this._sequenceQueue = [];
    this._obj = null;
    this._affectedTargets = [];
};

TBSSequenceManager.prototype.start = function (sequence, user, action) {
    this._sequence = this.parseSequence(sequence).slice();
    this._sequenceName = sequence;
    this._commandRunning = null;
    this._sequenceQueue = [];
    this._users = [user];
    this._affectedTargets = [];
    if (action)
        this._obj = action.item();
    this._action = action;
};

TBSSequenceManager.prototype.append = function (sequence, user, action) {
    this._sequenceQueue.push([sequence, user, action]);
};

TBSSequenceManager.prototype.getUser = function () {
    return this._users.leU_last();
};

TBSSequenceManager.prototype.getObj = function () {
    return this._obj;
};

TBSSequenceManager.prototype.parseSequence = function (id) {
    if (id instanceof Array) return id;
    if (id.match(/\((.+)\)/i)) {
        var args = RegExp.$1.split(",");
        id = id.replace(/\(.+\)/i, "");
        var sequence = Lecode.S_TBS.Config.Sequences[id];
        for (var i = 0; i < sequence.length; i++) {
            var line = sequence[i];
            for (var j = 0; j < args.length; j++) {
                var arg = args[j];
                sequence[i] = line.replace("$" + String(j + 1), arg);
            }
        }
        return sequence;
    }
    return Lecode.S_TBS.Config.Sequences[id];
};

TBSSequenceManager.prototype.update = function () {
    if (!this.isRunning()) return;
    if (this._commandRunning) {
        this.updateRunningCommand();
        return;
    }
    var command = this._sequence.shift();
    if (command) {
        this.runCommand(command);
    } else
        this.endOfSequence();
};

TBSSequenceManager.prototype.runCommand = function (command) {
    if (!command.match(/(.+)\s?:\s?(.+)/i)) return;
    var main = String(RegExp.$1).trim(),
        param = LeUtilities.stringSplit(String(RegExp.$2).trim(), ",");
    for (var i = 0; i < param.length; i++) {
        param[i] = param[i].trim();
    }

    this._waitRequested = false;
    var functionName = LeUtilities.shrinkTextWithUnderscores(main);
    var func = function () { };
    try {
        func = eval("this.command" + functionName + ".bind(this,param)");
    } catch (e) {
        console.log("[LeTBS]    Can't find command \"", functionName);
        console.log(e);
    }
    func();

    this._commandRunning = main;
};

TBSSequenceManager.prototype.commandPlayPose = function (param) {
    var targetData = param[0];
    var pose = param[1];
    var afterPose = param[2];
    var wait = false;
    if (afterPose === "true") {
        wait = true;
        afterPose = null;
    }
    var targets = this.readTargets(targetData);

    targets.forEach(function (target) {
        target.requestPlayPose();
        target.setPose(pose, afterPose);
    }.bind(this));

    this._waitRequested = wait;
};

TBSSequenceManager.prototype.commandSetFrame = function (param) {
    var targetData = param[0];
    var pose = param[1];
    var frame = param[2];
    var targets = this.readTargets(targetData);

    targets.forEach(function (target) {
        target.setFixedPose(pose, frame);
    }.bind(this));
};

TBSSequenceManager.prototype.commandSetSpeed = function (param) {
    var targetData = param[0];
    var value = param[1];
    var targets = this.readTargets(targetData);

    if (value === "reset") {
        targets.forEach(function (target) {
            target.initializeSpeed();
        }.bind(this));
    } else if (value.match(/\+(.+)/i)) {
        targets.forEach(function (target) {
            target.changeSpeed(Number(RegExp.$1));
        }.bind(this));
    } else if (value.match(/\-(.+)/i)) {
        targets.forEach(function (target) {
            target.changeSpeed(-Number(RegExp.$1));
        }.bind(this));
    } else {
        targets.forEach(function (target) {
            target.setSpeed(Number(value));
        }.bind(this));
    }
};

TBSSequenceManager.prototype.commandSetFrameDelay = function (param) {
    var targetData = param[0];
    var value = param[1];
    var targets = this.readTargets(targetData);


    if (value === "reset") {
        targets.forEach(function (target) {
            target.sprite().initializeFrameDelay();
        }.bind(this));
    } else if (value.match(/\+(.+)/i)) {
        targets.forEach(function (target) {
            target.sprite().changeFrameDelay(Number(RegExp.$1));
        }.bind(this));
    } else if (value.match(/\-(.+)/i)) {
        targets.forEach(function (target) {
            target.sprite().changeFrameDelay(-Number(RegExp.$1));
        }.bind(this));
    } else {
        targets.forEach(function (target) {
            target.sprite().setFrameDelay(Number(value));
        }.bind(this));
    }
};

TBSSequenceManager.prototype.commandSpriteShake = function (param) {
    var targetData = param[0];
    var power = Number(param[1]);
    var duration = Number(param[2]);
    var wait = (param[3] === "true");
    var targets = this.readTargets(targetData);

    for (var i = 0; i < targets.length; i++) {
        targets[i].startShake(power, duration);
    }
    if (wait) {
        this.commandWait([duration]);
    }
};

TBSSequenceManager.prototype.commandWait = function (param) {
    var duration = Number(param[0]);

    BattleManagerTBS.wait(duration);
};

TBSSequenceManager.prototype.commandEffects = function (param) {
    var targetData = param[0];
    var objData = param[1];
    var obj = this.readObject(objData);
    var hitAnim = param[2] || null;
    var animDelay = Number(param[3] || 0);
    var wait = String(param[4] || "false");
    wait = (wait === "true");
    var targets = this.readTargets(targetData);

    if (hitAnim && hitAnim.match(/obj_anim/i)) {
        if (BattleManagerTBS.activeAction().isAttack())
            hitAnim = BattleManagerTBS.activeEntity().getAttackAnimation();
        else
            hitAnim = BattleManagerTBS.activeAction().item().animationId;
    }
    BattleManagerTBS.invokeObjEffects(this.getUser(), obj, targets, hitAnim, animDelay);
    this._affectedTargets = this._affectedTargets.concat(targets);

    this._waitRequested = wait;
};

TBSSequenceManager.prototype.commandMapEffects = function (param) {
    var targetData = param[0];
    var objData = param[1];
    var obj = this.readObject(objData);
    var hitAnim = param[2] || null;
    var animDelay = Number(param[3] || 0);
    var wait = String(param[4] || "false");
    wait = (wait == "true");
    var cellTargets = this.readCellTargets(targetData);

    if (hitAnim && hitAnim.match(/obj_anim/i)) {
        if (BattleManagerTBS.activeAction().isAttack())
            hitAnim = BattleManagerTBS.activeEntity().getAttackAnimation();
        else
            hitAnim = BattleManagerTBS.activeAction().item().animationId;
    }
    BattleManagerTBS.invokeObjEffectsOnMap(this.getUser(), obj, cellTargets, hitAnim, animDelay);

    this._waitRequested = wait;
};

TBSSequenceManager.prototype.commandPerformCollapse = function (param) {
    var targetData = param[0];
    var targets = this.readTargets(targetData);

    for (var i = 0; i < targets.length; i++) {
        targets[i].battler().performCollapse();
    }
};

TBSSequenceManager.prototype.commandAnim = function (param) {
    var targetData = param[0];
    var anim = param[1];
    var animDelay = Number(param[2] || 0);
    var wait = String(param[3] || "false");
    wait = (wait == "true");
    var targets = this.readTargets(targetData);

    if (anim.match(/obj_anim/i)) {
        if (BattleManagerTBS.activeAction().isAttack())
            anim = BattleManagerTBS.activeEntity().getAttackAnimation();
        else
            anim = BattleManagerTBS.activeAction().item().animationId;
    } else if (anim.match(/collapse_anim/i)) {
        var collapse_anim = true;
    } else {
        anim = Number(anim);
    }

    targets.forEach(function (target) {
        if (collapse_anim)
            anim = target.getCollapseAnimation();
        target.newAnimation(anim, false, animDelay);
    }.bind(this));

    this._waitRequested = wait;
};

TBSSequenceManager.prototype.commandMapAnim = function (param) {
    var targetData = param[0];
    var anim = param[1];
    var animDelay = Number(param[2] || 0);
    var wait = String(param[3] || "false");
    wait = (wait == "true");
    var cellTargets = this.readCellTargets(targetData);

    if (anim.match(/obj_anim/i)) {
        if (BattleManagerTBS.activeAction().isAttack())
            anim = BattleManagerTBS.activeEntity().getAttackAnimation();
        else
            anim = BattleManagerTBS.activeAction().item().animationId;
    } else {
        anim = Number(anim);
    }
    cellTargets.forEach(function (cell) {
        BattleManagerTBS.getLayer("animations").newAnimation(anim, false, animDelay, cell);
    }.bind(this));

    this._waitRequested = wait;
};

TBSSequenceManager.prototype.commandDirectionalAnim = function (param) {
    var targetData1 = param[0];
    var targetData2 = param[1];
    var anim_2 = param[2];
    var anim_4 = param[3];
    var anim_6 = param[4];
    var anim_8 = param[5];
    var animDelay = Number(param[6] || 0);
    var wait = String(param[7] || "false");
    var targets1 = this.readTargets(targetData1);

    if (targets1.length > 0) {
        var anim;
        switch (targets1[0].getDir()) {
            case 2:
                anim = anim_2;
                break;
            case 4:
                anim = anim_4;
                break;
            case 6:
                anim = anim_6;
                break;
            case 8:
                anim = anim_8;
                break;
        }
        param[0] = targetData2;
        param[1] = anim;
        param[2] = animDelay;
        param[3] = wait;
        this.commandAnim(param);
    }
};

TBSSequenceManager.prototype.commandLookAt = function (param) {
    var targetData = param[0];
    var cellTargetData = param[1];
    var targets = this.readTargets(targetData);
    var cellTargets = this.readCellTargets(cellTargetData);

    if (cellTargets.length > 0) {
        var cell = cellTargets[0];
        targets.forEach(function (target) {
            target.lookAt(cell);
        }.bind(this));
    }
};

TBSSequenceManager.prototype.commandLookAway = function (param) {
    var targetData = param[0];
    var cellTargetData = param[1];
    var targets = this.readTargets(targetData);
    var cellTargets = this.readCellTargets(cellTargetData);

    if (cellTargets.length > 0) {
        var cell = cellTargets[0];
        targets.forEach(function (target) {
            target.lookAway(cell);
        }.bind(this));
    }
};

TBSSequenceManager.prototype.commandMoveToCell = function (param) {
    var targetData = param[0];
    var cellTargetData = param[1];
    var isInstant = String(param[2] || "false");
    isInstant = (isInstant.match(/true/i));
    var targets = this.readTargets(targetData);
    var cellTargets = this.readCellTargets(cellTargetData);

    if (targets.length > 0 && cellTargetData.length > 0) {
        var target = targets[0];
        var cell = cellTargets[0];
        if (isInstant) {
            target.teleport(cell);
        } else {
            var path = BattleManagerTBS.getPathFromAToB(target._cellX, target._cellY, cell.x, cell.y, "walkable");
            target.processMovement(path);
            this._waitRequested = true;
        }
    }
};

TBSSequenceManager.prototype.commandSwitchCells = function (param) {
    var targetData1 = param[0];
    var targetData2 = param[1];
    var target1 = this.readTargets(targetData1)[0];
    var target2 = this.readTargets(targetData2)[0];

    if (target1 && target2)
        target1.switchCellWith(target2);
};

TBSSequenceManager.prototype.commandJumpToCell = function (param) {
    var targetData = param[0];
    var cellTargetData = param[1];
    var height = param[2] || 120;
    var targets = this.readTargets(targetData);
    var cellTargets = this.readCellTargets(cellTargetData);

    if (targets.length > 0 && cellTargetData.length > 0) {
        var target = targets[0];
        var cell = cellTargets[0];
        var sx = target.x;
        var sy = target.y;
        var dx = cell.x * $gameMap.tileWidth();
        var dy = cell.y * $gameMap.tileHeight();
        var trajectory = LeUtilities.getPixelsOfJump(sx, sy, dx, dy, height);
        target.followTrajectory(trajectory, cell);
        this._waitRequested = true;
    }

};

TBSSequenceManager.prototype.commandMoveStraight = function (param) {
    var targetData = param[0];
    var nbr = Number(param[1] || 1);
    var targets = this.readTargets(targetData);

    targets.forEach(function (target) {
        target.forceMoveStraight(nbr, false);
    }.bind(this));
    this._waitRequested = true;
};

TBSSequenceManager.prototype.commandPush = function (param) {
    var targetData = param[0];
    var targetData2 = param[1];
    var distance = Number(param[2]);
    var damage = param[3] !== "false";
    var targets = this.readTargets(targetData);
    var sourceCell = this.readCellTargets(targetData2)[0];

    for (var i = 0; i < targets.length; i++) {
        var entity = targets[i];
        entity.forcePush(this.getUser(), sourceCell, distance, this.getObj(), damage);
    }
};

TBSSequenceManager.prototype.commandPull = function (param) {
    var targetData = param[0];
    var targetData2 = param[1];
    var distance = Number(param[2]);
    var damage = param[3] !== "false";
    var targets = this.readTargets(targetData);
    var sourceCell = this.readCellTargets(targetData2)[0];

    for (var i = 0; i < targets.length; i++) {
        var entity = targets[i];
        entity.forcePull(this.getUser(), sourceCell, distance, this.getObj(), damage);
    }
};

TBSSequenceManager.prototype.commandReachTarget = function (param) {
    var targetData = param[0];
    var targetData2 = param[1];
    var type = param[2];
    var endIf = (param[3] || "true") === "true";

    var user = this.readTargets(targetData)[0];
    var target = this.readTargets(targetData2)[0];
    if (target) {
        if (!user.reachEntity(target, type))
            this.endOfSequence();
    }
};

TBSSequenceManager.prototype.commandProjectile = function (param) {
    var id = param[0];
    var cellTargetData1 = param[1];
    var cellTargetData2 = param[2];
    var cellTargets1 = this.readCellTargets(cellTargetData1);
    var cellTargets2 = this.readCellTargets(cellTargetData2);
    if (cellTargets2.length === 0) {
        var entities = this.readTargets(cellTargetData2);
        cellTargets2 = entities.map(function (entity) {
            return entity.getCell();
        });
    }
    cellTargets2 = LeUtilities.uniqArray(cellTargets2);

    if (cellTargets1.length > 0 && cellTargets2.length > 0) {
        var cellStart = cellTargets1[0];
        cellTargets2.forEach(function (cellEnd) {
            var w = $gameMap.tileWidth();
            var h = $gameMap.tileHeight();
            var sx = cellStart.x * w + w / 2;
            var sy = cellStart.y * h + h / 2;
            var dx = cellEnd.x * w + w / 2;
            var dy = cellEnd.y * h + h / 2;
            BattleManagerTBS._projectilesManager.newProjectile(id, [sx, sy], [dx, dy]);
        });
    }
};

TBSSequenceManager.prototype.commandSetBattlerTargets = function (param) {
    var targetData = param[0];
    var targets = this.readTargets(targetData);
    this._lastBattlerTargets = targets;
};

TBSSequenceManager.prototype.commandSetCellTargets = function (param) {
    var targetData = param[0];
    var targets = this.readCellTargets(targetData);
    this._lastCellTargets = targets;
};

TBSSequenceManager.prototype.commandSaveEntities = function (param) {
    var id = param[0];
    var targetData = param[1];
    var option = param[2];
    var targets = this.readTargets(targetData);
    this._savedEntities[id] = targets;
    if (option === "shift") {
        this._savedEntities[id] = [targets.shift()];
    } else {
        this._savedEntities[id] = targets;
    }
};

TBSSequenceManager.prototype.commandSaveCells = function (param) {
    var id = param[0];
    var targetData = param[1];
    var option = param[2];
    var targets = this.readCellTargets(targetData);
    if (option === "shift") {
        this._savedCells[id] = [targets.shift()];
    } else {
        this._savedCells[id] = targets;
    }
};

TBSSequenceManager.prototype.commandSetCursor = function (param) {
    var targetData = param[0];
    var targets = this.readCellTargets(targetData);
    var cell = targets[0];
    BattleManagerTBS.setCursorCell(cell);
};

TBSSequenceManager.prototype.commandCall = function (param) {
    var seq = param[0];
    var times = Number(param[1] || 1);

    var seqArray = Lecode.S_TBS.Config.Sequences[seq].slice();
    for (var i = 0; i < times; i++) {
        for (var j = seqArray.length - 1; j >= 0; j--) {
            var command = seqArray[j];
            this._sequence.unshift(command);
        }
    }
};

TBSSequenceManager.prototype.commandCallForEveryCell = function (param) {
    var seq = param[0];
    var targetData = param[1];
    var sortType = param[2] || "random";

    var aoe = this.readCellTargets(targetData);
    if (sortType === "close->far") {
        aoe = aoe.sort(function (a, b) {
            var obj_aDist = LeUtilities.distanceBetween(a, this.getUser().getCell());
            var obj_bDist = LeUtilities.distanceBetween(b, this.getUser().getCell());
            return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
        }.bind(this));
    } else if (sortType === "far->close") {
        aoe = aoe.sort(function (a, b) {
            var obj_aDist = LeUtilities.distanceBetween(a, this.getUser().getCell());
            var obj_bDist = LeUtilities.distanceBetween(b, this.getUser().getCell());
            return (obj_aDist > obj_bDist) ? -1 : ((obj_aDist < obj_bDist) ? 1 : 0);
        }.bind(this));
    } else if (sortType === "random") {
        aoe = aoe.filter(function (cell) {
            return true;
        });
    }
    if (aoe.length > 0) {
        this._savedCells["every_cell_base"] = aoe;
        //this._savedCells["every_cell"] = aoe.shift();

        var seqArray = Lecode.S_TBS.Config.Sequences[seq].slice();
        for (var i = 0; i < aoe.length; i++) {
            for (var j = seqArray.length - 1; j >= 0; j--) {
                var command = seqArray[j];
                this._sequence.unshift(command);
            }
            this._sequence.unshift("save_cells: every_cell, saved(every_cell_base), shift");
        }
    }
};

TBSSequenceManager.prototype.commandCallForEveryEntity = function (param) {
    var seq = param[0];
    var targetData = param[1];
    var sortType = param[2] || "random";

    var entities = this.readTargets(targetData);
    if (sortType === "close->far") {
        entities = entities.sort(function (a, b) {
            var obj_aDist = LeUtilities.distanceBetween(a.getCell(), this.getUser().getCell());
            var obj_bDist = LeUtilities.distanceBetween(b.getCell(), this.getUser().getCell());
            return (obj_aDist > obj_bDist) ? 1 : ((obj_aDist < obj_bDist) ? -1 : 0);
        }.bind(this));
    } else if (sortType === "far->close") {
        entities = entities.sort(function (a, b) {
            var obj_aDist = LeUtilities.distanceBetween(a.getCell(), this.getUser().getCell());
            var obj_bDist = LeUtilities.distanceBetween(b.getCell(), this.getUser().getCell());
            return (obj_aDist > obj_bDist) ? -1 : ((obj_aDist < obj_bDist) ? 1 : 0);
        }.bind(this));
    } else if (sortType === "random") {
        entities = entities.filter(function (cell) {
            return true;
        });
    }
    if (entities.length > 0) {
        this._savedEntities["every_entity_base"] = entities;

        var seqArray = Lecode.S_TBS.Config.Sequences[seq].slice();
        for (var i = 0; i < entities.length; i++) {
            for (var j = seqArray.length - 1; j >= 0; j--) {
                var command = seqArray[j];
                this._sequence.unshift(command);
            }
            this._sequence.unshift("save_entities: every_entity, saved(every_entity_base), shift");
        }
    }
};

TBSSequenceManager.prototype.commandDelegateCall = function (param) {
    var seq = param[0];
    var targetData = param[1];
    var targets = this.readTargets(targetData);

    if (targets.length > 0) {
        this._users.push(targets[0]);
        param[1] = 1;
        this.commandCall(param);
    }
};

TBSSequenceManager.prototype.commandEndDelegatedCall = function () {
    this._users.pop();
};

TBSSequenceManager.prototype.commandAskCall = function (param) {
    var seq = param[0];
    var targetData = param[1];
    var targets = this.readTargets(targetData);

    for (var i = 0; i < targets.length; i++) {
        targets[i].startSequence(seq);
    }
};

TBSSequenceManager.prototype.commandUseSkill = function (param) {
    var targetData = param[0];
    var skillId = param[1];
    var targets = this.readTargets(targetData);

    for (var i = 0; i < targets.length; i++) {
        targets[i].forceAction(skillId);
    }
};

TBSSequenceManager.prototype.commandScript = function (param) {
    var code = param[0];
    var user = this.getUser();
    eval(code);
};

TBSSequenceManager.prototype.updateRunningCommand = function () {
    var command = this._commandRunning;
    switch (command) {
        case "wait":
            this.updateCommandWait();
            break;
        case "play_pose":
            this.updateCommandPlayPose();
            break;
        case "anim":
        case "map_anim":
        case "effects":
        case "map_effects":
            this.updateCommandAnim();
            break;
        case "move_to_cell":
            this.updateCommandMoveToCell();
            break;
        case "move_straight":
            this.updateCommandMoveStraight();
            break;
        case "jump_to_cell":
            this.updateCommandJumpToCell();
            break;
        case "projectile":
            this.updateCommandProjectile();
            break;
        default:
            this._commandRunning = null;
            break;
    }
};

TBSSequenceManager.prototype.updateCommandWait = function () {
    if (!BattleManagerTBS.isWaiting())
        this._commandRunning = null;
};

TBSSequenceManager.prototype.updateCommandPlayPose = function () {
    if (this._waitRequested) {
        var entities = BattleManagerTBS.battlerEntities();
        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if (!entity.isRequestedPosePlayed())
                return;
        }
        this._commandRunning = null;
        this.update();
    } else
        this._commandRunning = null;
};

TBSSequenceManager.prototype.updateCommandAnim = function () {
    if (this._waitRequested) {
        if (!BattleManagerTBS.getLayer("animations").isAnimationPlaying())
            this._commandRunning = null;
    } else
        this._commandRunning = null;
};

TBSSequenceManager.prototype.updateCommandMoveToCell = function () {
    if (this._waitRequested) {
        var entities = BattleManagerTBS.battlerEntities();
        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if (entity.isMoving())
                return;
        }
        this._commandRunning = null;
    } else
        this._commandRunning = null;
};

TBSSequenceManager.prototype.updateCommandMoveStraight = function () {
    if (this._waitRequested) {
        var entities = BattleManagerTBS.battlerEntities();
        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if (entity.isMoving())
                return;
        }
        this._commandRunning = null;
    } else
        this._commandRunning = null;
};

TBSSequenceManager.prototype.updateCommandJumpToCell = function () {
    if (this._waitRequested) {
        var entities = BattleManagerTBS.battlerEntities();
        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if (entity._sprite.hasTrajectory())
                return;
        }
        this._commandRunning = null;
    } else
        this._commandRunning = null;
};

TBSSequenceManager.prototype.updateCommandProjectile = function () {
    if (!BattleManagerTBS._projectilesManager.isRunning())
        this._commandRunning = null;
};

TBSSequenceManager.prototype.readTargets = function (data) {
    var targets = [];
    var x = BattleManagerTBS.cursor().cellX;
    var y = BattleManagerTBS.cursor().cellY;
    var cursorCell = BattleManagerTBS.getCellAt(x, y);
    var aoe = [];
    if (data.match(/\{(.+)\}/i)) {
        var aoeKey = RegExp.$1;
        if (aoeKey === "aoe") {
            aoe = BattleManagerTBS._actionAoE;
        } else if (aoeKey === "cursor") {
            aoe = [cursorCell];
        } else {
            var param = {
                user: this.getUser(),
                dir: this.getUser().getDirectionTo(cursorCell),
                need_check_los: false,
                exclude_center: false,
                line_of_sight: false
            };
            aoe = BattleManagerTBS.getScopeFromData(aoeKey, cursorCell, param);
        }
    }
    var aoeTargets = BattleManagerTBS.getEntitiesInScope(aoe);
    var aoeAllyTargets = aoeTargets.filter(function (entity) {
        return this.isAlly(entity.battler());
    }.bind(this));
    var aoeEnemyTargets = aoeTargets.filter(function (entity) {
        return this.isEnemy(entity.battler());
    }.bind(this));
    var aoeDeadTargets = aoeTargets.filter(function (entity) {
        return entity.battler().isDead();
    });
    var aoeDeadAllyTargets = aoeAllyTargets.filter(function (entity) {
        return entity.battler().isDead();
    });
    var aoeDeadEnemyTargets = aoeEnemyTargets.filter(function (entity) {
        return entity.battler().isDead();
    });
    var cursorTarget = [cursorCell.getEntity()];
    var cursorAllyTarget = (cursorTarget[0] && this.isAlly(cursorTarget[0].battler())) ? cursorTarget : [];
    var cursorEnemyTarget = (cursorTarget[0] && this.isEnemy(cursorTarget[0].battler())) ? cursorTarget : [];
    var cursorDeadTarget = (cursorTarget[0] && cursorTarget[0].battler().isDead()) ? cursorTarget : [];
    var cursorDeadAllyTarget = (cursorAllyTarget[0] > 0 && cursorAllyTarget[0].battler().isDead()) ? cursorAllyTarget : [];
    var cursorDeadEnemyTarget = (cursorEnemyTarget[0] > 0 && cursorEnemyTarget[0].battler().isDead()) ? cursorEnemyTarget : [];

    if (data.match(/\{.+\}_battlers/i)) {
        targets = aoeTargets;
    } else if (data.match(/\{.+\}_allies/i)) {
        targets = aoeAllyTargets;
    } else if (data.match(/\{.+\}_enemies/i)) {
        targets = aoeEnemyTargets;
    } else if (data.match(/(\d+)_battlers_in_\{.+\}/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeTargets, Number(RegExp.$1));
    } else if (data.match(/(\d+)_allies_in_\{.+\}/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeAllyTargets, Number(RegExp.$1));
    } else if (data.match(/(\d+)_enemies_in_\{.+\}/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeEnemyTargets, Number(RegExp.$1));
    } else if (data.match(/cursor_battler/i)) {
        targets = cursorTarget;
    } else if (data.match(/cursor_ally/i)) {
        targets = cursorAllyTarget;
    } else if (data.match(/cursor_enemy/i)) {
        targets = cursorEnemyTarget;
    } else if (data.match(/\{.+\}_dead_battlers/i)) {
        targets = aoeDeadTargets;
    } else if (data.match(/\{.+\}_dead_allies/i)) {
        targets = aoeDeadAllyTargets;
    } else if (data.match(/\{.+\}_dead_enemies/i)) {
        targets = aoeDeadEnemyTargets;
    } else if (data.match(/(\d+)_dead_battlers_in_\{.+\}/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeDeadTargets, Number(RegExp.$1));
    } else if (data.match(/(\d+)_dead_allies_in_\{.+\}/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeDeadAllyTargets, Number(RegExp.$1));
    } else if (data.match(/(\d+)_dead_enemies_in_\{.+\}/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoeDeadEnemyTargets, Number(RegExp.$1));
    } else if (data.match(/cursor_dead_battler/i)) {
        targets = cursorDeadTarget;
    } else if (data.match(/cursor_dead_ally/i)) {
        targets = cursorDeadAllyTarget;
    } else if (data.match(/cursor_dead_enemy/i)) {
        targets = cursorDeadEnemyTarget;
    } else if (data.match(/battler_toward_user/i)) {
        var cell = this.getUser().getForwardCell();
        if (cell) {
            var target = cell.getEntity();
            if (target)
                targets = [target];
        }
    } else if (data.match(/user/i)) {
        targets = [this.getUser()];
    } else if (data.match(/all/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            targets.push(entity);
        });
    } else if (data.match(/allies/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            if (this.isAlly(entity.battler()))
                targets.push(entity);
        }.bind(this));
    } else if (data.match(/enemies/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            if (this.isEnemy(entity.battler()))
                targets.push(entity);
        }.bind(this));
    } else if (data.match(/last_targets/i)) {
        targets = this._lastBattlerTargets;
    } else if (data.match(/saved\((.+)\)/i)) {
        targets = this._savedEntities[RegExp.$1] || [];
    }

    if (data.match(/\-(.+)/i)) {
        var newData = RegExp.$1;
        var toExclude = this.readTargets(newData);
        targets = targets.filter(function (entity) {
            return toExclude.indexOf(entity) === -1;
        });
    }

    /*if (data.match(/-user/i)) {
        var ux = this.getUser()._cellX;
        var uy = this.getUser()._cellY;
        targets = targets.filter(function (entity) {
            return entity._cellX != ux || entity._cellY != uy;
        }.bind(this));
    }*/
    this._lastBattlerTargets = targets;
    return targets;
};

TBSSequenceManager.prototype.readCellTargets = function (data) {
    var targets = [];
    var x = BattleManagerTBS.cursor().cellX;
    var y = BattleManagerTBS.cursor().cellY;
    var cursorCell = BattleManagerTBS.getCellAt(x, y);
    var aoe = [];
    if (data.match(/\{(.+)\}/i)) {
        var aoeKey = RegExp.$1;
        if (aoeKey === "aoe") {
            aoe = BattleManagerTBS._actionAoE;
        } else if (aoeKey === "cursor") {
            aoe = [cursorCell];
        } else {
            var param = {
                user: this.getUser(),
                dir: this.getUser().getDirectionTo(cursorCell),
                need_check_los: false,
                exclude_center: false,
                line_of_sight: false
            };
            aoe = BattleManagerTBS.getScopeFromData(aoeKey, cursorCell, param);
        }
    }

    if (data.match(/\{(.+)\}/i)) {
        targets = aoe;
    } else if (data.match(/cursor_cell/i)) {
        targets = [cursorCell];
    } else if (data.match(/user_cell/i)) {
        targets = [this.getUser().getCell()];
    } else if (data.match(/(\d+)_cells_in_\{.+\}/i)) {
        targets = LeUtilities.getXRandomValuesInArray(aoe, Number(RegExp.$1));
    } else if (data.match(/\{.+\}_ally_cells/i)) {
        targets = aoe.filter(function (cell) {
            var e = cell.getEntity();
            if (e) {
                return this.isAlly(e.battler());
            }
            return false;
        }.bind(this));
    } else if (data.match(/\{.+\}_enemy_cells/i)) {
        targets = aoe.filter(function (cell) {
            var e = cell.getEntity();
            if (e) {
                return this.isEnemy(e.battler());
            }
            return false;
        }.bind(this));
    } else if (data.match(/battlers_cells/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            targets.push(entity.getCell());
        }.bind(this));
    } else if (data.match(/ally_cells/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            if (this.isAlly(entity.battler()))
                targets.push(entity.getCell());
        }.bind(this));
    } else if (data.match(/enemy_cells/i)) {
        BattleManagerTBS.allEntities().forEach(function (entity) {
            if (this.isEnemy(entity.battler()))
                targets.push(entity.getCell());
        }.bind(this));
    } else if (data.match(/last_targets/i)) {
        targets = this._lastCellTargets;
    } else if (data.match(/saved\((.+)\)/i)) {
        targets = this._savedCells[RegExp.$1] || [];
    }

    if (data.match(/\-(.+)/i)) {
        var newData = RegExp.$1;
        var toExclude = this.readCellTargets(newData);
        targets = targets.filter(function (cell) {
            return toExclude.indexOf(cell) === -1;
        });
    }
    /*
    if (data.match(/-user_cell/i)) {
        targets = targets.filter(function (cell) {
            return !this.getUser().getCell().isSame(cell);
        }.bind(this));
    }*/
    this._lastCellTargets = targets;
    return targets;
};

TBSSequenceManager.prototype.readObject = function (data) {
    if (data.match(/current_obj/i))
        return BattleManagerTBS.activeAction().item();
    return null;
};

TBSSequenceManager.prototype.endOfSequence = function () {
    this._sequence = null;
    this._savedEntities = {};
    this._savedCells = {};
    var data = this._sequenceQueue.shift();
    if (data) {
        this.start(data[0], data[1], data[2]);
        this.update();
    } else {
        var entities = LeUtilities.uniqArray(this._affectedTargets);
        BattleManagerTBS.processCounterAttack(entities, this.getUser(), this._action);
        this._affectedTargets = [];
    }
};

TBSSequenceManager.prototype.isRunning = function () {
    return this._sequence != null;
};

TBSSequenceManager.prototype.isAlly = function (battler) {
    return this.getUser().battler().isActor() && battler.isActor() || this.getUser().battler().isEnemy() && battler.isEnemy();
};

TBSSequenceManager.prototype.isEnemy = function (battler) {
    return !this.isAlly(battler);
};

/*-------------------------------------------------------------------------
* TBSProjectilesManager
-------------------------------------------------------------------------*/
function TBSProjectilesManager() {
    this.initialize.apply(this, arguments);
}

TBSProjectilesManager.prototype.initialize = function (layer) {
    this._layer = layer;
    this._projectiles = [];
    this._running = false;
};

TBSProjectilesManager.prototype.isRunning = function () {
    return this._projectiles.length > 0;
};

TBSProjectilesManager.prototype.newProjectile = function (id, start, end) {
    var proj = new TBSProjectileSprite(id, start, end);
    this._projectiles.push(proj);
    this._layer.addChild(proj);
};

TBSProjectilesManager.prototype.update = function () {
    //this.updateProjectiles();
    this.destoryProjectiles();
};

TBSProjectilesManager.prototype.updateProjectiles = function () {
    for (var i = 0; i < this._projectiles.length; i++) {
        this._projectiles[i].update();
    }
};

TBSProjectilesManager.prototype.destoryProjectiles = function () {
    this._projectiles = this._projectiles.filter(function (proj) {
        if (proj.finished()) {
            this._layer.removeChild(proj);
            return false;
        }
        return true;
    }.bind(this));
};

/*-------------------------------------------------------------------------
* TBSProjectileSprite
-------------------------------------------------------------------------*/
function TBSProjectileSprite() {
    this.initialize.apply(this, arguments);
}
TBSProjectileSprite.prototype = Object.create(Sprite_Base.prototype);
TBSProjectileSprite.prototype.constructor = TBSProjectileSprite;

TBSProjectileSprite.prototype.initialize = function (id, start, end) {
    Sprite_Base.prototype.initialize.call(this);
    this._start = start;
    this._end = end;
    this._trajectory = [];
    this._speedFrame = 0;
    this.readData(id);
    this.iniPositions();
    this.makeTrajectory();
};

TBSProjectileSprite.prototype.readData = function (id) {
    var data = Lecode.S_TBS.Config.Projectiles[id];
    if (data.filename) {
        var bitmap = ImageManager.loadLeTBSProjectile(data.filename);
        this.bitmap = bitmap;
    } else if (data.anim) {
        this.bitmap = new Bitmap(data.anim[1], data.anim[2]);
        this.startAnimation(data.anim[0]);
    }
    this._speed = data.speed || 3;
    this._adaptAngle = false || data.adapt_angle;
    this._jump = data.jump || 0;
    this.anchor.x = 0.5;
    this.anchor.y = 0.5;
};

TBSProjectileSprite.prototype.iniPositions = function () {
    this.x = this._start[0];
    this.y = this._start[1];
};

TBSProjectileSprite.prototype.makeTrajectory = function () {
    var sx = this._start[0];
    var sy = this._start[1];
    var dx = this._end[0];
    var dy = this._end[1];
    if (this._jump != 0) {
        this._trajectory = LeUtilities.getPixelsOfJump(sx, sy, dx, dy, this._jump);
    } else {
        this._trajectory = LeUtilities.getPixelsOfLine(sx, sy, dx, dy);
    }
    if (this._trajectory[0][0] === dx && this._trajectory[0][1] === dy)
        this._trajectory = this._trajectory.reverse();
};

TBSProjectileSprite.prototype.update = function () {
    Sprite_Base.prototype.update.call(this);
    if (!this.finished()) {
        this.updateAngle();
        this.updateMove();
    }
};

TBSProjectileSprite.prototype.updateMove = function () {
    var frame = this._speedFrame;
    if (frame >= this._trajectory.length - 1) {
        frame = this._trajectory.length - 1;
        this._finished = true;
    }
    var newPos = this._trajectory[frame];
    this.x = newPos[0];
    this.y = newPos[1];
    this._speedFrame += this._speed;
};

TBSProjectileSprite.prototype.updateAngle = function () {
    if (this._adaptAngle) {
        var sx, sy, dx, dy;
        sx = this.x;
        sy = this.y;
        if (this._jump === 0) {
            dx = this._end[0];
            dy = this._end[1];
        } else {
            var topFrame = parseInt(this._trajectory.length / 2);
            if (this._speedFrame > topFrame) {
                dx = this._end[0];
                dy = this._end[1];
            } else {
                var topCoord = this._trajectory[topFrame];
                dx = topCoord[0];
                dy = topCoord[1];
            }
        }
        var rotation = Math.atan2(dy - sy, dx - sx);
        this.rotation = rotation;
    }
};

TBSProjectileSprite.prototype.startAnimation = function (animation) {
    animation = $dataAnimations[animation];
    var sprite = new Sprite_ProjectileAnimation();
    sprite.setup(this, animation);
    this.addChild(sprite);
    this._animationSprites.push(sprite);
};

TBSProjectileSprite.prototype.finished = function () {
    return this._finished;
};

/*-------------------------------------------------------------------------
* Sprite_ProjectileAnimation
-------------------------------------------------------------------------*/
function Sprite_ProjectileAnimation() {
    this.initialize.apply(this, arguments);
}
Sprite_ProjectileAnimation.prototype = Object.create(Sprite_Animation.prototype);
Sprite_ProjectileAnimation.prototype.constructor = Sprite_ProjectileAnimation;

Sprite_ProjectileAnimation.prototype.initialize = function () {
    Sprite_Animation.prototype.initialize.call(this);
};

Sprite_ProjectileAnimation.prototype.update = function () {
    Sprite_Animation.prototype.update.call(this);
    if (!this.isPlaying() && this._animation)
        this.setupDuration();
};

Sprite_ProjectileAnimation.prototype.setup = function (target, animation) {
    this._target = target;
    this._animation = animation;
    this._mirror = false;
    this._delay = false;
    if (this._animation) {
        this.remove();
        this.setupRate();
        this.setupDuration();
        this.loadBitmaps();
        this.createSprites();
    }
};

Sprite_ProjectileAnimation.prototype.updatePosition = function () {
    this.x = 0; //this._target.x;
    this.y = 0; //this._target.y;
};

Sprite_ProjectileAnimation.prototype.updateCellSprite = function (sprite, cell) {
    Sprite_Animation.prototype.updateCellSprite.call(this, sprite, cell);
    sprite.rotation += this._target.rotation * Math.PI / 180;
};


/*-------------------------------------------------------------------------
* Cell entity
-------------------------------------------------------------------------*/
function TBSCell(x, y) {
    this.x = x;
    this.y = y;
    this._regionId = -1;
    this._type = null;
    this._event = null;
    this._visible = false;
    this._opacity = 0;
    this._color = "";
}

TBSCell.prototype.isSame = function (otherCell) {
    return otherCell && this.x === otherCell.x && this.y === otherCell.y;
};

TBSCell.prototype.select = function () {
    BattleManagerTBS._activeCell = this;
};

TBSCell.prototype.isImpassableTile = function () {
    var x = this.x,
        y = this.y;
    if (!$gameMap.isValid(x, y)) return true;
    if (!$gameMap.isPassable(x, y, 2)) return true;
    if (!$gameMap.isPassable(x, y, 4)) return true;
    if (!$gameMap.isPassable(x, y, 6)) return true;
    if (!$gameMap.isPassable(x, y, 8)) return true;
    return false;
};

TBSCell.prototype.isObstacle = function () {
    if (this.regionId() === Lecode.S_TBS.obstacleRegionId) return true;
    if (this.regionId() === Lecode.S_TBS.freeObstacleRegionId) return true;
    if (this.isThereEntity()) return true;
    var tbsEvent = BattleManagerTBS.getTBSEventAt(this.x, this.y);
    if (tbsEvent && tbsEvent.isObstacle()) return true;
    return false;
};

TBSCell.prototype.isObstacleForLOS = function () {
    if (this.regionId() === Lecode.S_TBS.obstacleRegionId) return true;
    if (this.isThereEntity()) return true;
    var tbsEvent = BattleManagerTBS.getTBSEventAt(this.x, this.y);
    if (tbsEvent && tbsEvent.isObstacleForLOS()) return true;
    return false;
};

TBSCell.prototype.isThereEntity = function () {
    return this.getEntity() != null;
};

TBSCell.prototype.getEntity = function () {
    var entities = BattleManagerTBS.allEntities();
    for (var i = 0; i < entities.length; i++) {
        var entity = entities[i];
        if (entity.getCell().isSame(this))
            return entity;
    }
    return null;
};

TBSCell.prototype.regionId = function () {
    var tbsEvent = BattleManagerTBS.getTBSEventAt(this.x, this.y);
    if (tbsEvent && tbsEvent._tileEffect && tbsEvent._tileEffect > -1) {
        return tbsEvent._tileEffect;
    }
    return this._regionId;
};

TBSCell.prototype.toCoords = function () {
    return {
        x: this.x,
        y: this.y
    };
};

/*-------------------------------------------------------------------------
* SpriteCursorTBS
-------------------------------------------------------------------------*/
function SpriteCursorTBS() {
    this.initialize.apply(this, arguments);
}

SpriteCursorTBS.prototype = Object.create(Sprite.prototype);
SpriteCursorTBS.prototype.constructor = SpriteCursorTBS;

SpriteCursorTBS.prototype.initialize = function (bitmap) {
    Sprite.prototype.initialize.call(this, bitmap);
    this.cellX = this.cellY = 0;
    this._leU_loopFlash = true;
    this._leU_loopFlashData = {
        color: [255, 255, 255, 255],
        duration: 30
    };
};

SpriteCursorTBS.prototype.hide = function () {
    this.visible = false;
};

SpriteCursorTBS.prototype.show = function () {
    this.visible = true;
};

/*-------------------------------------------------------------------------
* TBSTurnOrderVisual
-------------------------------------------------------------------------*/
function TBSTurnOrderVisual() {
    this.initialize.apply(this, arguments);
}


/*-------------------------------------------------------------------------
* TBSEntity
-------------------------------------------------------------------------*/
function TBSEntity() {
    this.initialize.apply(this, arguments);

    Object.defineProperty(this, 'x', {
        get: function () {
            return this._posX;
        },
        set: function (value) {
            this.setPosition(value, this.y);
        },
        configurable: true
    });

    Object.defineProperty(this, 'y', {
        get: function () {
            return this._posY;
        },
        set: function (value) {
            this.setPosition(this.x, value);
        },
        configurable: true
    });
}

TBSEntity.prototype.initialize = function (battler, layer) {
    this._battler = battler;
    this._cell = null;
    this._cellX = 0;
    this._cellY = 0;
    this._moving = false;
    this._movePoints = 0;
    this._movingDistance = [0, 0];
    this._movePath = [];
    this._movingNextCell = null;
    this._moveReducePoints = false;
    this._movePerformed = false;
    this._actionPerformed = false;
    this._dead = false;
    this._flag = null;
    this._isMouseOver = false;
    this.createSprite(battler, layer);
    this.createSpriteValues();
    this.createComponents();
    this.setMovePoints();
    this.initializeSpeed();
};

TBSEntity.prototype.createSprite = function (battler, layer) {
    this._sprite = new TBSEntity_Sprite(battler, this);
    this._layer = layer;
    layer.addChild(this._sprite);
};

TBSEntity.prototype.createSpriteValues = function () {
    this._posX = 0;
    this._posY = 0;
    this._dir = 2;
    this._lastDir = 2;
    this._pose = "idle";
    this._afterPose = "idle";
    this._poseLoop = false;
    this._fixedPose = null;
};

TBSEntity.prototype.createComponents = function () {
    this._sequenceManager = new TBSSequenceManager();
};

TBSEntity.prototype.initializeSpeed = function () {
    this.setSpeed(Lecode.S_TBS.battlersMoveSpeed);
};

TBSEntity.prototype.setSpeed = function (speed) {
    this._speed = speed;
};

TBSEntity.prototype.changeSpeed = function (speed) {
    this._speed += speed;
};

TBSEntity.prototype.destroy = function () {
    //this._layer.removeChild(this._sprite);
};

TBSEntity.prototype.startSequence = function (id, action) {
    this._sequenceManager.start(id, this, action);
};

TBSEntity.prototype.runningSequence = function () {
    return this._sequenceManager._sequenceName;
};

TBSEntity.prototype.callSequence = function (id) {
    if (this._sequenceManager.isRunning()) {
        this._sequenceManager.commandCall([id, 1]);
    } else {
        this.startSequence(id);
    }
};

TBSEntity.prototype.appendSequence = function (id, action) {
    if (this._sequenceManager.isRunning()) {
        var sequence = Lecode.S_TBS.Config.Sequences[id];
        this._sequenceManager.append(sequence, this, action);
    } else {
        this.startSequence(id, action);
    }
};

TBSEntity.prototype.requestPlayPose = function () {
    this._requestPlayPose = true;
};

TBSEntity.prototype.isRequestedPosePlayed = function () {
    return !this._requestPlayPose;
};

TBSEntity.prototype.setPose = function (pose, afterPose) {
    this._fixedPose = null;
    this._pose = pose;
    this._afterPose = afterPose || "idle";
    this._poseLoop = (afterPose === pose);
    this._sprite.updatePose();
    this._sprite.resetFrameCount();
    this._sprite.setFixedFrame(null);
    this._sprite.updateBitmap();
    this._sprite.updatePosition();
};

TBSEntity.prototype.setFixedPose = function (pose, frame) {
    this._pose = pose;
    this._sprite.updatePose();
    if (frame === "last")
        frame = this._sprite._maxFrame[this._sprite.getPose()];
    this._fixedPose = pose;
    this._afterPose = null;
    this._poseLoop = false;
    this._sprite.resetFrameCount();
    this._sprite.setFixedFrame(Number(frame));
    this._sprite.updateBitmap();
    this._sprite.updatePosition();
};

TBSEntity.prototype.onPosePlayed = function (oldPose) {
    if (this._fixedPose) {
        this._pose = this._fixedPose;
        this._sprite.updatePose();
        return;
    }
    if (this._poseLoop) {
        this.setPose(oldPose, oldPose);
    } else {
        this.setPose(this._afterPose);
        this._afterPose = "idle";
    }
    this._requestPlayPose = false;
};

TBSEntity.prototype.setDir = function (dir) {
    if (![2, 4, 6, 8].contains(dir)) return;
    this._lastDir = this.getDir();
    this._dir = dir;
    this._sprite.update();
};

TBSEntity.prototype.getDir = function () {
    return this._dir;
};

TBSEntity.prototype.setCell = function (cell) {
    var x = cell.x * $gameMap.tileWidth();
    var y = cell.y * $gameMap.tileHeight();
    this.setPosition(x, y);
    this._cellX = cell.x;
    this._cellY = cell.y;
    this._cell = cell;
};

TBSEntity.prototype.setPosition = function (x, y) {
    this._posX = x;
    this._posY = y;
};

TBSEntity.prototype.shiftPosition = function (x, y) {
    this._posX += x;
    this._posY += y;
};

TBSEntity.prototype.update = function () {
    this.checkDeath();
    this.updateMove();
    this.checkMouseEvents();
};

TBSEntity.prototype.updateSprite = function () {
    this._sprite.update();
};

TBSEntity.prototype.checkDeath = function () {
    if (this._battler.isDead() && !this._dead)
        this.onDeath();
    if (!this._battler.isDead() && this._dead)
        this.onRevive();

};

TBSEntity.prototype.onBattleStart = function () {
    this._battler.onBattleStart();
    this.setMovePoints();
};

TBSEntity.prototype.onTurnStart = function () {
    this.setMovePoints();
    this.callSequence("turn_start");
    /*if (this.battler().isActor())
        this.newAnimation(180,false,false);
    else
        this.newAnimation(181,false,false);*/
};

TBSEntity.prototype.onTurnEnd = function () {
    this._battler.onTurnEnd();
    this.addPopup();
    this.setMovePoints();
    this._movePerformed = false;
    this._actionPerformed = false;
};

TBSEntity.prototype.onDeath = function () {
    this._dead = true;
    if (this.runningSequence() === "damaged")
        this.appendSequence("dead");
    else
        this.startSequence("dead");
    BattleManagerTBS.onEntityDeath(this);
};

TBSEntity.prototype.onRevive = function () {
    this._dead = false;
    this.appendSequence("revived");
    BattleManagerTBS.onEntityRevive(this);
};

TBSEntity.prototype.onDamage = function () {
    this.addPopup();
    this.checkDeath();
};

TBSEntity.prototype.onActionStart = function (id, fastSequence, action) {
};

TBSEntity.prototype.onActionEnd = function (id, action) {
};

TBSEntity.prototype.checkMouseEvents = function () {
    var triggered = false;
    if (this.isMouseOverMe()) {
        if (!this._isMouseOver) {
            this._isMouseOver = true;
            this.onMouseOver();
        }
        this.whileMouseOver();
    }
    if (!this.isMouseOverMe()) {
        if (this._isMouseOver) {
            this.onMouseOut();
        }
        this._isMouseOver = false;
    }
};

TBSEntity.prototype.isMouseOverMe = function () {
    var data = TouchInput._leTBSMoveData;
    return this._sprite.getBounds().contains(data.x, data.y);
};

TBSEntity.prototype.onMouseOver = function () {

};

TBSEntity.prototype.onMouseOut = function () {

};

TBSEntity.prototype.whileMouseOver = function () {

};

TBSEntity.prototype.lookAt = function (cell) {
    var downD = cell.y - this._cellY;
    var upD = this._cellY - cell.y;
    var rightD = cell.x - this._cellX;
    var leftD = this._cellX - cell.x;
    var maxD = LeUtilities.getMaxInArray([downD, upD, rightD, leftD]);
    switch (maxD) {
        case downD:
            this.setDir(2);
            break;
        case upD:
            this.setDir(8);
            break;
        case leftD:
            this.setDir(4);
            break;
        case rightD:
            this.setDir(6);
            break;
    }
};

TBSEntity.prototype.lookAway = function (cell) {
    this.lookAt(cell);
    switch (this.getDir()) {
        case 2:
            this.setDir(8);
            break;
        case 4:
            this.setDir(6);
            break;
        case 6:
            this.setDir(4);
            break;
        case 8:
            this.setDir(2);
            break;
    }
};

TBSEntity.prototype.getDirectionTo = function (cell) {
    var oldDir = this.getDir();
    this.lookAt(cell);
    var dir = this.getDir();
    this.setDir(oldDir);
    return dir;
};

TBSEntity.prototype.getDirectionAwayFrom = function (cell) {
    var oldDir = this.getDir();
    this.lookAway(cell);
    var dir = this.getDir();
    this.setDir(oldDir);
    return dir;
};

TBSEntity.prototype.startShake = function (power, duration) {
    this._sprite._shakeEffect = {
        power: power,
        duration: duration
    };
};

TBSEntity.prototype.lookClosestBattler = function (entities) {
    if (entities.length === 0) return;
    var entity = LeUtilities.closestByDistance(this, entities);
    var cell = entity.getCell();
    this.lookAt(cell);
};

TBSEntity.prototype.processMovement = function (path) {
    if (!path || path.length === 0) return;
    this._moving = true;
    this._movePath = path;
    this._movePath.reverse();
    this.setPose("move", "move");
    this._moveReducePoints = true;
    this._moveUpdateDir = true;
};

TBSEntity.prototype.forceMoveStraight = function (nbrCells, checkCollision) {
    if (nbrCells <= 0) return;
    this._movePath = [];
    var cx = this._cellX;
    var cy = this._cellY;
    this._collisionData = {
        distance: nbrCells,
        covered: 0,
        dir: this.getDir(),
        endCell: null
    };
    for (var i = 0; i < nbrCells; i++) {
        var cell = this.getForwardCell(cx, cy);
        if (!cell || cell.isObstacle()) { //  || cell.isImpassableTile()
            this._collisionData.endCell = cell;
            break;
        }
        this._collisionData.covered++;
        this._movePath.push(cell);
        switch (this.getDir()) {
            case 2:
                cy++;
                break;
            case 4:
                cx--;
                break;
            case 6:
                cx++;
                break;
            case 8:
                cy--;
                break;
        }
    }
    if (!checkCollision) this._collisionData = null;
    if (this._movePath.length === 0) return;
    this._moving = true;
    this._movingStraight = true;
    this._movePath.reverse();
    this._moveReducePoints = false;
    this._moveUpdateDir = true;
};

TBSEntity.prototype.forcePush = function (user, sourceCell, distance, obj, damage) {
    if (this.isImmuneToKnockback())
        return;
    distance += user.getKnockbackBonus() - this.getKnockbackReduction();
    var old = this.getDir();
    this.lookAway(sourceCell);
    this.forceMoveStraight(distance, damage);
    this.setDir(old);
    this._moveUpdateDir = false;
    if (this._collisionData) {
        this._collisionData.user = user;
        this._collisionData.obj = obj;
    }

    if (this._movePath.length === 0 && this._collisionData)
        BattleManagerTBS.processCollisionEffects(this);
};

TBSEntity.prototype.forcePull = function (user, sourceCell, distance, obj, damage) {
    if (this.isImmuneToKnockback())
        return;
    var old = this.getDir();
    this.lookAt(sourceCell);
    this.forceMoveStraight(distance, damage);
    this.setDir(old);
    this._moveUpdateDir = false;
    if (this._collisionData) {
        this._collisionData.user = user;
        this._collisionData.obj = obj;
    }

    if (this._movePath.length === 0 && this._collisionData)
        BattleManagerTBS.processCollisionEffects(this);
};

TBSEntity.prototype.reachEntity = function (entity, type) {
    var cells = [];
    switch (type) {
        case "back":
            cells.push(entity.getBackwardCell());
            break;
        case "front":
            cells.push(entity.getForwardCell());
            break;
        case "side":
            cells = cells.concat(entity.getSideCells());
            break;
        case "random":
            cells.push(entity.getBackwardCell());
            cells.push(entity.getForwardCell());
            cells = cells.concat(entity.getSideCells());
            break;
    }
    var dest = LeUtilities.getXRandomValuesInArray(cells, 1)[0];
    if (dest && !dest.isObstacle()) {
        this.setCell(dest);
        return true;
    }
    return false;
};

TBSEntity.prototype.getForwardCell = function (cx, cy) {
    cx = cx || this._cellX;
    cy = cy || this._cellY;
    switch (this.getDir()) {
        case 2:
            return BattleManagerTBS.getCellAt(cx, cy + 1);
        case 4:
            return BattleManagerTBS.getCellAt(cx - 1, cy);
        case 6:
            return BattleManagerTBS.getCellAt(cx + 1, cy);
        case 8:
            return BattleManagerTBS.getCellAt(cx, cy - 1);
    }
    return null;
};

TBSEntity.prototype.getBackwardCell = function () {
    var cell = this.getForwardCell();
    if (cell) {
        this.lookAway(cell);
        var backCell = this.getForwardCell();
        this.lookAt(cell);
        return backCell;
    }
    return null;
};

TBSEntity.prototype.getSideCells = function () {
    var cell = this.getForwardCell();
    if (!cell) {
        return; //- WIP if forward cell is null, use back cell.
    }
    var sideCell1;
    var sideCell2;
    if (this.getDir() === 8 || this.getDir() === 2) {
        sideCell1 = BattleManagerTBS.getCellAt(cell.x - 1, cell.y - 1);
        sideCell2 = BattleManagerTBS.getCellAt(cell.x + 1, cell.y - 1);
    } else {
        sideCell1 = BattleManagerTBS.getCellAt(cell.x - 1, cell.y - 1);
        sideCell2 = BattleManagerTBS.getCellAt(cell.x - 1, cell.y + 1);
    }
    return [sideCell1, sideCell2];
};

//- TODO: MOVE the 3 following functions to BattleManagerTBS
TBSEntity.prototype.forceAction = function (skillId, target) {
    var skill = $dataSkills[skillId];
    this.forceActionSetTarget(target);
    this.executeAction(skill);
};

TBSEntity.prototype.forceActionSetTarget = function (target) {
    switch (target) {
        case "self":
            BattleManagerTBS.setCursorCell(this.getCell());
            //- lookAt
            break;
    }
};

TBSEntity.prototype.executeAction = function (obj) {
    var battler = this.battler();
    var center = this.getCell().toCoords();
    BattleManagerTBS.newAction(battler, true);
    var action = BattleManagerTBS.activeAction();
    action.setItemObject(obj);

    var data = obj.id === battler.attackSkillId() ? this.getAttackScopeData() : this.getObjectScopeData(obj);
    /*var param = BattleManagerTBS.makeObjScopeParam(obj, this, center);
    var scope = BattleManagerTBS.getScopeFromData(data, center, param);
    BattleManagerTBS._actionScope = {};
    BattleManagerTBS._actionScope.cells = scope;
    BattleManagerTBS._actionScope.center = center;*/
    BattleManagerTBS.makeActionScope(this, data, obj);

    var aoeData = obj.id === battler.attackSkillId() ? this.getAttackAoEData() : this.getObjectAoEData(obj);
    var aoeCenter = BattleManagerTBS._activeCell.toCoords();
    var param = BattleManagerTBS.makeObjAoEParam(obj, this, aoeCenter);
    var aoe = BattleManagerTBS.getScopeFromData(aoeData, aoeCenter, param);
    BattleManagerTBS._actionAoE = aoe;

    var item = action.item();
    var id = action.isAttack() ? this.getWeaponSequenceData() : this.getObjectSequenceData(item);
    battler.useItem(item);
    action.applyGlobal();
    this.appendSequence(id, action);
};

TBSEntity.prototype.updateMove = function () {
    if (!this._moving) return;
    if (!this._movingNextCell) {
        this._movingNextCell = this._movePath.pop();
        this._movingDistance = [0, 0];
    }
    var cell = this._movingNextCell;
    var oldDir = this.getDir();
    this.lookAt(cell);
    this.moveForward(cell);
    if (!this._moveUpdateDir)
        this.setDir(oldDir);
    if (this._cellX == cell.x && this._cellY == cell.y) {
        var stop = this.onCellCovered();
        if (this._movePath.length === 0 || stop)
            this.onMoveEnd(!stop);
    }
};

TBSEntity.prototype.onCellCovered = function () {
    var stop = BattleManagerTBS.executeEventsByStep(this);
    // When returning true, the movement is stoped
    this._movingNextCell = null;
    if (this._moveReducePoints) {
        this._movePoints--;
        if (this.getMovePoints() === 0)
            return true;
    }
    return stop;
};

TBSEntity.prototype.moveForward = function (cell) {
    var speed = this._speed;
    var dir = this._sprite._dir;
    switch (dir) {
        case 2:
            this.shiftPosition(0, speed);
            this._movingDistance[1] += speed;
            break;
        case 4:
            this.shiftPosition(-speed, 0);
            this._movingDistance[0] += speed;
            break;
        case 6:
            this.shiftPosition(speed, 0);
            this._movingDistance[0] += speed;
            break;
        case 8:
            this.shiftPosition(0, -speed);
            this._movingDistance[1] += speed;
            break;
    }
    if (this._movingDistance[0] >= $gameMap.tileWidth() || this._movingDistance[1] >= $gameMap.tileHeight())
        this.setCell(cell);
};

TBSEntity.prototype.onMoveEnd = function () {
    this._moving = false;
    if (this._dead)
        this.setPose("dead", "dead");
    else
        this.setPose("idle");
    this._moveReducePoints = false;

    if (this._collisionData)
        BattleManagerTBS.processCollisionEffects(this);
    this._collisionData = null;
    this._movingStraight = false;
    BattleManagerTBS.executeEventsByTouch(this);
};

TBSEntity.prototype.teleport = function (cell) {
    this.setCell(cell);
};

TBSEntity.prototype.switchCellWith = function (entity) {
    var old = this.getCell();
    this.teleport(entity.getCell());
    entity.teleport(old);
};

TBSEntity.prototype.followTrajectory = function (trajectory, cell) {
    if (cell.x < this.getCell().x) {
        trajectory = trajectory.reverse();
    }
    this._sprite.setTrajectory(trajectory, cell);
};

TBSEntity.prototype.setMovePoints = function () {
    var obj = this._battler.isActor() ? this._battler.actor() : this._battler.enemy();
    this._movePoints = obj.leTbs_movePoints;
    this._battler.states().forEach(function (state) {
        if (state)
            this._movePoints += state.leTbs_movePointsPlus;
    }.bind(this));
    if (this._battler.isActor()) {
        this._battler.equips().forEach(function (equip) {
            if (equip)
                this._movePoints += equip.leTbs_movePointsPlus;
        }.bind(this));
    }
    if (this._movePoints < 0)
        this._movePoints = 0;
};

TBSEntity.prototype.applyObjChangeMovePoints = function (obj) {
    var value = obj.leTbs_changeMovePoints;
    var nbr = value.match("%") ? Number(value.replace("%", "")) * 0.01 * this.getMovePoints() : Number(value);
    this.changeMovePoints(nbr);
},

    TBSEntity.prototype.changeMovePoints = function (plus) {
        this._movePoints += plus;
    };

TBSEntity.prototype.getMovePoints = function () {
    return this._movePoints.clamp(0, this._movePoints);
};

TBSEntity.prototype.canMoveCommand = function () {
    if (this.getMovePoints() === 0) return false;
    if (this.oneTimeMove() && this._movePerformed) return false;
    return true;
};

TBSEntity.prototype.canAttackCommand = function () {
    if (!this._battler.canAttack()) return false;
    if (!this.canObjCommand()) return false;
    return true;
};

TBSEntity.prototype.canSkillCommand = function () {
    if (!this.canObjCommand()) return false;
    return true;
};

TBSEntity.prototype.canItemCommand = function () {
    if (!this.canObjCommand()) return false;
    return true;
};

TBSEntity.prototype.canObjCommand = function () {
    if (this.oneTimeOffense() && this._actionPerformed) return false;
    return true;
};

TBSEntity.prototype.playableByAI = function () {
    return this.battler().isEnemy() || this.battler().isConfused();
};

TBSEntity.prototype.getAttackAnimation = function () {
    if (this._battler.isActor()) {
        return this._battler.attackAnimationId1();
    } else {
        return this._battler.enemy().leTbs_atkAnim;
    }
};

TBSEntity.prototype.getAttackScopeData = function () {
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_atkScopeData;
    else {
        for (var i = 0; i < this._battler.weapons().length; i++) {
            var weapon = this._battler.weapons()[i];
            if (weapon && weapon.leTbs_scopeData)
                return weapon.leTbs_scopeData;
        }
        return this._battler.actor().leTbs_atkScopeData;
    }
};

TBSEntity.prototype.getObjectScopeData = function (obj) {
    var defaultScope = DataManager.isSkill(obj) ? Lecode.S_TBS.defaultSkillScope : Lecode.S_TBS.defaultItemScope;
    return obj.leTbs_scopeData || defaultScope;
};

TBSEntity.prototype.getAttackAoEData = function () {
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_atkAoeData;
    else {
        for (var i = 0; i < this._battler.weapons().length; i++) {
            var weapon = this._battler.weapons()[i];
            if (weapon && weapon.leTbs_aoeData)
                return weapon.leTbs_aoeData;
        }
        return this._battler.actor().leTbs_atkAoeData;
    }
};

TBSEntity.prototype.getObjectAoEData = function (obj) {
    var defaultAoe = DataManager.isSkill(obj) ? Lecode.S_TBS.defaultSkillAoE : Lecode.S_TBS.defaultItemAoE;
    return obj.leTbs_aoeData || defaultAoe;
};

TBSEntity.prototype.getMoveScopeData = function () {
    return this.getMoveScopeRawData().replace("_mp_", String(this.getMovePoints()));
};

TBSEntity.prototype.getMoveScopeRawData = function () {
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_moveScopeData)
            return state.leTbs_moveScopeData;
    }
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_moveScopeData;
    else {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_moveScopeData)
                return equip.leTbs_moveScopeData;
        }
        return this._battler.actor().leTbs_moveScopeData;
    }
};

TBSEntity.prototype.getMoveScopeParamData = function () {
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_moveScopeParam)
            return state.leTbs_moveScopeParam;
    }
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_moveScopeParam;
    else {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_moveScopeParam)
                return equip.leTbs_moveScopeParam;
        }
        return this._battler.actor().leTbs_moveScopeParam;
    }
};

TBSEntity.prototype.getWeaponSequenceData = function () {
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_atkSequenceData;
    else {
        for (var i = 0; i < this._battler.weapons().length; i++) {
            var weapon = this._battler.weapons()[i];
            if (weapon && weapon.leTbs_sequenceData)
                return weapon.leTbs_sequenceData;
        }
        return this._battler.actor().leTbs_atkSequenceData;
    }
};

TBSEntity.prototype.getWeaponFastSequence = function () {
    if (this._battler.isEnemy())
        return [];
    else {
        for (var i = 0; i < this._battler.weapons().length; i++) {
            var weapon = this._battler.weapons()[i];
            if (weapon && weapon.leTbs_sequence)
                return weapon.leTbs_sequence;
        }
        return [];
    }
};

TBSEntity.prototype.getObjectSequenceData = function (obj) {
    var defaultSeqId = DataManager.isSkill(obj) ? Lecode.S_TBS.defaultSkillSequence : Lecode.S_TBS.defaultItemSequence;
    return obj.leTbs_sequenceData || defaultSeqId;
};

TBSEntity.prototype.getObjectFastSequence = function (obj) {
    return obj.leTbs_sequence;
};

TBSEntity.prototype.passAfterObjUse = function (obj) {
    if (DataManager.isSkill(obj)) {
        if (this._battler.isEnemy())
            return !!this._battler.leTbs_passOnAtkUse;
        if (obj.id == this._battler.attackSkillId()) {
            if (this._battler.weapons().length > 0)
                return !!this._battler.weapons()[0].leTbs_passOnUse;
        }
    }
    return !!obj.leTbs_passOnUse;
};

TBSEntity.prototype.oneTimeMove = function () {
    return !!this.rpgObject().leTbs_oneTimeMove;
};

TBSEntity.prototype.oneTimeOffense = function () {
    return !!this.rpgObject().leTbs_oneTimeOffense;
};

TBSEntity.prototype.getCollapseAnimation = function () {
    return this.rpgObject().leTbs_collapseAnim;
};

TBSEntity.prototype.getAiPattern = function () {
    return this.rpgObject().leTbs_aiPattern;
};

TBSEntity.prototype.isPassableOnDeath = function () {
    var test = this.hasNoCorpse();
    if (test) return true;
    test = this.battler().states().some(function (state) {
        return state && !!state.leTbs_passableOnDeath;
    });
    if (test) return true;
    return !!this.rpgObject().leTbs_passableOnDeath;
};

TBSEntity.prototype.isPassable = function () {
    var test = this._battler.isDead() && this.isPassableOnDeath();
    if (test) return true;
    test = this.battler().states().some(function (state) {
        return state && state.leTbs_passable;
    });
    if (test) return true;
    return this.rpgObject().leTbs_passable;
};

TBSEntity.prototype.entitiesCanLayOnMe = function () {
    if (this._battler.isDead()) {
        if (this.hasNoCorpse()) return true;
        test = this.battler().states().some(function (state) {
            return state && state.leTbs_canLayOnMeOnDeath;
        });
        if (test) return true;
        return this.rpgObject().leTbs_canLayOnMeOnDeath;
    }
    test = this.battler().states().some(function (state) {
        return state && state.leTbs_canLayOnMe;
    });
    if (test) return true;
    return this.rpgObject().leTbs_canLayOnMe;
};

TBSEntity.prototype.hasNoCorpse = function () {
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_hasNoCorpse)
            return true;
    }
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_hasNoCorpse;
    else {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_hasNoCorpse)
                return true;
        }
        return this._battler.actor().leTbs_hasNoCorpse;
    }
};

TBSEntity.prototype.isFocusedByAI = function (type) {
    type = type.trim();
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_focusedByAiFor[type])
            return state.leTbs_focusedByAiFor[type];
    }
    if (this._battler.isActor()) {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_focusedByAiFor[type])
                return equip.leTbs_focusedByAiFor[type];
        }
    }
    return null;
};

TBSEntity.prototype.getSpriteScaleX = function () {
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_spriteScaleX)
            return state.leTbs_spriteScaleX;
    }
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_spriteScaleX;
    else {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_spriteScaleX)
                return equip.leTbs_spriteScaleX;
        }
        return this._battler.actor().leTbs_spriteScaleX;
    }
};

TBSEntity.prototype.getSpriteScaleY = function () {
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_spriteScaleY)
            return state.leTbs_spriteScaleY;
    }
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_spriteScaleY;
    else {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_spriteScaleY)
                return equip.leTbs_spriteScaleY;
        }
        return this._battler.actor().leTbs_spriteScaleY;
    }
};

TBSEntity.prototype.getSpriteTone = function () {
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_spriteTone)
            return state.leTbs_spriteTone;
    }
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_spriteTone;
    else {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_spriteTone)
                return equip.leTbs_spriteTone;
        }
        return this._battler.actor().leTbs_spriteTone;
    }
};

TBSEntity.prototype.getSpriteHue = function () {
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_spriteHue)
            return state.leTbs_spriteHue;
    }
    if (this._battler.isEnemy())
        return this._battler.enemy().leTbs_spriteHue;
    else {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_spriteHue)
                return equip.leTbs_spriteHue;
        }
        return this._battler.actor().leTbs_spriteHue;
    }
};

TBSEntity.prototype.setOpacity = function (value) {
    this._sprite.opacity = value;
};

TBSEntity.prototype.getLoopAnimations = function () {
    var anims = [];
    for (var i = 0; i < this._battler.states().length; i++) {
        var state = this._battler.states()[i];
        if (state && state.leTbs_loopAnimation)
            anims.push(state.leTbs_loopAnimation);
    }
    if (this._battler.isEnemy()) {
        if (this._battler.enemy().leTbs_loopAnimation)
            anims.push(this._battler.enemy().leTbs_loopAnimation);
    } else {
        for (var i = 0; i < this._battler.equips().length; i++) {
            var equip = this._battler.equips()[i];
            if (equip && equip.leTbs_loopAnimation)
                anims.push(equip.leTbs_loopAnimation);
        }
        if (this._battler.actor().leTbs_loopAnimation)
            anims.push(this._battler.actor().leTbs_loopAnimation);
    }
    return anims;
};

TBSEntity.prototype.startFlash = function (colorArray, duration, loop) {
    if (loop)
        this._sprite.leU_startLoopFlash(colorArray, duration);
    else
        this._sprite.leU_startFlash(colorArray, duration);
};

TBSEntity.prototype.stopFLash = function () {
    this._sprite.leU_endLoopFlash();
    this._sprite.leU_clearFlash();
};

TBSEntity.prototype.getCollisionDamageBonus = function (damage) {
    var bonus = 0;
    this.battler().states().forEach(function (state) {
        if (state) {
            bonus += state.leTbs_collisionDmgBonus;
            bonus += state.leTbs_collisionDmgBonusRate * 0.01 * damage;
        }
    });
    if (this.battler().isActor()) {
        this.battler().equips().forEach(function (equip) {
            if (equip) {
                bonus += equip.leTbs_collisionDmgBonus;
                bonus += equip.leTbs_collisionDmgBonusRate * 0.01 * damage;
            }
        });
    }
    return bonus;
};

TBSEntity.prototype.getCollisionDamageReduction = function (damage) {
    var reduction = 0;
    this.battler().states().forEach(function (state) {
        if (state) {
            reduction += state.leTbs_collisionDmgReduction;
            reduction += state.leTbs_collisionDmgReductionRate * 0.01 * damage;
        }
    });
    if (this.battler().isActor()) {
        this.battler().equips().forEach(function (equip) {
            if (equip) {
                reduction += equip.leTbs_collisionDmgReduction;
                reduction += equip.leTbs_collisionDmgReductionRate * 0.01 * damage;
            }
        });
    }
    return reduction;
};

TBSEntity.prototype.getDirectionalDmgBonus = function (type) {
    var value = this.rpgObject().leTbs_directionalDmgBonus[type];
    this.battler().states().forEach(function (state) {
        if (state) {
            value += state.leTbs_directionalDmgBonus[type];
        }
    });
    if (this.battler().isActor()) {
        this.battler().equips().forEach(function (equip) {
            if (equip) {
                value += equip.leTbs_directionalDmgBonus[type];
            }
        });
    }
    return value;
};

TBSEntity.prototype.getDirectionalDmgReduction = function (type) {
    var value = this.rpgObject().leTbs_directionalDmgReduction[type];
    this.battler().states().forEach(function (state) {
        if (state) {
            value += state.leTbs_directionalDmgReduction[type];
        }
    });
    if (this.battler().isActor()) {
        this.battler().equips().forEach(function (equip) {
            if (equip) {
                value += equip.leTbs_directionalDmgReduction[type];
            }
        });
    }
    return value;
};

TBSEntity.prototype.isImmuneToKnockback = function () {
    return this.rpgObject().leTbs_immuneKnockback;
};

TBSEntity.prototype.getKnockbackBonus = function () {
    var bonus = 0;
    bonus += this.rpgObject().leTbs_knockbackBonus;
    this.battler().states().forEach(function (state) {
        if (state) {
            bonus += state.leTbs_knockbackBonus;
        }
    });
    if (this.battler().isActor()) {
        this.battler().equips().forEach(function (equip) {
            if (equip) {
                bonus += equip.leTbs_knockbackBonus;
            }
        });
    }
    return bonus;
};

TBSEntity.prototype.getKnockbackReduction = function () {
    var reduction = 0;
    reduction += this.rpgObject().leTbs_knockbackReduction;
    this.battler().states().forEach(function (state) {
        if (state) {
            reduction += state.leTbs_knockbackReduction;
        }
    });
    if (this.battler().isActor()) {
        this.battler().equips().forEach(function (equip) {
            if (equip) {
                reduction += equip.leTbs_knockbackReduction;
            }
        });
    }
    return reduction;
};


TBSEntity.prototype.filenameID = function () {
    var battler = this.battler();
    if (this.rpgObject().leTbs_spriteName)
        return this.rpgObject().leTbs_spriteName;
    if (battler.isActor()) return battler.name();
    return battler.originalName();
};

TBSEntity.prototype.addPopup = function () {
    this._sprite.addPopup();
};

TBSEntity.prototype.newAnimation = function (animation, mirror, delay) {
    this._sprite.newAnimation(animation, mirror, delay);
};

TBSEntity.prototype.battler = function () {
    return this._battler;
};

TBSEntity.prototype.sprite = function () {
    return this._sprite;
};

TBSEntity.prototype.width = function () {
    return this._sprite.width;
};

TBSEntity.prototype.height = function () {
    return this._sprite.height;
};

TBSEntity.prototype.getCell = function () {
    return this._cell;
};

TBSEntity.prototype.isMoving = function () {
    return this._moving;
};

TBSEntity.prototype.rpgObject = function () {
    return this.battler().isActor() ? this.battler().actor() : this.battler().enemy();
};

/*-------------------------------------------------------------------------
* TBSEntity_Sprite
-------------------------------------------------------------------------*/
function TBSEntity_Sprite() {
    this.initialize.apply(this, arguments);
}

TBSEntity_Sprite.prototype = Object.create(Sprite_Base.prototype);
TBSEntity_Sprite.prototype.constructor = TBSEntity_Sprite;

TBSEntity_Sprite.prototype.initialize = function (battler, entity) {
    Sprite_Base.prototype.initialize.call(this);
    this._battler = battler;
    this._entity = entity;
    this._bitmaps = {};
    this._frameCount = 0;
    this._maxFrame = {};
    this._fixedFrame = null;
    this._updateCount = 0;
    this._poses = [];
    this._frameLoaded = 0;
    this._popups = [];
    this._shakeEffect = {
        power: 0,
        duration: 0
    };
    this._trajectoryIndex = 0;
    this._trajectory = [];
    this._trajectoryEndCell = null;
    this.initializeFrameDelay();
    this.createBitmaps();
};

TBSEntity_Sprite.prototype.initializeFrameDelay = function () {
    this.setFrameDelay(Lecode.S_TBS.battlersFrameDelay);
};

TBSEntity_Sprite.prototype.setFrameDelay = function (delay) {
    this._frameDelay = delay;
};

TBSEntity_Sprite.prototype.changeFrameDelay = function (delay) {
    this._frameDelay += delay;
};

TBSEntity_Sprite.prototype.onPosePlayed = function () {
    this._frameCount = 0;
    this._entity.onPosePlayed(this.getPose());
};

TBSEntity_Sprite.prototype.resetFrameCount = function () {
    this._frameCount = 0;
};

TBSEntity_Sprite.prototype.setFixedFrame = function (frame) {
    this._fixedFrame = frame;
};

TBSEntity_Sprite.prototype.setTrajectory = function (trajectory, cell) {
    this._trajectoryIndex = 0;
    this._trajectory = trajectory;
    this._trajectoryEndCell = cell;
};

TBSEntity_Sprite.prototype.hasTrajectory = function () {
    return !!this._trajectory[this._trajectoryIndex];
};

TBSEntity_Sprite.prototype.update = function () {
    Sprite_Base.prototype.update.call(this);
    if (!this.isReady()) return;
    this.updateDirection();
    this.updatePose();
    this.updateFrameDelay();
    this.updatePosition();
    this.updatePopups();
    this.updateSpriteEffects();
    this.checkLoopAnimations();
};

TBSEntity_Sprite.prototype.updateSpriteEffects = function () {
    var entity = this._entity;
    this.scale.x = entity.getSpriteScaleX();
    this.scale.y = entity.getSpriteScaleY();
    this.setColorTone(entity.getSpriteTone());
};

TBSEntity_Sprite.prototype.updateFrameDelay = function () {
    this._updateCount++;
    if (this._updateCount === this._frameDelay) {
        this._updateCount = 0;
        this.onNextFrame();
    }
};

TBSEntity_Sprite.prototype.onNextFrame = function () {
    this.updateBitmap();
    this.updateFrameCount();
};

TBSEntity_Sprite.prototype.updateDirection = function () {
    this._dir = this._entity._dir;
};

TBSEntity_Sprite.prototype.updatePose = function () {
    this._pose = this._entity._pose;
};

TBSEntity_Sprite.prototype.updatePosition = function () {
    this.updateTrajectoryMove();
    this.x = this._entity._posX;
    this.y = this._entity._posY;
    var bounds = this.getBounds();
    if (this.bitmap) {
        var w = bounds.width;
        var h = bounds.height;
        this.x += $gameMap.tileWidth() / 2 - w / 2;
        this.y += $gameMap.tileHeight() - h;
    }
    this.updateShakeEffect();
};

TBSEntity_Sprite.prototype.updateTrajectoryMove = function () {
    if (this.hasTrajectory()) {
        var pos = this._trajectory[this._trajectoryIndex];
        this._trajectoryIndex += this._entity._speed;
        if (!this.hasTrajectory()) {
            this._entity.teleport(this._trajectoryEndCell);
        } else {
            this._entity.setPosition(pos[0], pos[1]);
        }
    }
};

TBSEntity_Sprite.prototype.updateShakeEffect = function () {
    var min = this._shakeEffect.power * 0.6;
    var max = this._shakeEffect.power * 1.6;
    var d = this._shakeEffect.duration--;
    if (d > 0) {
        this.x += LeUtilities.randValueBetween(min, max) * LeUtilities.randValueBetween(-1, 1);
        this.y += LeUtilities.randValueBetween(min, max) * LeUtilities.randValueBetween(-1, 1);
    }
};

TBSEntity_Sprite.prototype.updateBitmap = function () {
    var pose = this.getPose();
    this.bitmap = this._bitmaps[pose];
    var w = this.bitmap.width / (this._maxFrame[pose] + 1);
    var h = this.bitmap.height / 4;
    var x;
    var y;
    var frame = this._fixedFrame != null ? this._fixedFrame : this._frameCount;
    x = w * frame;
    y = (h * this._dir) / 2 - h;
    this.setFrame(x, y, w, h);
};

TBSEntity_Sprite.prototype.updateFrameCount = function () {
    var pose = this.getPose();
    if (this._frameCount > this._maxFrame[pose]) {
        this.onPosePlayed();
    } else {
        this._frameCount++;
    }
};

TBSEntity_Sprite.prototype.updatePopups = function () {
    if (this._popups.length === 0) return;
    this._popups.forEach(function (popup) {
        popup.update();
    }.bind(this));
    if (!this._popups[0].isPlaying()) {
        this.removePopup(this._popups[0]);
    }
};

TBSEntity_Sprite.prototype.removePopup = function (popup) {
    BattleManagerTBS.getLayer("movableInfo").removeChild(popup);
    this._popups.shift();
};

TBSEntity_Sprite.prototype.createBitmaps = function () {
    var battler = this._battler;
    var config = this.getConfig();
    var hue = this._entity.getSpriteHue();
    config.forEach(function (info) {
        this.processBitmapsConfig(info, hue);
    }.bind(this));
};

TBSEntity_Sprite.prototype.processBitmapsConfig = function (info, hue) {
    var pose = info[0];
    var filename = this.filenameID() + info[1];
    this._poses.push(pose);
    if (pose === "dead" && this._entity.hasNoCorpse()) {
        this._maxFrame["dead"] = 0;
        this._bitmaps["dead"] = new Bitmap(48, 48);
        this._frameLoaded++;
        return;
    }
    var fullBitmap = ImageManager.loadLeTBSBattler(filename, hue);
    fullBitmap.addLoadListener(this.createPoseBitmaps.bind(this, fullBitmap, pose, info));
};

TBSEntity_Sprite.prototype.createPoseBitmaps = function (fbitmap, pose, info) {
    var frames = info[2];
    this._maxFrame[pose] = frames - 1;
    this._bitmaps[pose] = fbitmap;
    this._frameLoaded++;
};

TBSEntity_Sprite.prototype.addPopup = function () {
    var sprite = new Sprite_Damage();
    sprite.x = this.x + this.width / 2;
    sprite.y = this.y;
    sprite.setup(this._battler);
    this._popups.push(sprite);
    BattleManagerTBS.getLayer("movableInfo").addChild(sprite);
};

TBSEntity_Sprite.prototype.newAnimation = function (id, mirror, delay) {
    var sprite = new Sprite_TBSEntityAnimation();
    sprite.setup(this, $dataAnimations[id], mirror, delay);
    if (this.parent)
        this.parent.addChild(sprite);
    else
        BattleManagerTBS.getLayer("animations").addChild(sprite);
    this._animationSprites.push(sprite);
};

TBSEntity_Sprite.prototype.checkLoopAnimations = function () {
    var anims = this._entity.getLoopAnimations();
    var exists = {};
    anims.forEach(function (id) {
        exists[id] = false;
    });
    this._animationSprites.forEach(function (sprite) {
        for (var i = 0; i < anims.length; i++) {
            if (sprite._animation.id === anims[i] && sprite.isPlaying())
                exists[anims[i]] = true;
        }
    });
    anims.forEach(function (id) {
        if (!exists[id]) {
            this.newAnimation(id, false, 0);
        }
    }.bind(this));
};

TBSEntity_Sprite.prototype.isReady = function () {
    return this._frameLoaded === this._poses.length;
};

TBSEntity_Sprite.prototype.getPose = function () {
    return this.isValidPose(this._pose) ? this._pose : "idle";
};

TBSEntity_Sprite.prototype.getConfig = function () {
    var battler = this._battler, id;
    if (this._entity.rpgObject().leTbs_spriteConfig)
        id = this._entity.rpgObject().leTbs_spriteConfig;
    else
        id = battler.isActor() ? battler.name() : battler.originalName();
    var config = Lecode.S_TBS.Config.Battler_Sprites[id];
    if (!config) config = Lecode.S_TBS.Config.Battler_Sprites["Default"];
    return config;
};

TBSEntity_Sprite.prototype.isValidPose = function (pose) {
    return this._poses.indexOf(pose) >= 0;
};

TBSEntity_Sprite.prototype.filenameID = function () {
    return this._entity.filenameID();
};


/*-------------------------------------------------------------------------
* TBSNeutralEntity
-------------------------------------------------------------------------*/
function TBSNeutralEntity() {
    this.initialize.apply(this, arguments);
}
TBSNeutralEntity.prototype = Object.create(TBSEntity.prototype);
TBSNeutralEntity.prototype.constructor = TBSNeutralEntity;

TBSNeutralEntity.prototype.initialize = function (layer, tbsEvent, enemyId) {
    this._tbsEvent = tbsEvent;
    this._isNeutral = true;
    var battler = new Game_Enemy(enemyId, 0, 0);
    TBSEntity.prototype.initialize.call(this, battler, layer);
};


/*-------------------------------------------------------------------------
* TBSEvent
-------------------------------------------------------------------------*/
function TBSEvent() {
    this.initialize.apply(this, arguments);
}

TBSEvent.prototype.initialize = function (event) {
    this._event = event;
    this._triggerType = null;
    this._obstacleForLOS = true;
    this._stopWhenStepped = false;
    this._tileEffect = null;
    this._oldPos = {};
    this._tiedMovingEntity = null;
    this.onEventPageSetup();
};

TBSEvent.prototype.onEventPageSetup = function () {
    this.setupFlags();
};

TBSEvent.prototype.onEventForceMoveRoute = function () {
    this.checkEntityOnEvent();
};

TBSEvent.prototype.setupFlags = function () {
    for (var i = 0; i < this._event.list().length; i++) {
        var command = this._event.list()[i];
        if (command && command.code === 108 || command.code === 408) {
            var comment = command.parameters[0];
            if (comment.match(/<LeTBS>\s?Trigger_Type\s?:\s?(.+)/i))
                this._triggerType = String(RegExp.$1).toLowerCase();
            if (comment.match(/<LeTBS>\s?Free_LOS/i))
                this._obstacleForLOS = true;
            if (comment.match(/<LeTBS>\s?Stop_On_Step/i))
                this._stopWhenStepped = true;
            if (comment.match(/<LeTBS>\s?Tile_Effect\s?:\s?(.+)/i))
                this._tileEffect = Number(RegExp.$1);
            if (comment.match(/<LeTBS>\s?Tied_Mark\s?:\s?(.+)/i))
                this._tiedMark = String(RegExp.$1).toLowerCase();
        }
    }
};

TBSEvent.prototype.update = function () {
    this.updateEntityMove();
};

TBSEvent.prototype.updateEntityMove = function () {
    if (this._tiedMovingEntity && (this.screenX() != this._oldPos.screenX || this.screenY() != this._oldPos.screenY)) {
        if (this._oldPos.screenX && this._oldPos.screenY) {
            var entity = this._tiedMovingEntity;
            var diffX = this._oldPos.screenX - this.screenX();
            var diffY = this._oldPos.screenY - this.screenY();
            entity.x -= diffX;
            entity.y -= diffY;
            var cell = BattleManagerTBS.getCellAt(this._event._realX, this._event._realY);
            if (cell)
                entity.setCell(cell);
        }
        this._oldPos.x = this._event._realX;
        this._oldPos.y = this._event._realY;
        this._oldPos.screenX = this.screenX();
        this._oldPos.screenY = this.screenY();
    }
};

TBSEvent.prototype.start = function () {
    this.checkEntityOnEvent();
    this._event.start();
};

TBSEvent.prototype.checkEntityOnEvent = function () {
    this._tiedMovingEntity = BattleManagerTBS.getEntityAt(this.x(), this.y());
};

TBSEvent.prototype.x = function () {
    return this._event.x;
};

TBSEvent.prototype.y = function () {
    return this._event.y;
};

TBSEvent.prototype.screenX = function () {
    return this._event._realX * $gameMap.tileWidth();
};

TBSEvent.prototype.screenY = function () {
    return this._event._realY * $gameMap.tileHeight();
};

TBSEvent.prototype.isObstacle = function () {
    return !this._event.isThrough() && this._event.isNormalPriority();
};

TBSEvent.prototype.isObstacleForLOS = function () {
    return !!this._obstacleForLOS;
};

TBSEvent.prototype.canTriggerByTouch = function () {
    return this._triggerType === "touch";
};

TBSEvent.prototype.canTriggerByStep = function () {
    return this._triggerType === "step_on";
};

TBSEvent.prototype.canTriggerAtTurnOrderEnd = function () {
    return this._triggerType === "turn_order_end";
};

TBSEvent.prototype.canTriggerAtBattleStart = function () {
    return this._triggerType === "battle_start";
};

TBSEvent.prototype.canTriggerAtBattleEnd = function () {
    return this._triggerType === "battle_end";
};


/*-------------------------------------------------------------------------
* TBSDirectionSelector
-------------------------------------------------------------------------*/
function TBSDirectionSelector() {
    this.initialize.apply(this, arguments);
}

TBSDirectionSelector.prototype.initialize = function (layer) {
    this._cell = null;
    this._battlerEntity = null;
    this.createSprite(layer);
};

TBSDirectionSelector.prototype.createSprite = function (layer) {
    var bitmap = ImageManager.loadLeTBS("DirectionSelector", 0);
    this._sprite = new Sprite(bitmap);
    this._sprite.anchor.x = 0.5;
    this._sprite.anchor.y = 0.5;
    this._sprite.opacity = 0;
    layer.addChild(this._sprite);
};

TBSDirectionSelector.prototype.set = function (cell, battler) {
    this._cell = cell;
    this._battlerEntity = battler;
    this._sprite.x = cell.x * $gameMap.tileWidth() + $gameMap.tileWidth() / 2;
    this._sprite.y = cell.y * $gameMap.tileHeight() + $gameMap.tileHeight() / 2;
    this._sprite.opacity = 255;
    this.setDir(battler.getDir());
};

TBSDirectionSelector.prototype.setDir = function (dir) {
    this._battlerEntity.setDir(dir);
    var r = 0;
    switch (dir) {
        case 2:
            r = 0;
            break;
        case 4:
            r = 90;
            break;
        case 6:
            r = 90 * 3;
            break;
        case 8:
            r = 90 * 2;
            break;
    }
    this._sprite.rotation = r * Math.PI / 180;
    SoundManager.playCursor();
};

TBSDirectionSelector.prototype.hide = function () {
    this._sprite.opacity = 0;
};


/*-------------------------------------------------------------------------
* Window_TBSConfirm
-------------------------------------------------------------------------*/
function Window_TBSConfirm() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSPositioning
-------------------------------------------------------------------------*/
function Window_TBSPositioning() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSPositioningConfirm
-------------------------------------------------------------------------*/
function Window_TBSPositioningConfirm() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSPositioningInfo
-------------------------------------------------------------------------*/
function Window_TBSPositioningInfo() {
    this.initialize.apply(this, arguments);
}
/*-------------------------------------------------------------------------
* Window_TBSStatus
-------------------------------------------------------------------------*/
function Window_TBSStatus() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSCommand
-------------------------------------------------------------------------*/
function Window_TBSCommand() {
    this.initialize.apply(this, arguments);
}

/*-------------------------------------------------------------------------
* Window_TBSEndCommand
-------------------------------------------------------------------------*/
function Window_TBSEndCommand() {
    this.initialize.apply(this, arguments);
}


/*=========================================================================
*	RTPs MODIFS
=========================================================================*/



/*-------------------------------------------------------------------------
* Game_BattlerBase
-------------------------------------------------------------------------*/
Game_BattlerBase.prototype.hasConfusionStateAttackAlly = function () {
    return this.confusionLevel() === 1;
};

Game_BattlerBase.prototype.hasConfusionStateAttackAnyone = function () {
    return this.confusionLevel() === 2;
};

Game_BattlerBase.prototype.hasConfusionStateAttackEnemy = function () {
    return this.confusionLevel() === 3;
};


/*-------------------------------------------------------------------------
* Game_Battler
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameBattler_initMembers = Game_Battler.prototype.initMembers;
Game_Battler.prototype.initMembers = function () {
    Lecode.S_TBS.oldGameBattler_initMembers.call(this);
    this._leTbsDirectionalDmg = 0;
};

Game_Battler.prototype.leTBS_setDirectionalDmgEffects = function (amount) {
    this._leTbsDirectionalDmg = amount;
};

Lecode.S_TBS.oldGameBattler_addNewState = Game_Battler.prototype.addNewState;
Game_Battler.prototype.addNewState = function (stateId) {
    if (LeUtilities.isScene("Scene_Battle") && Lecode.S_TBS.commandOn) {
        var state = $dataStates[stateId];
        var entity = BattleManagerTBS.getEntityByBattler(this);
        entity.changeMovePoints(state.leTbs_movePointsPlus);
    }
    Lecode.S_TBS.oldGameBattler_addNewState.call(this, stateId);
};

Game_Battler.prototype.rpgObject = function () {
    return this.isActor() ? this.actor() : this.enemy();
};


/*-------------------------------------------------------------------------
* Game_Action
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameAction_executeDamage = Game_Action.prototype.executeDamage;
Game_Action.prototype.executeDamage = function (target, value) {
    value += value * target._leTbsDirectionalDmg;
    Lecode.S_TBS.oldGameAction_executeDamage.call(this, target, Math.floor(value));
};


/*-------------------------------------------------------------------------
* Game_Event
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameEvent_setupPage = Game_Event.prototype.setupPage;
Game_Event.prototype.setupPage = function () {
    Lecode.S_TBS.oldGameEvent_setupPage.call(this);
    if (LeUtilities.isScene("Scene_Battle") && Lecode.S_TBS.commandOn) {
        BattleManagerTBS.onEventPageSetup(this);
    }
};

Lecode.S_TBS.oldGameEvent_forceMoveRoute = Game_Event.prototype.forceMoveRoute;
Game_Event.prototype.forceMoveRoute = function (route) {
    Lecode.S_TBS.oldGameEvent_forceMoveRoute.call(this, route);
    if (LeUtilities.isScene("Scene_Battle") && Lecode.S_TBS.commandOn) {
        BattleManagerTBS.onEventForceMoveRoute(this);
    }
};

/*-------------------------------------------------------------------------
* Game_Interpreter
-------------------------------------------------------------------------*/
Lecode.S_TBS.PCommand = {};
Lecode.S_TBS.old_pluginCommand = Game_Interpreter.prototype.pluginCommand;
Game_Interpreter.prototype.pluginCommand = function (command, args) {
    Lecode.S_TBS.old_pluginCommand.call(this, command, args);
    if (command === 'LeTBS') {
        switch (args[0]) {
            case 'ON':
                Lecode.S_TBS.commandOn = true;
                break;
            case 'OFF':
                Lecode.S_TBS.commandOn = false;
                break;
            case "Center":
                var cell = null;
                Lecode.S_TBS.PCommand.oldActiveCell = BattleManagerTBS._activeCell;
                if (args[1].match(/\((\d+)\,(\d+)\)/i)) {
                    var x = Number(RegExp.$1);
                    var y = Number(RegExp.$2);
                    cell = BattleManagerTBS.getCellAt(x, y);
                } else if (args[1] === "Old") {
                    cell = Lecode.S_TBS.PCommand.oldActiveCell;
                } else if (args[1] === "ActiveEntity") {
                    cell = BattleManagerTBS.activeEntity().getCell();
                } else if (args[1].match(/flaggedentity\((.+)\)/i)) {
                    cell = BattleManagerTBS.getFlaggedEntity(RegExp.$1).getCell();
                }
                if (cell) {
                    if (args[2] === "Select")
                        BattleManagerTBS.setCursorCell(cell);
                    else
                        BattleManagerTBS.centerCell(cell);
                }
                break;
            case "Wait":
                var value = Number(args[1]);
                BattleManagerTBS.wait(value);
                break;
            case "ResetEvents":
                LeUtilities.resetMapEvents();
                break;
            case "ForceAction":
                var entity = args[1];
                var skillId = Number(args[2]);
                var target = args[3];
                if (args[1].match(/flaggedentity\((.+)\)/i)) {
                    entity = BattleManagerTBS.getFlaggedEntity(RegExp.$1);
                }
                entity.forceAction(skillId, target);
                break;
            case "ForceEventTrigger":
                var eventId = Number(args[1]);
                BattleManagerTBS.executeEventsByForce(eventId);
                break;
        }
    }
};


/*-------------------------------------------------------------------------
* Game_Interpreter
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldGameInterpreter_character = Game_Interpreter.prototype.character;
Game_Interpreter.prototype.character = function (param) {
    if (Lecode.S_TBS.commandOn && $gameParty.inBattle()) {
        return $gameMap.event(param > 0 ? param : this._eventId);
    }
    return Lecode.S_TBS.oldGameInterpreter_character.call(this, param);
};


/*-------------------------------------------------------------------------
* TouchInput
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldTouchInput_clear = TouchInput.clear;
TouchInput.clear = function () {
    Lecode.S_TBS.oldTouchInput_clear.call(this);
    this._leTBSMoveData = {
        x: 0,
        y: 0
    };
};

Lecode.S_TBS.oldTouchInput_onMouseMove = TouchInput._onMouseMove;
TouchInput._onMouseMove = function (event) {
    Lecode.S_TBS.oldTouchInput_onMouseMove.call(this, event);
    var x = Graphics.pageToCanvasX(event.pageX);
    var y = Graphics.pageToCanvasY(event.pageY);
    this._leTBSMoveData.x = x;
    this._leTBSMoveData.y = y;
};


/*-------------------------------------------------------------------------
* DataManager
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldDMisDatabaseLoaded_method = DataManager.isDatabaseLoaded;
DataManager.isDatabaseLoaded = function () {
    if (!Lecode.S_TBS.oldDMisDatabaseLoaded_method.call(this)) return false;
    this.processLeTBSTags();
    return true;
};

DataManager.processLeTBSTags = function () {
    this.processLeTBSTagsForBattlers();
    this.processLeTBSTagsForEquipmentsAndStates();
    this.processLeTBSTagsForObjects();
};

DataManager.processLeTBSTagsForBattlers = function () {
    var groups = [$dataActors, $dataEnemies, $dataClasses];
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            var notedata = obj.note.split(/[\r\n]+/);
            var letbs = false;

            obj.leTbs_movePoints = Lecode.S_TBS.defaultMovePoints;
            obj.leTbs_moveScopeData = Lecode.S_TBS.defaultMoveScope;
            obj.leTbs_moveScopeParam = "";
            obj.leTbs_atkAnim = Lecode.S_TBS.defaultAttackAnimation;
            obj.leTbs_atkScopeData = Lecode.S_TBS.defaultAttackScope;
            obj.leTbs_atkAoeData = Lecode.S_TBS.defaultAttackAoE;
            obj.leTbs_atkSequenceData = Lecode.S_TBS.defaultAttackSequence;
            obj.leTbs_oneTimeMove = Lecode.S_TBS.oneTimeMove;
            obj.leTbs_oneTimeOffense = Lecode.S_TBS.oneTimeOffense;
            obj.leTbs_collapseAnim = Lecode.S_TBS.collapseAnimation;
            obj.leTbs_passOnAtkUse = false;
            obj.leTbs_aiPattern = Lecode.S_TBS.defaultAiPattern;
            obj.leTbs_passable = false;
            obj.leTbs_passableOnDeath = false;
            obj.leTbs_hasNoCorpse = false;
            obj.leTbs_canLayOnMe = false;
            obj.leTbs_canLayOnMeOnDeath = false;
            obj.leTbs_collisionDmgBonus = 0;
            obj.leTbs_collisionDmgBonusRate = 0;
            obj.leTbs_collisionDmgReduction = 0;
            obj.leTbs_collisionDmgReductionRate = 0;
            obj.leTbs_immuneKnockback = false;
            obj.leTbs_knockbackBonus = 0;
            obj.leTbs_knockbackReduction = 0;
            obj.leTbs_directionalDmgBonus = {
                face: 0,
                back: 0,
                side: 0
            };
            obj.leTbs_directionalDmgReduction = {
                face: 0,
                back: 0,
                side: 0
            };
            obj.leTbs_spriteName = null;
            obj.leTbs_spriteConfig = null;
            obj.leTbs_hideStatusWindow = false;
            obj.leTbs_spriteScaleX = 1.0;
            obj.leTbs_spriteScaleY = 1.0;
            obj.leTbs_spriteTone = [0, 0, 0, 0];
            obj.leTbs_spriteHue = 0;
            obj.leTbs_loopAnimation = null;
            obj.leTbs_aiNoAttack = false;

            for (var k = 0; k < notedata.length; k++) {
                var line = notedata[k];
                if (line.match(/<letbs>/i))
                    letbs = true;
                else if (line.match(/<\/letbs>/i))
                    letbs = false;

                if (letbs) {
                    if (line.match(/move_points\s?:\s?(.+)/i))
                        obj.leTbs_movePoints = Number(RegExp.$1);
                    else if (line.match(/move_scope\s?:\s?(.+)/i))
                        obj.leTbs_moveScopeData = String(RegExp.$1);
                    else if (line.match(/move_scope_options\s?:\s?((.|\n)*)/i))
                        obj.leTbs_moveScopeParam = String(RegExp.$1);
                    else if (line.match(/atk_anim\s?:\s?(.+)/i))
                        obj.leTbs_atkAnim = Number(RegExp.$1);
                    else if (line.match(/atk_scope\s?:\s?(.+)/i))
                        obj.leTbs_atkScopeData = String(RegExp.$1);
                    else if (line.match(/atk_aoe\s?:\s?(.+)/i))
                        obj.leTbs_atkAoeData = String(RegExp.$1);
                    else if (line.match(/atk_sequence\s?:\s?(.+)/i))
                        obj.leTbs_atkSequence = String(RegExp.$1);
                    else if (line.match(/one_time_move/i))
                        obj.leTbs_oneTimeMove = true;
                    else if (line.match(/one_time_offense/i))
                        obj.leTbs_oneTimeOffense = true;
                    else if (line.match(/collapse_anim\s?:\s?(.+)/i))
                        obj.leTbs_collapseAnim = Number(RegExp.$1);
                    else if (line.match(/pass_on_atk_use/i))
                        obj.leTbs_passOnAtkUse = true;
                    else if (line.match(/ai_pattern\s?:\s?(.+)/i))
                        obj.leTbs_aiPattern = String(RegExp.$1);
                    else if (line.match(/passable_on_death/i))
                        obj.leTbs_passableOnDeath = true;
                    else if (line.match(/passable/i))
                        obj.leTbs_passable = true;
                    else if (line.match(/has_no_corpse/i))
                        obj.leTbs_hasNoCorpse = true;
                    else if (line.match(/entities_can_lay_on_me/i))
                        obj.leTbs_canLayOnMe = true;
                    else if (line.match(/entities_can_lay_on_me_on_death/i))
                        obj.leTbs_canLayOnMeOnDeath = true;
                    else if (line.match(/collision_damage_bonus\s?:\s?(.+)/i))
                        obj.leTbs_collisionDmgBonus = Number(RegExp.$1);
                    else if (line.match(/collision_damage_bonus\%\s?:\s?(.+)/i))
                        obj.leTbs_collisionDmgBonusRate = Number(RegExp.$1);
                    else if (line.match(/collision_damage_reduction\s?:\s?(.+)/i))
                        obj.leTbs_collisionDmgReduction = Number(RegExp.$1);
                    else if (line.match(/collision_damage_reduction\%\s?:\s?(.+)/i))
                        obj.leTbs_collisionDmgReductionRate = Number(RegExp.$1);
                    else if (line.match(/immune_knockback/i))
                        obj.leTbs_immuneKnockback = true;
                    else if (line.match(/knockback_bonus\s?:\s?(.+)/i))
                        obj.leTbs_knockbackBonus = Number(RegExp.$1);
                    else if (line.match(/knockback_reduction\s?:\s?(.+)/i))
                        obj.leTbs_knockbackReduction = Number(RegExp.$1);
                    else if (line.match(/back_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.back = Number(RegExp.$1);
                    else if (line.match(/back_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.back = Number(RegExp.$1);
                    else if (line.match(/face_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.face = Number(RegExp.$1);
                    else if (line.match(/face_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.face = Number(RegExp.$1);
                    else if (line.match(/side_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.side = Number(RegExp.$1);
                    else if (line.match(/side_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.side = Number(RegExp.$1);
                    else if (line.match(/sprite_name\s?:\s?(.+)/i))
                        obj.leTbs_spriteName = String(RegExp.$1);
                    else if (line.match(/sprite_config\s?:\s?(.+)/i))
                        obj.leTbs_spriteConfig = String(RegExp.$1);
                    else if (line.match(/hide_status_window/i))
                        obj.leTbs_hideStatusWindow = true;
                    else if (line.match(/sprite_scale\s?:\s?(.+)/i)) {
                        var str = RegExp.$1.split(",");
                        obj.leTbs_spriteScaleX = Number(str[0].trim());
                        obj.leTbs_spriteScaleY = Number(str[1].trim());
                    }
                    else if (line.match(/sprite_tone\s?:\s?(.+)/i)) {
                        var str = RegExp.$1.split(",");
                        var r = Number(str[0].trim());
                        var g = Number(str[1].trim());
                        var b = Number(str[1].trim());
                        var gray = Number(str[1].trim());
                        obj.leTbs_spriteTone = [r, g, b, gray];
                    }
                    else if (line.match(/sprite_hue\s?:\s?(.+)/i))
                        obj.leTbs_spriteHue = Number(RegExp.$1);
                    else if (line.match(/loop_animation\s?:\s?(.+)/i))
                        obj.leTbs_loopAnimation = Number(RegExp.$1);
                    else if (line.match(/ai_no_attack/i))
                        obj.leTbs_aiNoAttack = true;
                }
            }
        }
    }
};

DataManager.processLeTBSTagsForEquipmentsAndStates = function () {
    var groups = [$dataWeapons, $dataArmors, $dataStates];
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            var notedata = obj.note.split(/[\r\n]+/);
            var letbs = false;

            obj.leTbs_movePointsPlus = 0;
            obj.leTbs_scopeData = Lecode.S_TBS.defaultAttackScope;
            obj.leTbs_aoeData = null;
            obj.leTbs_sequenceData = null;
            obj.leTbs_moveScopeData = null;
            obj.leTbs_moveScopeParam = null;
            obj.leTbs_passable = false;
            obj.leTbs_passableOnDeath = false;
            obj.leTbs_hasNoCorpse = false;
            obj.leTbs_canLayOnMe = false;
            obj.leTbs_canLayOnMeOnDeath = false;
            obj.leTbs_collisionDmgBonus = 0;
            obj.leTbs_collisionDmgBonusRate = 0;
            obj.leTbs_collisionDmgReduction = 0;
            obj.leTbs_collisionDmgReductionRate = 0;
            obj.leTbs_immuneKnockback = false;
            obj.leTbs_knockbackBonus = 0;
            obj.leTbs_knockbackReduction = 0;
            obj.leTbs_directionalDmgBonus = {
                face: 0,
                back: 0,
                side: 0
            };
            obj.leTbs_directionalDmgReduction = {
                face: 0,
                back: 0,
                side: 0
            };
            obj.leTbs_onlyDeadTargets = false;
            obj.leTbs_allowDeadTargets = false;
            obj.leTbs_loopAnimation = null;
            obj.leTbs_focusedByAiFor = {};

            for (var k = 0; k < notedata.length; k++) {
                var line = notedata[k];
                if (line.match(/<letbs>/i))
                    letbs = true;
                else if (line.match(/<\/letbs>/i))
                    letbs = false;

                if (letbs) {
                    if (line.match(/move_points\s?:\s?(.+)/i))
                        obj.leTbs_movePointsPlus = Number(RegExp.$1);
                    else if (line.match(/scope\s?:\s?(.+)/i))
                        obj.leTbs_scopeData = String(RegExp.$1);
                    else if (line.match(/aoe\s?:\s?(.+)/i))
                        obj.leTbs_aoeData = String(RegExp.$1);
                    else if (line.match(/sequence\s?:\s?(.+)/i))
                        obj.leTbs_sequenceData = String(RegExp.$1);
                    else if (line.match(/move_scope\s?:\s?(.+)/i))
                        obj.leTbs_moveScopeData = String(RegExp.$1);
                    else if (line.match(/move_scope_options\s?:\s?((.|\n)*)/i))
                        obj.leTbs_moveScopeParam = String(RegExp.$1);
                    else if (line.match(/passable_on_death/i))
                        obj.leTbs_passableOnDeath = true;
                    else if (line.match(/passable/i))
                        obj.leTbs_passable = true;
                    else if (line.match(/has_no_corpse/i))
                        obj.leTbs_hasNoCorpse = true;
                    else if (line.match(/entities_can_lay_on_me/i))
                        obj.leTbs_canLayOnMe = true;
                    else if (line.match(/entities_can_lay_on_me_on_death/i))
                        obj.leTbs_canLayOnMeOnDeath = true;
                    else if (line.match(/collision_damage_bonus\s?:\s?(.+)/i))
                        obj.leTbs_collisionDmgBonus = Number(RegExp.$1);
                    else if (line.match(/collision_damage_bonus\%\s?:\s?(.+)/i))
                        obj.leTbs_collisionDmgBonusRate = Number(RegExp.$1);
                    else if (line.match(/collision_damage_reduction\s?:\s?(.+)/i))
                        obj.leTbs_collisionDmgReduction = Number(RegExp.$1);
                    else if (line.match(/collision_damage_reduction\%\s?:\s?(.+)/i))
                        obj.leTbs_collisionDmgReductionRate = Number(RegExp.$1);
                    else if (line.match(/immune_knockback/i))
                        obj.leTbs_immuneKnockback = true;
                    else if (line.match(/knockback_bonus\s?:\s?(.+)/i))
                        obj.leTbs_knockbackBonus = Number(RegExp.$1);
                    else if (line.match(/knockback_reduction\s?:\s?(.+)/i))
                        obj.leTbs_knockbackReduction = Number(RegExp.$1);
                    else if (line.match(/knockback_bonus\s?:\s?(.+)/i))
                        obj.leTbs_knockbackBonus = Number(RegExp.$1);
                    else if (line.match(/knockback_reduction\s?:\s?(.+)/i))
                        obj.leTbs_knockbackReduction = Number(RegExp.$1);
                    else if (line.match(/back_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.back = Number(RegExp.$1);
                    else if (line.match(/back_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.back = Number(RegExp.$1);
                    else if (line.match(/face_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.face = Number(RegExp.$1);
                    else if (line.match(/face_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.face = Number(RegExp.$1);
                    else if (line.match(/side_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.side = Number(RegExp.$1);
                    else if (line.match(/side_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.side = Number(RegExp.$1);
                    else if (line.match(/only_dead_targets/i))
                        obj.leTbs_onlyDeadTargets = true;
                    else if (line.match(/allow_dead_targets/i))
                        obj.leTbs_allowDeadTargets = true;
                    else if (line.match(/loop_animation\s?:\s?(.+)/i))
                        obj.leTbs_loopAnimation = Number(RegExp.$1);
                    else if (line.match(/focused_by_ai_for_(.+)\s?:\s?(.+)/i))
                        obj.leTbs_focusedByAiFor[RegExp.$1] = Number(RegExp.$2);
                }
            }
        }
    }
};

DataManager.processLeTBSTagsForObjects = function () {
    var groups = [$dataSkills, $dataItems, $dataWeapons];
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        for (var j = 1; j < group.length; j++) {
            var obj = group[j];
            var notedata = obj.note.split(/[\r\n]+/);
            var letbs = false;
            var letbs_ai = false;
            var letbs_sequence = false;

            obj.leTbs_scopeData = null;
            obj.leTbs_aoeData = null;
            obj.leTbs_sequenceData = null;
            obj.leTbs_passOnUse = false;
            obj.leTbs_maxUse = 1;
            obj.leTbs_scopeParam = [];
            obj.leTbs_aoeParam = [];
            obj.leTbs_collisionFormula = null;
            obj.leTbs_directionalDmgBonus = {
                face: 0,
                back: 0,
                side: 0
            };
            obj.leTbs_directionalDmgReduction = {
                face: 0,
                back: 0,
                side: 0
            };
            obj.leTbs_aiConfig = {
                type: "",
                use_condition: "true",
                escape_condition: "true",
                rush_condition: "true",
                use_on_dead: false,
                maximise_targets: false,
                summon_near: "enemies",
                avoid_friendly_fire: 0
            };
            obj.leTbs_sequence = [];
            obj.leTbs_loopAnimation = null;
            obj.leTbs_changeMovePoints = "0";

            for (var k = 0; k < notedata.length; k++) {
                var line = notedata[k];
                if (line.match(/<letbs>/i))
                    letbs = true;
                else if (line.match(/<\/letbs>/i))
                    letbs = false;
                else if (line.match(/<letbs_ai>/i))
                    letbs_ai = true;
                else if (line.match(/<\/letbs_ai>/i))
                    letbs_ai = false;
                else if (line.match(/<letbs_sequence>/i))
                    letbs_sequence = true;
                else if (line.match(/<\/letbs_sequence>/i))
                    letbs_sequence = false;

                if (letbs) {
                    if (line.match(/scope\s?:\s?(.+)/i))
                        obj.leTbs_scopeData = String(RegExp.$1);
                    else if (line.match(/aoe\s?:\s?(.+)/i))
                        obj.leTbs_aoeData = String(RegExp.$1);
                    else if (line.match(/sequence\s?:\s?(.+)/i))
                        obj.leTbs_sequenceData = String(RegExp.$1);
                    else if (line.match(/pass_on_use/i))
                        obj.leTbs_passOnUse = true;
                    else if (line.match(/max_use:\s?:\s?(.+)/i))
                        obj.leTbs_maxUse = Number(RegExp.$1);
                    else if (line.match(/scope_options\s?:\s?((.|\n)*)/i))
                        obj.leTbs_scopeParam = String(RegExp.$1);
                    else if (line.match(/aoe_options\s?:\s?((.|\n)*)/i))
                        obj.leTbs_aoeParam = String(RegExp.$1);
                    else if (line.match(/collision_formula\s?:\s?(.+)/i))
                        obj.leTbs_collisionFormula = String(RegExp.$1);
                    else if (line.match(/knockback_bonus\s?:\s?(.+)/i))
                        obj.leTbs_knockbackBonus = Number(RegExp.$1);
                    else if (line.match(/knockback_reduction\s?:\s?(.+)/i))
                        obj.leTbs_knockbackReduction = Number(RegExp.$1);
                    else if (line.match(/back_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.back = Number(RegExp.$1);
                    else if (line.match(/back_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.back = Number(RegExp.$1);
                    else if (line.match(/face_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.face = Number(RegExp.$1);
                    else if (line.match(/face_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.face = Number(RegExp.$1);
                    else if (line.match(/side_dmg_bonus\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgBonus.side = Number(RegExp.$1);
                    else if (line.match(/side_dmg_reduction\s?:\s?(.+)/i))
                        obj.leTbs_directionalDmgReduction.side = Number(RegExp.$1);
                    else if (line.match(/loop_animation\s?:\s?(.+)/i))
                        obj.leTbs_loopAnimation = Number(RegExp.$1);
                    else if (line.match(/change_move_points\s?:\s?(.+)/i))
                        obj.leTbs_changeMovePoints = String(RegExp.$1);
                }
                else if (letbs_ai) {
                    if (line.match(/type\s?:\s?(.+)/i))
                        obj.leTbs_aiConfig.type = String(RegExp.$1);
                    else if (line.match(/use_condition\s?:\s?(.+)/i))
                        obj.leTbs_aiConfig.use_condition = String(RegExp.$1);
                    else if (line.match(/escape_condition\s?:\s?(.+)/i))
                        obj.leTbs_aiConfig.escape_condition = String(RegExp.$1);
                    else if (line.match(/rush_condition\s?:\s?(.+)/i))
                        obj.leTbs_aiConfig.rush_condition = String(RegExp.$1);
                    else if (line.match(/use_on_dead/i))
                        obj.leTbs_aiConfig.use_on_dead = true;
                    else if (line.match(/maximise_targets/i))
                        obj.leTbs_aiConfig.maximise_targets = true;
                    else if (line.match(/avoid_friendly_fire\s?:\s?(.+)\%/i))
                        obj.leTbs_aiConfig.avoid_friendly_fire = Number(RegExp.$1) * 0.01;
                    else if (line.match(/summon_near\s?:\s?(.+)/i))
                        obj.leTbs_aiConfig.summon_near = String(RegExp.$1);
                }
                else if (letbs_sequence) {
                    obj.leTbs_sequence.push(line);
                }
            }
        }
    }
};

/*-------------------------------------------------------------------------
* ImageManager
-------------------------------------------------------------------------*/
ImageManager.loadLeTBS = function (filename, hue) {
    return this.loadBitmap('img/leTBS/', filename, hue, true);
};

ImageManager.loadLeTBSBattler = function (filename, hue) {
    return this.loadBitmap('img/leTBS/Battlers/', filename, hue, true);
};

ImageManager.loadLeTBSStatus = function (filename, hue) {
    return this.loadBitmap('img/leTBS/Status/', filename, hue, true);
};

ImageManager.loadLeTBSProjectile = function (filename, hue) {
    return this.loadBitmap('img/leTBS/Projectiles/', filename, hue, true);
};

ImageManager.loadLeTBS("Battle_Start");

/*-------------------------------------------------------------------------
* Game_Map
-------------------------------------------------------------------------*/
Lecode.S_TBS.oldIsPassable_method = Game_Map.prototype.isPassable;
Game_Map.prototype.isPassable = function (x, y, d) {
    var result = Lecode.S_TBS.oldIsPassable_method.call(this, x, y, d);
    if (LeUtilities.isScene("Scene_Battle") && BattleManagerTBS.activeEntity()) {
        var entityCell = BattleManagerTBS.activeEntity().getCell();
        var cell = BattleManagerTBS.getCellAt(x, y);
        if (cell && !(entityCell.x == x && entityCell.y == y) && cell.isThereEntity())
            return false;
    }
    return result;
};


/*-------------------------------------------------------------------------
* TBS_FloatingAction
-------------------------------------------------------------------------*/
function TBS_FloatingAction() {
    this.initialize.apply(this, arguments);
}
TBS_FloatingAction.prototype = Object.create(Game_Action.prototype);
TBS_FloatingAction.prototype.constructor = TBS_FloatingAction;

TBS_FloatingAction.prototype.initialize = function (subject, forcing) {
    Game_Action.prototype.initialize.call(this, subject, forcing);
};

TBS_FloatingAction.prototype.setSubject = function (subject) {
    this._subject = subject;
};

TBS_FloatingAction.prototype.subject = function () {
    return this._subject;
};
